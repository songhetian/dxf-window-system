"use strict";
const electron = require("electron");
const path = require("path");
const require$$0$2 = require("node:events");
const require$$0$1 = require("node:util");
const require$$0$3 = require("node:http");
const require$$0$4 = require("node:diagnostics_channel");
const require$$1 = require("node:https");
const require$$2 = require("node:http2");
const require$$3$1 = require("node:dns");
const require$$4 = require("node:os");
const require$$0$6 = require("node:stream");
const fs = require("fs");
const require$$1$1 = require("events");
const require$$2$1 = require("util");
const require$$5 = require("assert");
const require$$2$2 = require("worker_threads");
const require$$0$5 = require("module");
const require$$1$2 = require("node:fs");
const require$$3$2 = require("node:path");
const require$$4$2 = require("node:url");
const require$$4$1 = require("url");
const require$$7 = require("buffer");
const require$$0$7 = require("node:async_hooks");
const require$$0$8 = require("node:assert");
const require$$0$9 = require("node:crypto");
const Database = require("better-sqlite3");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var fastify$1 = { exports: {} };
var queue = { exports: {} };
var reusify_1;
var hasRequiredReusify;
function requireReusify() {
  if (hasRequiredReusify) return reusify_1;
  hasRequiredReusify = 1;
  function reusify(Constructor) {
    var head = new Constructor();
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor();
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  }
  reusify_1 = reusify;
  return reusify_1;
}
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue.exports;
  hasRequiredQueue = 1;
  var reusify = requireReusify();
  function fastqueue(context2, worker, _concurrency) {
    if (typeof context2 === "function") {
      _concurrency = worker;
      worker = context2;
      context2 = null;
    }
    if (!(_concurrency >= 1)) {
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler2 = null;
    var self2 = {
      push,
      drain: noop2,
      saturated: noop2,
      pause,
      paused: false,
      get concurrency() {
        return _concurrency;
      },
      set concurrency(value) {
        if (!(value >= 1)) {
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        }
        _concurrency = value;
        if (self2.paused) return;
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      },
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop2,
      kill,
      killAndDrain,
      error: error2,
      abort
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused) return;
      self2.paused = false;
      if (queueHead === null) {
        _running++;
        release();
        return;
      }
      for (; queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context2;
      current.release = release;
      current.value = value;
      current.callback = done || noop2;
      current.errorHandler = errorHandler2;
      if (_running >= _concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context2, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context2;
      current.release = release;
      current.value = value;
      current.callback = done || noop2;
      current.errorHandler = errorHandler2;
      if (_running >= _concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context2, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next && _running <= _concurrency) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context2, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop2;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop2;
    }
    function abort() {
      var current = queueHead;
      queueHead = null;
      queueTail = null;
      while (current) {
        var next = current.next;
        var callback = current.callback;
        var errorHandler3 = current.errorHandler;
        var val = current.value;
        var context3 = current.context;
        current.value = null;
        current.callback = noop2;
        current.errorHandler = null;
        if (errorHandler3) {
          errorHandler3(new Error("abort"), val);
        }
        callback.call(context3, new Error("abort"));
        current.release(current);
        current = next;
      }
      self2.drain = noop2;
    }
    function error2(handler) {
      errorHandler2 = handler;
    }
  }
  function noop2() {
  }
  function Task() {
    this.value = null;
    this.callback = noop2;
    this.next = null;
    this.release = noop2;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err2, result) {
      var callback = self2.callback;
      var errorHandler2 = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop2;
      if (self2.errorHandler) {
        errorHandler2(err2, val);
      }
      callback.call(self2.context, err2, result);
      self2.release(self2);
    };
  }
  function queueAsPromised(context2, worker, _concurrency) {
    if (typeof context2 === "function") {
      _concurrency = worker;
      worker = context2;
      context2 = null;
    }
    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function(res2) {
        cb(null, res2);
      }, cb);
    }
    var queue2 = fastqueue(context2, asyncWrapper, _concurrency);
    var pushCb = queue2.push;
    var unshiftCb = queue2.unshift;
    queue2.push = push;
    queue2.unshift = unshift;
    queue2.drained = drained;
    return queue2;
    function push(value) {
      var p = new Promise(function(resolve2, reject) {
        pushCb(value, function(err2, result) {
          if (err2) {
            reject(err2);
            return;
          }
          resolve2(result);
        });
      });
      p.catch(noop2);
      return p;
    }
    function unshift(value) {
      var p = new Promise(function(resolve2, reject) {
        unshiftCb(value, function(err2, result) {
          if (err2) {
            reject(err2);
            return;
          }
          resolve2(result);
        });
      });
      p.catch(noop2);
      return p;
    }
    function drained() {
      var p = new Promise(function(resolve2) {
        process.nextTick(function() {
          if (queue2.idle()) {
            resolve2();
          } else {
            var previousDrain = queue2.drain;
            queue2.drain = function() {
              if (typeof previousDrain === "function") previousDrain();
              resolve2();
              queue2.drain = previousDrain;
            };
          }
        });
      });
      return p;
    }
  }
  queue.exports = fastqueue;
  queue.exports.promise = queueAsPromised;
  return queue.exports;
}
var error$1 = { exports: {} };
var hasRequiredError$1;
function requireError$1() {
  if (hasRequiredError$1) return error$1.exports;
  hasRequiredError$1 = 1;
  const { format: format2 } = require$$0$1;
  function toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
  const FastifyGenericErrorSymbol = /* @__PURE__ */ Symbol.for("fastify-error-generic");
  function createError2(code2, message, statusCode = 500, Base = Error, captureStackTrace2 = createError2.captureStackTrace) {
    const shouldCreateFastifyGenericError = code2 === FastifyGenericErrorSymbol;
    if (shouldCreateFastifyGenericError) {
      code2 = "FST_ERR";
    }
    if (!code2) throw new Error("Fastify error code must not be empty");
    if (!message) throw new Error("Fastify error message must not be empty");
    code2 = code2.toUpperCase();
    !statusCode && (statusCode = void 0);
    const FastifySpecificErrorSymbol = /* @__PURE__ */ Symbol.for(`fastify-error ${code2}`);
    function FastifyError(...args) {
      if (!new.target) {
        return new FastifyError(...args);
      }
      this.code = code2;
      this.name = "FastifyError";
      this.statusCode = statusCode;
      const lastElement = args.length - 1;
      if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
        this.cause = args.pop().cause;
      }
      this.message = format2(message, ...args);
      Error.stackTraceLimit && captureStackTrace2 && Error.captureStackTrace(this, FastifyError);
    }
    FastifyError.prototype = Object.create(Base.prototype, {
      constructor: {
        value: FastifyError,
        enumerable: false,
        writable: true,
        configurable: true
      },
      [FastifyGenericErrorSymbol]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: false
      },
      [FastifySpecificErrorSymbol]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: false
      }
    });
    if (shouldCreateFastifyGenericError) {
      Object.defineProperty(FastifyError, Symbol.hasInstance, {
        value(instance) {
          return instance && instance[FastifyGenericErrorSymbol];
        },
        configurable: false,
        writable: false,
        enumerable: false
      });
    } else {
      Object.defineProperty(FastifyError, Symbol.hasInstance, {
        value(instance) {
          return instance && instance[FastifySpecificErrorSymbol];
        },
        configurable: false,
        writable: false,
        enumerable: false
      });
    }
    FastifyError.prototype[Symbol.toStringTag] = "Error";
    FastifyError.prototype.toString = toString;
    return FastifyError;
  }
  createError2.captureStackTrace = true;
  const FastifyErrorConstructor = createError2(FastifyGenericErrorSymbol, "Fastify Error", 500, Error);
  error$1.exports = createError2;
  error$1.exports.FastifyError = FastifyErrorConstructor;
  error$1.exports.default = createError2;
  error$1.exports.createError = createError2;
  return error$1.exports;
}
var errors$3;
var hasRequiredErrors$3;
function requireErrors$3() {
  if (hasRequiredErrors$3) return errors$3;
  hasRequiredErrors$3 = 1;
  const { createError: createError2 } = requireError$1();
  errors$3 = {
    AVV_ERR_EXPOSE_ALREADY_DEFINED: createError2(
      "AVV_ERR_EXPOSE_ALREADY_DEFINED",
      "'%s' is already defined, specify an expose option for '%s'"
    ),
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError2(
      "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
      "'%s' is already defined"
    ),
    AVV_ERR_CALLBACK_NOT_FN: createError2(
      "AVV_ERR_CALLBACK_NOT_FN",
      "Callback for '%s' hook is not a function. Received: '%s'"
    ),
    AVV_ERR_PLUGIN_NOT_VALID: createError2(
      "AVV_ERR_PLUGIN_NOT_VALID",
      "Plugin must be a function or a promise. Received: '%s'"
    ),
    AVV_ERR_ROOT_PLG_BOOTED: createError2(
      "AVV_ERR_ROOT_PLG_BOOTED",
      "Root plugin has already booted"
    ),
    AVV_ERR_PARENT_PLG_LOADED: createError2(
      "AVV_ERR_PARENT_PLG_LOADED",
      "Impossible to load '%s' plugin because the parent '%s' was already loaded"
    ),
    AVV_ERR_READY_TIMEOUT: createError2(
      "AVV_ERR_READY_TIMEOUT",
      "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
    ),
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError2(
      "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
      "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
    )
  };
  return errors$3;
}
var symbols$2;
var hasRequiredSymbols$2;
function requireSymbols$2() {
  if (hasRequiredSymbols$2) return symbols$2;
  hasRequiredSymbols$2 = 1;
  const kAvvio = /* @__PURE__ */ Symbol("avvio.Boot");
  const kIsOnCloseHandler = /* @__PURE__ */ Symbol("isOnCloseHandler");
  const kThenifyDoNotWrap = /* @__PURE__ */ Symbol("avvio.ThenifyDoNotWrap");
  const kUntrackNode = /* @__PURE__ */ Symbol("avvio.TimeTree.untrackNode");
  const kTrackNode = /* @__PURE__ */ Symbol("avvio.TimeTree.trackNode");
  const kGetParent = /* @__PURE__ */ Symbol("avvio.TimeTree.getParent");
  const kGetNode = /* @__PURE__ */ Symbol("avvio.TimeTree.getNode");
  const kAddNode = /* @__PURE__ */ Symbol("avvio.TimeTree.addNode");
  const kPluginMeta = /* @__PURE__ */ Symbol.for("plugin-meta");
  symbols$2 = {
    kAvvio,
    kIsOnCloseHandler,
    kThenifyDoNotWrap,
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode,
    kPluginMeta
  };
  return symbols$2;
}
var timeTree;
var hasRequiredTimeTree;
function requireTimeTree() {
  if (hasRequiredTimeTree) return timeTree;
  hasRequiredTimeTree = 1;
  const {
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode
  } = requireSymbols$2();
  class TimeTree {
    constructor() {
      this.root = null;
      this.tableId = /* @__PURE__ */ new Map();
      this.tableLabel = /* @__PURE__ */ new Map();
    }
    /**
     * @param {TimeTreeNode} node
     */
    [kTrackNode](node2) {
      this.tableId.set(node2.id, node2);
      if (this.tableLabel.has(node2.label)) {
        this.tableLabel.get(node2.label).push(node2);
      } else {
        this.tableLabel.set(node2.label, [node2]);
      }
    }
    /**
     * @param {TimeTreeNode} node
     */
    [kUntrackNode](node2) {
      this.tableId.delete(node2.id);
      const labelNode = this.tableLabel.get(node2.label);
      labelNode.pop();
      if (labelNode.length === 0) {
        this.tableLabel.delete(node2.label);
      }
    }
    /**
     * @param {string} parent
     * @returns {TimeTreeNode}
     */
    [kGetParent](parent) {
      if (parent === null) {
        return null;
      } else if (this.tableLabel.has(parent)) {
        const parentNode = this.tableLabel.get(parent);
        return parentNode[parentNode.length - 1];
      } else {
        return null;
      }
    }
    /**
     *
     * @param {string} nodeId
     * @returns {TimeTreeNode}
     */
    [kGetNode](nodeId) {
      return this.tableId.get(nodeId);
    }
    /**
     * @param {string} parent
     * @param {string} label
     * @param {number} start
     * @returns {TimeTreeNode["id"]}
     */
    [kAddNode](parent, label, start) {
      const parentNode = this[kGetParent](parent);
      const isRoot = parentNode === null;
      if (isRoot) {
        this.root = {
          parent: null,
          id: "root",
          label,
          nodes: [],
          start,
          stop: null,
          diff: -1
        };
        this[kTrackNode](this.root);
        return this.root.id;
      }
      const nodeId = `${label}-${Math.random()}`;
      const childNode = {
        parent,
        id: nodeId,
        label,
        nodes: [],
        start,
        stop: null,
        diff: -1
      };
      parentNode.nodes.push(childNode);
      this[kTrackNode](childNode);
      return nodeId;
    }
    /**
     * @param {string} parent
     * @param {string} label
     * @param {number|undefined} start
     * @returns {TimeTreeNode["id"]}
     */
    start(parent, label, start = Date.now()) {
      return this[kAddNode](parent, label, start);
    }
    /**
     * @param {string} nodeId
     * @param {number|undefined} stop
     */
    stop(nodeId, stop = Date.now()) {
      const node2 = this[kGetNode](nodeId);
      if (node2) {
        node2.stop = stop;
        node2.diff = node2.stop - node2.start || 0;
        this[kUntrackNode](node2);
      }
    }
    /**
     * @returns {TimeTreeNode}
     */
    toJSON() {
      return Object.assign({}, this.root);
    }
    /**
     * @returns {string}
     */
    prettyPrint() {
      return prettyPrintTimeTree(this.toJSON());
    }
  }
  function prettyPrintTimeTree(obj, prefix = "") {
    let result = prefix;
    const nodesCount = obj.nodes.length;
    const lastIndex = nodesCount - 1;
    result += `${obj.label} ${obj.diff} ms
`;
    for (let i = 0; i < nodesCount; ++i) {
      const node2 = obj.nodes[i];
      const prefix_ = prefix + (i === lastIndex ? "  " : "│ ");
      result += prefix;
      result += i === lastIndex ? "└─" : "├─";
      result += node2.nodes.length === 0 ? "─ " : "┬ ";
      result += prettyPrintTimeTree(node2, prefix_).slice(prefix.length + 2);
    }
    return result;
  }
  timeTree = {
    TimeTree
  };
  return timeTree;
}
var debug_1$1;
var hasRequiredDebug$1;
function requireDebug$1() {
  if (hasRequiredDebug$1) return debug_1$1;
  hasRequiredDebug$1 = 1;
  const { debuglog } = require$$0$1;
  const debug = debuglog("avvio");
  debug_1$1 = {
    debug
  };
  return debug_1$1;
}
var createPromise_1;
var hasRequiredCreatePromise;
function requireCreatePromise() {
  if (hasRequiredCreatePromise) return createPromise_1;
  hasRequiredCreatePromise = 1;
  function createPromise() {
    const obj = {
      resolve: null,
      reject: null,
      promise: null
    };
    obj.promise = new Promise((resolve2, reject) => {
      obj.resolve = resolve2;
      obj.reject = reject;
    });
    return obj;
  }
  createPromise_1 = {
    createPromise
  };
  return createPromise_1;
}
var getPluginName_1;
var hasRequiredGetPluginName$1;
function requireGetPluginName$1() {
  if (hasRequiredGetPluginName$1) return getPluginName_1;
  hasRequiredGetPluginName$1 = 1;
  const { kPluginMeta } = requireSymbols$2();
  function getPluginName2(plugin2, options) {
    if (plugin2[kPluginMeta]?.name) {
      return plugin2[kPluginMeta].name;
    }
    if (options?.name) {
      return options.name;
    }
    if (plugin2.name) {
      return plugin2.name;
    } else {
      return plugin2.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
    }
  }
  getPluginName_1 = {
    getPluginName: getPluginName2
  };
  return getPluginName_1;
}
var isPromiseLike_1;
var hasRequiredIsPromiseLike;
function requireIsPromiseLike() {
  if (hasRequiredIsPromiseLike) return isPromiseLike_1;
  hasRequiredIsPromiseLike = 1;
  function isPromiseLike(maybePromiseLike) {
    return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
  }
  isPromiseLike_1 = {
    isPromiseLike
  };
  return isPromiseLike_1;
}
var plugin$1;
var hasRequiredPlugin$1;
function requirePlugin$1() {
  if (hasRequiredPlugin$1) return plugin$1;
  hasRequiredPlugin$1 = 1;
  const { EventEmitter } = require$$0$2;
  const { inherits } = require$$0$1;
  const { debug } = requireDebug$1();
  const { createPromise } = requireCreatePromise();
  const { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = requireErrors$3();
  const { getPluginName: getPluginName2 } = requireGetPluginName$1();
  const { isPromiseLike } = requireIsPromiseLike();
  function Plugin(queue2, func, options, isAfter, timeout) {
    this.queue = queue2;
    this.func = func;
    this.options = options;
    this.isAfter = isAfter;
    this.timeout = timeout;
    this.started = false;
    this.name = getPluginName2(func, options);
    this.queue.pause();
    this._error = null;
    this.loaded = false;
    this._promise = null;
    this.startTime = null;
  }
  inherits(Plugin, EventEmitter);
  Plugin.prototype.exec = function(server2, callback) {
    debug("exec", this.name);
    this.server = server2;
    const func = this.func;
    const name = this.name;
    let completed = false;
    this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
    let timer = null;
    const done = (execErr) => {
      if (completed) {
        debug("loading complete", name);
        return;
      }
      this._error = execErr;
      if (execErr) {
        debug("exec errored", name);
      } else {
        debug("exec completed", name);
      }
      completed = true;
      if (timer) {
        clearTimeout(timer);
      }
      callback(execErr);
    };
    if (this.timeout > 0) {
      debug("setting up timeout", name, this.timeout);
      timer = setTimeout(function() {
        debug("timed out", name);
        timer = null;
        const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
        readyTimeoutErr.fn = func;
        done(readyTimeoutErr);
      }, this.timeout);
    }
    this.started = true;
    this.startTime = Date.now();
    this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
    const maybePromiseLike = func(this.server, this.options, done);
    if (isPromiseLike(maybePromiseLike)) {
      debug("exec: resolving promise", name);
      maybePromiseLike.then(
        () => process.nextTick(done),
        (e) => process.nextTick(done, e)
      );
    } else if (func.length < 3) {
      done();
    }
  };
  Plugin.prototype.loadedSoFar = function() {
    debug("loadedSoFar", this.name);
    if (this.loaded) {
      return Promise.resolve();
    }
    const setup = () => {
      this.server.after((afterErr, callback) => {
        this._error = afterErr;
        this.queue.pause();
        if (this._promise) {
          if (afterErr) {
            debug("rejecting promise", this.name, afterErr);
            this._promise.reject(afterErr);
          } else {
            debug("resolving promise", this.name);
            this._promise.resolve();
          }
          this._promise = null;
        }
        process.nextTick(callback, afterErr);
      });
      this.queue.resume();
    };
    let res2;
    if (!this._promise) {
      this._promise = createPromise();
      res2 = this._promise.promise;
      if (!this.server) {
        this.on("start", setup);
      } else {
        setup();
      }
    } else {
      res2 = Promise.resolve();
    }
    return res2;
  };
  Plugin.prototype.enqueue = function(plugin2, callback) {
    debug("enqueue", this.name, plugin2.name);
    this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
    this.queue.push(plugin2, callback);
  };
  Plugin.prototype.finish = function(err2, callback) {
    debug("finish", this.name, err2);
    const done = () => {
      if (this.loaded) {
        return;
      }
      debug("loaded", this.name);
      this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
      this.loaded = true;
      callback(err2);
    };
    if (err2) {
      if (this._promise) {
        this._promise.reject(err2);
        this._promise = null;
      }
      done();
      return;
    }
    const check = () => {
      debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
      if (this.queue.length() === 0 && this.queue.running() === 0) {
        if (this._promise) {
          const wrap = () => {
            debug("wrap");
            queueMicrotask(check);
          };
          this._promise.resolve();
          this._promise.promise.then(wrap, wrap);
          this._promise = null;
        } else {
          done();
        }
      } else {
        debug("delayed", this.name);
        this.queue.drain = () => {
          debug("drain", this.name);
          this.queue.drain = noop2;
          queueMicrotask(check);
        };
      }
    };
    queueMicrotask(check);
    this.queue.resume();
  };
  function noop2() {
  }
  plugin$1 = {
    Plugin
  };
  return plugin$1;
}
var validatePlugin_1;
var hasRequiredValidatePlugin;
function requireValidatePlugin() {
  if (hasRequiredValidatePlugin) return validatePlugin_1;
  hasRequiredValidatePlugin = 1;
  const { AVV_ERR_PLUGIN_NOT_VALID } = requireErrors$3();
  function validatePlugin(maybePlugin) {
    if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
      if (Array.isArray(maybePlugin)) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("array");
      } else if (maybePlugin === null) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("null");
      } else {
        throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
      }
    }
  }
  validatePlugin_1 = {
    validatePlugin
  };
  return validatePlugin_1;
}
var isBundledOrTypescriptPlugin_1;
var hasRequiredIsBundledOrTypescriptPlugin;
function requireIsBundledOrTypescriptPlugin() {
  if (hasRequiredIsBundledOrTypescriptPlugin) return isBundledOrTypescriptPlugin_1;
  hasRequiredIsBundledOrTypescriptPlugin = 1;
  function isBundledOrTypescriptPlugin(maybeBundledOrTypescriptPlugin) {
    return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
  }
  isBundledOrTypescriptPlugin_1 = {
    isBundledOrTypescriptPlugin
  };
  return isBundledOrTypescriptPlugin_1;
}
var thenify_1;
var hasRequiredThenify;
function requireThenify() {
  if (hasRequiredThenify) return thenify_1;
  hasRequiredThenify = 1;
  const { debug } = requireDebug$1();
  const { kThenifyDoNotWrap } = requireSymbols$2();
  function thenify() {
    if (this.booted) {
      debug("thenify returning undefined because we are already booted");
      return;
    }
    if (this[kThenifyDoNotWrap]) {
      this[kThenifyDoNotWrap] = false;
      return;
    }
    debug("thenify");
    return (resolve2, reject) => {
      const p = this._loadRegistered();
      return p.then(() => {
        this[kThenifyDoNotWrap] = true;
        return resolve2(this._server);
      }, reject);
    };
  }
  thenify_1 = {
    thenify
  };
  return thenify_1;
}
var executeWithThenable_1;
var hasRequiredExecuteWithThenable;
function requireExecuteWithThenable() {
  if (hasRequiredExecuteWithThenable) return executeWithThenable_1;
  hasRequiredExecuteWithThenable = 1;
  const { isPromiseLike } = requireIsPromiseLike();
  const { kAvvio } = requireSymbols$2();
  function executeWithThenable(func, args, callback) {
    let result;
    try {
      result = func.apply(func, args);
    } catch (error2) {
      if (callback) {
        process.nextTick(callback, error2);
      }
      return;
    }
    if (isPromiseLike(result) && !result[kAvvio]) {
      result.then(() => process.nextTick(callback), (error2) => process.nextTick(callback, error2));
    } else if (callback) {
      process.nextTick(callback);
    }
  }
  executeWithThenable_1 = {
    executeWithThenable
  };
  return executeWithThenable_1;
}
var boot;
var hasRequiredBoot;
function requireBoot() {
  if (hasRequiredBoot) return boot;
  hasRequiredBoot = 1;
  const fastq = requireQueue();
  const EE = require$$0$2.EventEmitter;
  const inherits = require$$0$1.inherits;
  const {
    AVV_ERR_EXPOSE_ALREADY_DEFINED,
    AVV_ERR_CALLBACK_NOT_FN,
    AVV_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_READY_TIMEOUT,
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
  } = requireErrors$3();
  const {
    kAvvio,
    kIsOnCloseHandler
  } = requireSymbols$2();
  const { TimeTree } = requireTimeTree();
  const { Plugin } = requirePlugin$1();
  const { debug } = requireDebug$1();
  const { validatePlugin } = requireValidatePlugin();
  const { isBundledOrTypescriptPlugin } = requireIsBundledOrTypescriptPlugin();
  const { isPromiseLike } = requireIsPromiseLike();
  const { thenify } = requireThenify();
  const { executeWithThenable } = requireExecuteWithThenable();
  function Boot(server2, opts, done) {
    if (typeof server2 === "function" && arguments.length === 1) {
      done = server2;
      opts = {};
      server2 = null;
    }
    if (typeof opts === "function") {
      done = opts;
      opts = {};
    }
    opts = opts || {};
    opts.autostart = opts.autostart !== false;
    opts.timeout = Number(opts.timeout) || 0;
    opts.expose = opts.expose || {};
    if (!new.target) {
      return new Boot(server2, opts, done);
    }
    this._server = server2 || this;
    this._opts = opts;
    if (server2) {
      this._expose();
    }
    this._current = [];
    this._error = null;
    this._lastUsed = null;
    this.setMaxListeners(0);
    if (done) {
      this.once("start", done);
    }
    this.started = false;
    this.booted = false;
    this.pluginTree = new TimeTree();
    this._readyQ = fastq(this, callWithCbOrNextTick, 1);
    this._readyQ.pause();
    this._readyQ.drain = () => {
      this.emit("start");
      this._readyQ.drain = noop2;
    };
    this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
    this._closeQ.pause();
    this._closeQ.drain = () => {
      this.emit("close");
      this._closeQ.drain = noop2;
    };
    this._doStart = null;
    const instance = this;
    this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server3, opts2, done2) {
      instance._doStart = done2;
      opts2.autostart && instance.start();
    }, opts, false, 0);
    this._trackPluginLoading(this._root);
    this._loadPlugin(this._root, (err2) => {
      debug("root plugin ready");
      try {
        this.emit("preReady");
        this._root = null;
      } catch (preReadyError) {
        err2 = err2 || this._error || preReadyError;
      }
      if (err2) {
        this._error = err2;
        if (this._readyQ.length() === 0) {
          throw err2;
        }
      } else {
        this.booted = true;
      }
      this._readyQ.resume();
    });
  }
  inherits(Boot, EE);
  if ("asyncDispose" in Symbol) {
    Boot.prototype[Symbol.asyncDispose] = function() {
      return new Promise((resolve2, reject) => {
        this.close((err2) => {
          if (err2) {
            return reject(err2);
          }
          resolve2();
        });
      });
    };
  }
  Boot.prototype.start = function() {
    this.started = true;
    process.nextTick(this._doStart);
    return this;
  };
  Boot.prototype.override = function(server2, func, opts) {
    return server2;
  };
  Boot.prototype[kAvvio] = true;
  Boot.prototype.use = function(plugin2, opts) {
    this._lastUsed = this._addPlugin(plugin2, opts, false);
    return this;
  };
  Boot.prototype._loadRegistered = function() {
    const plugin2 = this._current[0];
    const weNeedToStart = !this.started && !this.booted;
    if (weNeedToStart) {
      process.nextTick(() => this._root.queue.resume());
    }
    if (!plugin2) {
      return Promise.resolve();
    }
    return plugin2.loadedSoFar();
  };
  Object.defineProperty(Boot.prototype, "then", { get: thenify });
  Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
    if (isBundledOrTypescriptPlugin(pluginFn)) {
      pluginFn = pluginFn.default;
    }
    validatePlugin(pluginFn);
    opts = opts || {};
    if (this.booted) {
      throw new AVV_ERR_ROOT_PLG_BOOTED();
    }
    const current = this._current[0];
    let timeout = this._opts.timeout;
    if (!current.loaded && current.timeout > 0) {
      const delta = Date.now() - current.startTime;
      timeout = current.timeout - (delta + 3);
    }
    const plugin2 = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
    this._trackPluginLoading(plugin2);
    if (current.loaded) {
      throw new Error(plugin2.name, current.name);
    }
    current.enqueue(plugin2, (err2) => {
      err2 && (this._error = err2);
    });
    return plugin2;
  };
  Boot.prototype._expose = function _expose() {
    const instance = this;
    const server2 = instance._server;
    const {
      use: useKey = "use",
      after: afterKey = "after",
      ready: readyKey = "ready",
      onClose: onCloseKey = "onClose",
      close: closeKey = "close"
    } = this._opts.expose;
    if (server2[useKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
    }
    server2[useKey] = function(fn, opts) {
      instance.use(fn, opts);
      return this;
    };
    if (server2[afterKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
    }
    server2[afterKey] = function(func) {
      if (typeof func !== "function") {
        return instance._loadRegistered();
      }
      instance.after(encapsulateThreeParam(func, this));
      return this;
    };
    if (server2[readyKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
    }
    server2[readyKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
      }
      return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
    };
    if (server2[onCloseKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
    }
    server2[onCloseKey] = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
      }
      instance.onClose(encapsulateTwoParam(func, this));
      return this;
    };
    if (server2[closeKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
    }
    server2[closeKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
      }
      if (func) {
        instance.close(encapsulateThreeParam(func, this));
        return this;
      }
      return instance.close();
    };
    if (server2.then) {
      throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
    }
    Object.defineProperty(server2, "then", { get: thenify.bind(instance) });
    server2[kAvvio] = true;
  };
  Boot.prototype.after = function(func) {
    if (!func) {
      return this._loadRegistered();
    }
    this._addPlugin(_after.bind(this), {}, true);
    function _after(s, opts, done) {
      callWithCbOrNextTick.call(this, func, done);
    }
    return this;
  };
  Boot.prototype.onClose = function(func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
    }
    func[kIsOnCloseHandler] = true;
    this._closeQ.unshift(func, (err2) => {
      err2 && (this._error = err2);
    });
    return this;
  };
  Boot.prototype.close = function(func) {
    let promise2;
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
      }
    } else {
      promise2 = new Promise(function(resolve2, reject) {
        func = function(err2) {
          if (err2) {
            return reject(err2);
          }
          resolve2();
        };
      });
    }
    this.ready(() => {
      this._error = null;
      this._closeQ.push(func);
      process.nextTick(this._closeQ.resume.bind(this._closeQ));
    });
    return promise2;
  };
  Boot.prototype.ready = function(func) {
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
      }
      this._readyQ.push(func);
      queueMicrotask(this.start.bind(this));
      return;
    }
    return new Promise((resolve2, reject) => {
      this._readyQ.push(readyPromiseCB);
      this.start();
      const relativeContext = this._current[0].server;
      function readyPromiseCB(err2, context2, done) {
        if (err2) {
          reject(err2);
        } else {
          resolve2(relativeContext);
        }
        process.nextTick(done);
      }
    });
  };
  Boot.prototype._trackPluginLoading = function(plugin2) {
    const parentName = this._current[0]?.name || null;
    plugin2.once("start", (serverName, funcName, time2) => {
      const nodeId = this.pluginTree.start(parentName || null, funcName, time2);
      plugin2.once("loaded", (serverName2, funcName2, time3) => {
        this.pluginTree.stop(nodeId, time3);
      });
    });
  };
  Boot.prototype.prettyPrint = function() {
    return this.pluginTree.prettyPrint();
  };
  Boot.prototype.toJSON = function() {
    return this.pluginTree.toJSON();
  };
  Boot.prototype._loadPlugin = function(plugin2, callback) {
    const instance = this;
    if (isPromiseLike(plugin2.func)) {
      plugin2.func.then((fn) => {
        if (typeof fn.default === "function") {
          fn = fn.default;
        }
        plugin2.func = fn;
        this._loadPlugin(plugin2, callback);
      }, callback);
      return;
    }
    const last = instance._current[0];
    instance._current.unshift(plugin2);
    if (instance._error && !plugin2.isAfter) {
      debug("skipping loading of plugin as instance errored and it is not an after", plugin2.name);
      process.nextTick(execCallback);
      return;
    }
    let server2 = last?.server || instance._server;
    if (!plugin2.isAfter) {
      try {
        server2 = instance.override(server2, plugin2.func, plugin2.options);
      } catch (overrideErr) {
        debug("override errored", plugin2.name);
        return execCallback(overrideErr);
      }
    }
    plugin2.exec(server2, execCallback);
    function execCallback(err2) {
      plugin2.finish(err2, (err3) => {
        instance._current.shift();
        callback(err3);
      });
    }
  };
  Boot.prototype._loadPluginNextTick = function(plugin2, callback) {
    process.nextTick(this._loadPlugin.bind(this), plugin2, callback);
  };
  function noop2() {
  }
  function callWithCbOrNextTick(func, cb) {
    const context2 = this._server;
    const err2 = this._error;
    this._error = null;
    if (func.length === 0) {
      this._error = err2;
      executeWithThenable(func, [], cb);
    } else if (func.length === 1) {
      executeWithThenable(func, [err2], cb);
    } else {
      if (this._opts.timeout === 0) {
        const wrapCb = (err3) => {
          this._error = err3;
          cb(this._error);
        };
        if (func.length === 2) {
          func(err2, wrapCb);
        } else {
          func(err2, context2, wrapCb);
        }
      } else {
        timeoutCall.call(this, func, err2, context2, cb);
      }
    }
  }
  function timeoutCall(func, rootErr, context2, cb) {
    const name = func.unwrappedName ?? func.name;
    debug("setting up ready timeout", name, this._opts.timeout);
    let timer = setTimeout(() => {
      debug("timed out", name);
      timer = null;
      const toutErr = new AVV_ERR_READY_TIMEOUT(name);
      toutErr.fn = func;
      this._error = toutErr;
      cb(toutErr);
    }, this._opts.timeout);
    if (func.length === 2) {
      func(rootErr, timeoutCb.bind(this));
    } else {
      func(rootErr, context2, timeoutCb.bind(this));
    }
    function timeoutCb(err2) {
      if (timer) {
        clearTimeout(timer);
        this._error = err2;
        cb(this._error);
      }
    }
  }
  function closeWithCbOrNextTick(func, cb) {
    const context2 = this._server;
    const isOnCloseHandler = func[kIsOnCloseHandler];
    if (func.length === 0 || func.length === 1) {
      let promise2;
      if (isOnCloseHandler) {
        promise2 = func(context2);
      } else {
        promise2 = func(this._error);
      }
      if (promise2 && typeof promise2.then === "function") {
        debug("resolving close/onClose promise");
        promise2.then(
          () => process.nextTick(cb),
          (e) => process.nextTick(cb, e)
        );
      } else {
        process.nextTick(cb);
      }
    } else if (func.length === 2) {
      if (isOnCloseHandler) {
        func(context2, cb);
      } else {
        func(this._error, cb);
      }
    } else {
      if (isOnCloseHandler) {
        func(context2, cb);
      } else {
        func(this._error, context2, cb);
      }
    }
  }
  function encapsulateTwoParam(func, that) {
    return _encapsulateTwoParam.bind(that);
    function _encapsulateTwoParam(context2, cb) {
      let res2;
      if (func.length === 0) {
        res2 = func();
        if (res2?.then) {
          res2.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 1) {
        res2 = func(this);
        if (res2?.then) {
          res2.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else {
        func(this, cb);
      }
    }
  }
  function encapsulateThreeParam(func, that) {
    const wrapped = _encapsulateThreeParam.bind(that);
    wrapped.unwrappedName = func.name;
    return wrapped;
    function _encapsulateThreeParam(err2, cb) {
      let res2;
      if (!func) {
        process.nextTick(cb);
      } else if (func.length === 0) {
        res2 = func();
        if (res2?.then) {
          res2.then(function() {
            process.nextTick(cb, err2);
          }, cb);
        } else {
          process.nextTick(cb, err2);
        }
      } else if (func.length === 1) {
        res2 = func(err2);
        if (res2?.then) {
          res2.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        func(err2, cb);
      } else {
        func(err2, this, cb);
      }
    }
  }
  boot = Boot;
  return boot;
}
var symbols$1;
var hasRequiredSymbols$1;
function requireSymbols$1() {
  if (hasRequiredSymbols$1) return symbols$1;
  hasRequiredSymbols$1 = 1;
  const keys = {
    kAvvioBoot: /* @__PURE__ */ Symbol("fastify.avvioBoot"),
    kChildren: /* @__PURE__ */ Symbol("fastify.children"),
    kServerBindings: /* @__PURE__ */ Symbol("fastify.serverBindings"),
    kBodyLimit: /* @__PURE__ */ Symbol("fastify.bodyLimit"),
    kSupportedHTTPMethods: /* @__PURE__ */ Symbol("fastify.acceptedHTTPMethods"),
    kRoutePrefix: /* @__PURE__ */ Symbol("fastify.routePrefix"),
    kLogLevel: /* @__PURE__ */ Symbol("fastify.logLevel"),
    kLogSerializers: /* @__PURE__ */ Symbol("fastify.logSerializers"),
    kHooks: /* @__PURE__ */ Symbol("fastify.hooks"),
    kContentTypeParser: /* @__PURE__ */ Symbol("fastify.contentTypeParser"),
    kState: /* @__PURE__ */ Symbol("fastify.state"),
    kOptions: /* @__PURE__ */ Symbol("fastify.options"),
    kDisableRequestLogging: /* @__PURE__ */ Symbol("fastify.disableRequestLogging"),
    kPluginNameChain: /* @__PURE__ */ Symbol("fastify.pluginNameChain"),
    kRouteContext: /* @__PURE__ */ Symbol("fastify.context"),
    kGenReqId: /* @__PURE__ */ Symbol("fastify.genReqId"),
    kHttp2ServerSessions: /* @__PURE__ */ Symbol("fastify.http2ServerSessions"),
    // Schema
    kSchemaController: /* @__PURE__ */ Symbol("fastify.schemaController"),
    kSchemaHeaders: /* @__PURE__ */ Symbol("headers-schema"),
    kSchemaParams: /* @__PURE__ */ Symbol("params-schema"),
    kSchemaQuerystring: /* @__PURE__ */ Symbol("querystring-schema"),
    kSchemaBody: /* @__PURE__ */ Symbol("body-schema"),
    kSchemaResponse: /* @__PURE__ */ Symbol("response-schema"),
    kSchemaErrorFormatter: /* @__PURE__ */ Symbol("fastify.schemaErrorFormatter"),
    kSchemaVisited: /* @__PURE__ */ Symbol("fastify.schemas.visited"),
    // Request
    kRequest: /* @__PURE__ */ Symbol("fastify.Request"),
    kRequestPayloadStream: /* @__PURE__ */ Symbol("fastify.RequestPayloadStream"),
    kRequestAcceptVersion: /* @__PURE__ */ Symbol("fastify.RequestAcceptVersion"),
    kRequestCacheValidateFns: /* @__PURE__ */ Symbol("fastify.request.cache.validateFns"),
    kRequestOriginalUrl: /* @__PURE__ */ Symbol("fastify.request.originalUrl"),
    // 404
    kFourOhFour: /* @__PURE__ */ Symbol("fastify.404"),
    kCanSetNotFoundHandler: /* @__PURE__ */ Symbol("fastify.canSetNotFoundHandler"),
    kFourOhFourLevelInstance: /* @__PURE__ */ Symbol("fastify.404LogLevelInstance"),
    kFourOhFourContext: /* @__PURE__ */ Symbol("fastify.404ContextKey"),
    kDefaultJsonParse: /* @__PURE__ */ Symbol("fastify.defaultJSONParse"),
    // Reply
    kReply: /* @__PURE__ */ Symbol("fastify.Reply"),
    kReplySerializer: /* @__PURE__ */ Symbol("fastify.reply.serializer"),
    kReplyIsError: /* @__PURE__ */ Symbol("fastify.reply.isError"),
    kReplyHeaders: /* @__PURE__ */ Symbol("fastify.reply.headers"),
    kReplyTrailers: /* @__PURE__ */ Symbol("fastify.reply.trailers"),
    kReplyHasStatusCode: /* @__PURE__ */ Symbol("fastify.reply.hasStatusCode"),
    kReplyHijacked: /* @__PURE__ */ Symbol("fastify.reply.hijacked"),
    kReplyStartTime: /* @__PURE__ */ Symbol("fastify.reply.startTime"),
    kReplyNextErrorHandler: /* @__PURE__ */ Symbol("fastify.reply.nextErrorHandler"),
    kReplyEndTime: /* @__PURE__ */ Symbol("fastify.reply.endTime"),
    kReplyErrorHandlerCalled: /* @__PURE__ */ Symbol("fastify.reply.errorHandlerCalled"),
    kReplyIsRunningOnErrorHook: /* @__PURE__ */ Symbol("fastify.reply.isRunningOnErrorHook"),
    kReplySerializerDefault: /* @__PURE__ */ Symbol("fastify.replySerializerDefault"),
    kReplyCacheSerializeFns: /* @__PURE__ */ Symbol("fastify.reply.cache.serializeFns"),
    // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
    kTestInternals: /* @__PURE__ */ Symbol("fastify.testInternals"),
    kErrorHandler: /* @__PURE__ */ Symbol("fastify.errorHandler"),
    kErrorHandlerAlreadySet: /* @__PURE__ */ Symbol("fastify.errorHandlerAlreadySet"),
    kChildLoggerFactory: /* @__PURE__ */ Symbol("fastify.childLoggerFactory"),
    kHasBeenDecorated: /* @__PURE__ */ Symbol("fastify.hasBeenDecorated"),
    kKeepAliveConnections: /* @__PURE__ */ Symbol("fastify.keepAliveConnections"),
    kRouteByFastify: /* @__PURE__ */ Symbol("fastify.routeByFastify")
  };
  symbols$1 = keys;
  return symbols$1;
}
var server = {};
var processWarning$1 = { exports: {} };
var hasRequiredProcessWarning$1;
function requireProcessWarning$1() {
  if (hasRequiredProcessWarning$1) return processWarning$1.exports;
  hasRequiredProcessWarning$1 = 1;
  const { format: format2 } = require$$0$1;
  function createDeprecation(params) {
    return createWarning({ ...params, name: "DeprecationWarning" });
  }
  function createWarning({ name, code: code2, message, unlimited = false } = {}) {
    if (!name) throw new Error("Warning name must not be empty");
    if (!code2) throw new Error("Warning code must not be empty");
    if (!message) throw new Error("Warning message must not be empty");
    if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
    code2 = code2.toUpperCase();
    let warningContainer = {
      [name]: function(a, b, c) {
        if (warning.emitted === true && warning.unlimited !== true) {
          return;
        }
        warning.emitted = true;
        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
      }
    };
    if (unlimited) {
      warningContainer = {
        [name]: function(a, b, c) {
          warning.emitted = true;
          process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
        }
      };
    }
    const warning = warningContainer[name];
    warning.emitted = false;
    warning.message = message;
    warning.unlimited = unlimited;
    warning.code = code2;
    warning.format = function(a, b, c) {
      let formatted;
      if (a && b && c) {
        formatted = format2(message, a, b, c);
      } else if (a && b) {
        formatted = format2(message, a, b);
      } else if (a) {
        formatted = format2(message, a);
      } else {
        formatted = message;
      }
      return formatted;
    };
    return warning;
  }
  const out = { createWarning, createDeprecation };
  processWarning$1.exports = out;
  processWarning$1.exports.default = out;
  processWarning$1.exports.processWarning = out;
  return processWarning$1.exports;
}
var warnings;
var hasRequiredWarnings;
function requireWarnings() {
  if (hasRequiredWarnings) return warnings;
  hasRequiredWarnings = 1;
  const { createWarning } = requireProcessWarning$1();
  const FSTWRN001 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN001",
    message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
    unlimited: true
  });
  const FSTWRN003 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN003",
    message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
    unlimited: true
  });
  const FSTWRN004 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN004",
    message: "It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.",
    unlimited: true
  });
  const FSTSEC001 = createWarning({
    name: "FastifySecurity",
    code: "FSTSEC001",
    message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
    unlimited: true
  });
  const FSTDEP022 = createWarning({
    name: "FastifyWarning",
    code: "FSTDEP022",
    message: 'The router options for %s property access is deprecated. Please use "options.routerOptions" instead for accessing router options. The router options will be removed in `fastify@6`.',
    unlimited: true
  });
  warnings = {
    FSTWRN001,
    FSTWRN003,
    FSTWRN004,
    FSTSEC001,
    FSTDEP022
  };
  return warnings;
}
var errors$2 = { exports: {} };
var hasRequiredErrors$2;
function requireErrors$2() {
  if (hasRequiredErrors$2) return errors$2.exports;
  hasRequiredErrors$2 = 1;
  const createError2 = requireError$1();
  const codes = {
    /**
     * Basic
     */
    FST_ERR_NOT_FOUND: createError2(
      "FST_ERR_NOT_FOUND",
      "Not Found",
      404
    ),
    FST_ERR_OPTIONS_NOT_OBJ: createError2(
      "FST_ERR_OPTIONS_NOT_OBJ",
      "Options must be an object",
      500,
      TypeError
    ),
    FST_ERR_QSP_NOT_FN: createError2(
      "FST_ERR_QSP_NOT_FN",
      "querystringParser option should be a function, instead got '%s'",
      500,
      TypeError
    ),
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError2(
      "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
      "schemaController.bucket option should be a function, instead got '%s'",
      500,
      TypeError
    ),
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError2(
      "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
      "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
      500,
      TypeError
    ),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError2(
      "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
      "ajv.customOptions option should be an object, instead got '%s'",
      500,
      TypeError
    ),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError2(
      "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
      "ajv.plugins option should be an array, instead got '%s'",
      500,
      TypeError
    ),
    FST_ERR_VALIDATION: createError2(
      "FST_ERR_VALIDATION",
      "%s",
      400
    ),
    FST_ERR_LISTEN_OPTIONS_INVALID: createError2(
      "FST_ERR_LISTEN_OPTIONS_INVALID",
      "Invalid listen options: '%s'",
      500,
      TypeError
    ),
    FST_ERR_ERROR_HANDLER_NOT_FN: createError2(
      "FST_ERR_ERROR_HANDLER_NOT_FN",
      "Error Handler must be a function",
      500,
      TypeError
    ),
    FST_ERR_ERROR_HANDLER_ALREADY_SET: createError2(
      "FST_ERR_ERROR_HANDLER_ALREADY_SET",
      "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.",
      500,
      TypeError
    ),
    /**
     * ContentTypeParser
    */
    FST_ERR_CTP_ALREADY_PRESENT: createError2(
      "FST_ERR_CTP_ALREADY_PRESENT",
      "Content type parser '%s' already present."
    ),
    FST_ERR_CTP_INVALID_TYPE: createError2(
      "FST_ERR_CTP_INVALID_TYPE",
      "The content type should be a string or a RegExp",
      500,
      TypeError
    ),
    FST_ERR_CTP_EMPTY_TYPE: createError2(
      "FST_ERR_CTP_EMPTY_TYPE",
      "The content type cannot be an empty string",
      500,
      TypeError
    ),
    FST_ERR_CTP_INVALID_HANDLER: createError2(
      "FST_ERR_CTP_INVALID_HANDLER",
      "The content type handler should be a function",
      500,
      TypeError
    ),
    FST_ERR_CTP_INVALID_PARSE_TYPE: createError2(
      "FST_ERR_CTP_INVALID_PARSE_TYPE",
      "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
      500,
      TypeError
    ),
    FST_ERR_CTP_BODY_TOO_LARGE: createError2(
      "FST_ERR_CTP_BODY_TOO_LARGE",
      "Request body is too large",
      413,
      RangeError
    ),
    FST_ERR_CTP_INVALID_MEDIA_TYPE: createError2(
      "FST_ERR_CTP_INVALID_MEDIA_TYPE",
      "Unsupported Media Type: %s",
      415
    ),
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError2(
      "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
      "Request body size did not match Content-Length",
      400,
      RangeError
    ),
    FST_ERR_CTP_EMPTY_JSON_BODY: createError2(
      "FST_ERR_CTP_EMPTY_JSON_BODY",
      "Body cannot be empty when content-type is set to 'application/json'",
      400
    ),
    FST_ERR_CTP_INVALID_JSON_BODY: createError2(
      "FST_ERR_CTP_INVALID_JSON_BODY",
      "Body is not valid JSON but content-type is set to 'application/json'",
      400
    ),
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError2(
      "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
      'Cannot call "%s" when fastify instance is already started!',
      400
    ),
    /**
     * decorate
    */
    FST_ERR_DEC_ALREADY_PRESENT: createError2(
      "FST_ERR_DEC_ALREADY_PRESENT",
      "The decorator '%s' has already been added!"
    ),
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError2(
      "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
      "The dependencies of decorator '%s' must be of type Array.",
      500,
      TypeError
    ),
    FST_ERR_DEC_MISSING_DEPENDENCY: createError2(
      "FST_ERR_DEC_MISSING_DEPENDENCY",
      "The decorator is missing dependency '%s'."
    ),
    FST_ERR_DEC_AFTER_START: createError2(
      "FST_ERR_DEC_AFTER_START",
      "The decorator '%s' has been added after start!"
    ),
    FST_ERR_DEC_REFERENCE_TYPE: createError2(
      "FST_ERR_DEC_REFERENCE_TYPE",
      "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
    ),
    FST_ERR_DEC_UNDECLARED: createError2(
      "FST_ERR_DEC_UNDECLARED",
      "No decorator '%s' has been declared on %s."
    ),
    /**
     * hooks
    */
    FST_ERR_HOOK_INVALID_TYPE: createError2(
      "FST_ERR_HOOK_INVALID_TYPE",
      "The hook name must be a string",
      500,
      TypeError
    ),
    FST_ERR_HOOK_INVALID_HANDLER: createError2(
      "FST_ERR_HOOK_INVALID_HANDLER",
      "%s hook should be a function, instead got %s",
      500,
      TypeError
    ),
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError2(
      "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
      "Async function has too many arguments. Async hooks should not use the 'done' argument.",
      500,
      TypeError
    ),
    FST_ERR_HOOK_NOT_SUPPORTED: createError2(
      "FST_ERR_HOOK_NOT_SUPPORTED",
      "%s hook not supported!",
      500,
      TypeError
    ),
    /**
     * Middlewares
     */
    FST_ERR_MISSING_MIDDLEWARE: createError2(
      "FST_ERR_MISSING_MIDDLEWARE",
      "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
      500
    ),
    FST_ERR_HOOK_TIMEOUT: createError2(
      "FST_ERR_HOOK_TIMEOUT",
      "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
    ),
    /**
     * logger
    */
    FST_ERR_LOG_INVALID_DESTINATION: createError2(
      "FST_ERR_LOG_INVALID_DESTINATION",
      "Cannot specify both logger.stream and logger.file options"
    ),
    FST_ERR_LOG_INVALID_LOGGER: createError2(
      "FST_ERR_LOG_INVALID_LOGGER",
      "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
      500,
      TypeError
    ),
    FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError2(
      "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
      "loggerInstance only accepts a logger instance.",
      500,
      TypeError
    ),
    FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError2(
      "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
      "logger options only accepts a configuration object.",
      500,
      TypeError
    ),
    FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError2(
      "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
      "You cannot provide both logger and loggerInstance. Please provide only one.",
      500,
      TypeError
    ),
    /**
     * reply
    */
    FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError2(
      "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
      "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
      500,
      TypeError
    ),
    FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError2(
      "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
      "Response.body is already consumed."
    ),
    FST_ERR_REP_READABLE_STREAM_LOCKED: createError2(
      "FST_ERR_REP_READABLE_STREAM_LOCKED",
      "ReadableStream was locked. You should call releaseLock() method on reader before sending."
    ),
    FST_ERR_REP_ALREADY_SENT: createError2(
      "FST_ERR_REP_ALREADY_SENT",
      'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
    ),
    FST_ERR_REP_SENT_VALUE: createError2(
      "FST_ERR_REP_SENT_VALUE",
      "The only possible value for reply.sent is true.",
      500,
      TypeError
    ),
    FST_ERR_SEND_INSIDE_ONERR: createError2(
      "FST_ERR_SEND_INSIDE_ONERR",
      "You cannot use `send` inside the `onError` hook"
    ),
    FST_ERR_SEND_UNDEFINED_ERR: createError2(
      "FST_ERR_SEND_UNDEFINED_ERR",
      "Undefined error has occurred"
    ),
    FST_ERR_BAD_STATUS_CODE: createError2(
      "FST_ERR_BAD_STATUS_CODE",
      "Called reply with an invalid status code: %s"
    ),
    FST_ERR_BAD_TRAILER_NAME: createError2(
      "FST_ERR_BAD_TRAILER_NAME",
      "Called reply.trailer with an invalid header name: %s"
    ),
    FST_ERR_BAD_TRAILER_VALUE: createError2(
      "FST_ERR_BAD_TRAILER_VALUE",
      "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
    ),
    FST_ERR_FAILED_ERROR_SERIALIZATION: createError2(
      "FST_ERR_FAILED_ERROR_SERIALIZATION",
      "Failed to serialize an error. Error: %s. Original error: %s"
    ),
    FST_ERR_MISSING_SERIALIZATION_FN: createError2(
      "FST_ERR_MISSING_SERIALIZATION_FN",
      'Missing serialization function. Key "%s"'
    ),
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError2(
      "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
      'Missing serialization function. Key "%s:%s"'
    ),
    FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError2(
      "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
      'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
    ),
    /**
     * schemas
    */
    FST_ERR_SCH_MISSING_ID: createError2(
      "FST_ERR_SCH_MISSING_ID",
      "Missing schema $id property"
    ),
    FST_ERR_SCH_ALREADY_PRESENT: createError2(
      "FST_ERR_SCH_ALREADY_PRESENT",
      "Schema with id '%s' already declared!"
    ),
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError2(
      "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
      "Schema is missing for the content type '%s'"
    ),
    FST_ERR_SCH_DUPLICATE: createError2(
      "FST_ERR_SCH_DUPLICATE",
      "Schema with '%s' already present!"
    ),
    FST_ERR_SCH_VALIDATION_BUILD: createError2(
      "FST_ERR_SCH_VALIDATION_BUILD",
      "Failed building the validation schema for %s: %s, due to error %s"
    ),
    FST_ERR_SCH_SERIALIZATION_BUILD: createError2(
      "FST_ERR_SCH_SERIALIZATION_BUILD",
      "Failed building the serialization schema for %s: %s, due to error %s"
    ),
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError2(
      "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
      'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
    ),
    /**
     * initialConfig
     */
    FST_ERR_INIT_OPTS_INVALID: createError2(
      "FST_ERR_INIT_OPTS_INVALID",
      "Invalid initialization options: '%s'"
    ),
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError2(
      "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
      "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
    ),
    /**
     * router
     */
    FST_ERR_DUPLICATED_ROUTE: createError2(
      "FST_ERR_DUPLICATED_ROUTE",
      "Method '%s' already declared for route '%s'"
    ),
    FST_ERR_BAD_URL: createError2(
      "FST_ERR_BAD_URL",
      "'%s' is not a valid url component",
      400,
      URIError
    ),
    FST_ERR_ASYNC_CONSTRAINT: createError2(
      "FST_ERR_ASYNC_CONSTRAINT",
      "Unexpected error from async constraint",
      500
    ),
    FST_ERR_INVALID_URL: createError2(
      "FST_ERR_INVALID_URL",
      "URL must be a string. Received '%s'",
      400,
      TypeError
    ),
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError2(
      "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
      'Options for "%s:%s" route must be an object',
      500,
      TypeError
    ),
    FST_ERR_ROUTE_DUPLICATED_HANDLER: createError2(
      "FST_ERR_ROUTE_DUPLICATED_HANDLER",
      'Duplicate handler for "%s:%s" route is not allowed!',
      500
    ),
    FST_ERR_ROUTE_HANDLER_NOT_FN: createError2(
      "FST_ERR_ROUTE_HANDLER_NOT_FN",
      "Error Handler for %s:%s route, if defined, must be a function",
      500,
      TypeError
    ),
    FST_ERR_ROUTE_MISSING_HANDLER: createError2(
      "FST_ERR_ROUTE_MISSING_HANDLER",
      'Missing handler function for "%s:%s" route.',
      500
    ),
    FST_ERR_ROUTE_METHOD_INVALID: createError2(
      "FST_ERR_ROUTE_METHOD_INVALID",
      "Provided method is invalid!",
      500,
      TypeError
    ),
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError2(
      "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
      "%s method is not supported.",
      500
    ),
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError2(
      "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
      "Body validation schema for %s:%s route is not supported!",
      500
    ),
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError2(
      "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
      "'bodyLimit' option must be an integer > 0. Got '%s'",
      500,
      TypeError
    ),
    FST_ERR_ROUTE_REWRITE_NOT_STR: createError2(
      "FST_ERR_ROUTE_REWRITE_NOT_STR",
      'Rewrite url for "%s" needs to be of type "string" but received "%s"',
      500,
      TypeError
    ),
    /**
     *  again listen when close server
     */
    FST_ERR_REOPENED_CLOSE_SERVER: createError2(
      "FST_ERR_REOPENED_CLOSE_SERVER",
      "Fastify has already been closed and cannot be reopened"
    ),
    FST_ERR_REOPENED_SERVER: createError2(
      "FST_ERR_REOPENED_SERVER",
      "Fastify is already listening"
    ),
    FST_ERR_INSTANCE_ALREADY_LISTENING: createError2(
      "FST_ERR_INSTANCE_ALREADY_LISTENING",
      "Fastify instance is already listening. %s"
    ),
    /**
     * plugin
     */
    FST_ERR_PLUGIN_VERSION_MISMATCH: createError2(
      "FST_ERR_PLUGIN_VERSION_MISMATCH",
      "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
    ),
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError2(
      "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
      "The decorator '%s'%s is not present in %s"
    ),
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError2(
      "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
      "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
      500,
      TypeError
    ),
    /**
     *  Avvio Errors
     */
    FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError2(
      "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
      "fastify-plugin: %s",
      500,
      TypeError
    ),
    FST_ERR_PLUGIN_NOT_VALID: createError2(
      "FST_ERR_PLUGIN_NOT_VALID",
      "fastify-plugin: %s"
    ),
    FST_ERR_ROOT_PLG_BOOTED: createError2(
      "FST_ERR_ROOT_PLG_BOOTED",
      "fastify-plugin: %s"
    ),
    FST_ERR_PARENT_PLUGIN_BOOTED: createError2(
      "FST_ERR_PARENT_PLUGIN_BOOTED",
      "fastify-plugin: %s"
    ),
    FST_ERR_PLUGIN_TIMEOUT: createError2(
      "FST_ERR_PLUGIN_TIMEOUT",
      "fastify-plugin: %s"
    )
  };
  function appendStackTrace(oldErr, newErr) {
    newErr.cause = oldErr;
    return newErr;
  }
  errors$2.exports = codes;
  errors$2.exports.appendStackTrace = appendStackTrace;
  errors$2.exports.AVVIO_ERRORS_MAP = {
    AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
    AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
    AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
    AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
  };
  return errors$2.exports;
}
var hooks;
var hasRequiredHooks;
function requireHooks() {
  if (hasRequiredHooks) return hooks;
  hasRequiredHooks = 1;
  const applicationHooks = [
    "onRoute",
    "onRegister",
    "onReady",
    "onListen",
    "preClose",
    "onClose"
  ];
  const lifecycleHooks = [
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError",
    "onRequestAbort"
  ];
  const supportedHooks = lifecycleHooks.concat(applicationHooks);
  const {
    FST_ERR_HOOK_INVALID_TYPE,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_SEND_UNDEFINED_ERR,
    FST_ERR_HOOK_TIMEOUT,
    FST_ERR_HOOK_NOT_SUPPORTED,
    AVVIO_ERRORS_MAP,
    appendStackTrace
  } = requireErrors$2();
  const {
    kChildren,
    kHooks,
    kRequestPayloadStream
  } = requireSymbols$1();
  function Hooks() {
    this.onRequest = [];
    this.preParsing = [];
    this.preValidation = [];
    this.preSerialization = [];
    this.preHandler = [];
    this.onResponse = [];
    this.onSend = [];
    this.onError = [];
    this.onRoute = [];
    this.onRegister = [];
    this.onReady = [];
    this.onListen = [];
    this.onTimeout = [];
    this.onRequestAbort = [];
    this.preClose = [];
  }
  Hooks.prototype = /* @__PURE__ */ Object.create(null);
  Hooks.prototype.validate = function(hook, fn) {
    if (typeof hook !== "string") throw new FST_ERR_HOOK_INVALID_TYPE();
    if (Array.isArray(this[hook]) === false) {
      throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
    }
    if (typeof fn !== "function") throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
  };
  Hooks.prototype.add = function(hook, fn) {
    this.validate(hook, fn);
    this[hook].push(fn);
  };
  function buildHooks(h) {
    const hooks2 = new Hooks();
    hooks2.onRequest = h.onRequest.slice();
    hooks2.preParsing = h.preParsing.slice();
    hooks2.preValidation = h.preValidation.slice();
    hooks2.preSerialization = h.preSerialization.slice();
    hooks2.preHandler = h.preHandler.slice();
    hooks2.onSend = h.onSend.slice();
    hooks2.onResponse = h.onResponse.slice();
    hooks2.onError = h.onError.slice();
    hooks2.onRoute = h.onRoute.slice();
    hooks2.onRegister = h.onRegister.slice();
    hooks2.onTimeout = h.onTimeout.slice();
    hooks2.onRequestAbort = h.onRequestAbort.slice();
    hooks2.onReady = [];
    hooks2.onListen = [];
    hooks2.preClose = [];
    return hooks2;
  }
  function hookRunnerApplication(hookName, boot2, server2, cb) {
    const hooks2 = server2[kHooks][hookName];
    let i = 0;
    let c = 0;
    next();
    function exit(err2) {
      const hookFnName = hooks2[i - 1]?.name;
      const hookFnFragment = hookFnName ? ` "${hookFnName}"` : "";
      if (err2) {
        if (err2.code === "AVV_ERR_READY_TIMEOUT") {
          err2 = appendStackTrace(err2, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
        } else {
          err2 = AVVIO_ERRORS_MAP[err2.code] != null ? appendStackTrace(err2, new AVVIO_ERRORS_MAP[err2.code](err2.message)) : err2;
        }
        cb(err2);
        return;
      }
      cb();
    }
    function next(err2) {
      if (err2) {
        exit(err2);
        return;
      }
      if (i === hooks2.length && c === server2[kChildren].length) {
        if (i === 0 && c === 0) {
          exit();
        } else {
          boot2(function manageTimeout(err3, done) {
            exit(err3);
            done(err3);
          });
        }
        return;
      }
      if (i === hooks2.length && c < server2[kChildren].length) {
        const child = server2[kChildren][c++];
        hookRunnerApplication(hookName, boot2, child, next);
        return;
      }
      boot2(wrap(hooks2[i++], server2));
      next();
    }
    function wrap(fn, server3) {
      return function(err2, done) {
        if (err2) {
          done(err2);
          return;
        }
        if (fn.length === 1) {
          try {
            fn.call(server3, done);
          } catch (error2) {
            done(error2);
          }
          return;
        }
        try {
          const ret = fn.call(server3);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
        } catch (error2) {
          err2 = error2;
        }
        done(err2);
      };
    }
  }
  function onListenHookRunner(server2) {
    const hooks2 = server2[kHooks].onListen;
    const hooksLen = hooks2.length;
    let i = 0;
    let c = 0;
    next();
    function next(err2) {
      err2 && server2.log.error(err2);
      if (i === hooksLen) {
        while (c < server2[kChildren].length) {
          const child = server2[kChildren][c++];
          onListenHookRunner(child);
        }
        return;
      }
      wrap(hooks2[i++], server2, next);
    }
    async function wrap(fn, server3, done) {
      if (fn.length === 1) {
        try {
          fn.call(server3, done);
        } catch (e) {
          done(e);
        }
        return;
      }
      try {
        const ret = fn.call(server3);
        if (ret && typeof ret.then === "function") {
          ret.then(done, done);
          return;
        }
        done();
      } catch (error2) {
        done(error2);
      }
    }
  }
  function hookRunnerGenerator(iterator) {
    return function hookRunner(functions, request2, reply2, cb) {
      let i = 0;
      function next(err2) {
        if (err2 || i === functions.length) {
          cb(err2, request2, reply2);
          return;
        }
        let result;
        try {
          result = iterator(functions[i++], request2, reply2, next);
        } catch (error2) {
          cb(error2, request2, reply2);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err2) {
        if (!err2) {
          err2 = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err2, request2, reply2);
      }
      next();
    };
  }
  function onResponseHookIterator(fn, request2, reply2, next) {
    return fn(request2, reply2, next);
  }
  const onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
  const preValidationHookRunner = hookRunnerGenerator(hookIterator);
  const preHandlerHookRunner = hookRunnerGenerator(hookIterator);
  const onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
  const onRequestHookRunner = hookRunnerGenerator(hookIterator);
  function onSendHookRunner(functions, request2, reply2, payload, cb) {
    let i = 0;
    function next(err2, newPayload) {
      if (err2) {
        cb(err2, request2, reply2, payload);
        return;
      }
      if (newPayload !== void 0) {
        payload = newPayload;
      }
      if (i === functions.length) {
        cb(null, request2, reply2, payload);
        return;
      }
      let result;
      try {
        result = functions[i++](request2, reply2, payload, next);
      } catch (error2) {
        cb(error2, request2, reply2);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err2) {
      if (!err2) {
        err2 = new FST_ERR_SEND_UNDEFINED_ERR();
      }
      cb(err2, request2, reply2, payload);
    }
    next();
  }
  const preSerializationHookRunner = onSendHookRunner;
  function preParsingHookRunner(functions, request2, reply2, cb) {
    let i = 0;
    function next(err2, newPayload) {
      if (reply2.sent) {
        return;
      }
      if (newPayload !== void 0) {
        request2[kRequestPayloadStream] = newPayload;
      }
      if (err2 || i === functions.length) {
        cb(err2, request2, reply2);
        return;
      }
      let result;
      try {
        result = functions[i++](request2, reply2, request2[kRequestPayloadStream], next);
      } catch (error2) {
        cb(error2, request2, reply2);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err2) {
      if (!err2) {
        err2 = new FST_ERR_SEND_UNDEFINED_ERR();
      }
      cb(err2, request2, reply2);
    }
    next();
  }
  function onRequestAbortHookRunner(functions, request2, cb) {
    let i = 0;
    function next(err2) {
      if (err2 || i === functions.length) {
        cb(err2, request2);
        return;
      }
      let result;
      try {
        result = functions[i++](request2, next);
      } catch (error2) {
        cb(error2, request2);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve() {
      next();
    }
    function handleReject(err2) {
      if (!err2) {
        err2 = new FST_ERR_SEND_UNDEFINED_ERR();
      }
      cb(err2, request2);
    }
    next();
  }
  function hookIterator(fn, request2, reply2, next) {
    if (reply2.sent === true) return void 0;
    return fn(request2, reply2, next);
  }
  hooks = {
    Hooks,
    buildHooks,
    hookRunnerGenerator,
    preParsingHookRunner,
    onResponseHookRunner,
    onSendHookRunner,
    preSerializationHookRunner,
    onRequestAbortHookRunner,
    hookIterator,
    hookRunnerApplication,
    onListenHookRunner,
    preHandlerHookRunner,
    preValidationHookRunner,
    onRequestHookRunner,
    onTimeoutHookRunner,
    lifecycleHooks,
    supportedHooks
  };
  return hooks;
}
var noopSet;
var hasRequiredNoopSet;
function requireNoopSet() {
  if (hasRequiredNoopSet) return noopSet;
  hasRequiredNoopSet = 1;
  noopSet = function noopSet2() {
    return {
      [Symbol.iterator]: function* () {
      },
      add() {
      },
      delete() {
      },
      has() {
        return true;
      }
    };
  };
  return noopSet;
}
var promise;
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  const { kTestInternals } = requireSymbols$1();
  function withResolvers() {
    let res2, rej;
    const promise2 = new Promise((resolve2, reject) => {
      res2 = resolve2;
      rej = reject;
    });
    return { promise: promise2, resolve: res2, reject: rej };
  }
  promise = {
    // TODO(20.x): remove when node@20 is not supported
    withResolvers: typeof Promise.withResolvers === "function" ? Promise.withResolvers.bind(Promise) : withResolvers,
    // Tested using the kTestInternals
    [kTestInternals]: {
      withResolvers
    }
  };
  return promise;
}
var hasRequiredServer;
function requireServer() {
  if (hasRequiredServer) return server;
  hasRequiredServer = 1;
  const http = require$$0$3;
  const https = require$$1;
  const http2 = require$$2;
  const dns = require$$3$1;
  const os = require$$4;
  const { kState, kOptions, kServerBindings, kHttp2ServerSessions } = requireSymbols$1();
  const { FSTWRN003 } = requireWarnings();
  const { onListenHookRunner } = requireHooks();
  const {
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_REOPENED_SERVER,
    FST_ERR_LISTEN_OPTIONS_INVALID,
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE
  } = requireErrors$2();
  const noopSet2 = requireNoopSet();
  const PonyPromise = requirePromise();
  server.createServer = createServer;
  function defaultResolveServerListeningText(address) {
    return `Server listening at ${address}`;
  }
  function createServer(options, httpHandler) {
    const server2 = getServerInstance(options, httpHandler);
    function listen(listenOptions = { port: 0, host: "localhost" }, cb = void 0) {
      if (typeof cb === "function") {
        if (cb.constructor.name === "AsyncFunction") {
          FSTWRN003("listen method");
        }
        listenOptions.cb = cb;
      }
      if (listenOptions.signal) {
        if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
          throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
        }
        this[kState].aborted = listenOptions.signal.aborted;
        if (this[kState].aborted) {
          return this.close();
        } else {
          const onAborted = () => {
            this[kState].aborted = true;
            this.close();
          };
          listenOptions.signal.addEventListener("abort", onAborted, { once: true });
        }
      }
      let host;
      if (listenOptions.path == null) {
        host = listenOptions.host ?? "localhost";
      } else {
        host = listenOptions.host;
      }
      if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
        listenOptions.host = host;
      }
      if (host === "localhost") {
        listenOptions.cb = (err2, address) => {
          if (err2) {
            cb(err2, address);
            return;
          }
          multipleBindings.call(this, server2, httpHandler, options, listenOptions, () => {
            this[kState].listening = true;
            cb(null, address);
            onListenHookRunner(this);
          });
        };
      } else {
        listenOptions.cb = (err2, address) => {
          if (err2) {
            cb(err2, address);
            return;
          }
          this[kState].listening = true;
          cb(null, address);
          onListenHookRunner(this);
        };
      }
      if (cb === void 0) {
        const listening = listenPromise.call(this, server2, listenOptions);
        return listening.then((address) => {
          const { promise: promise2, resolve: resolve2 } = PonyPromise.withResolvers();
          if (host === "localhost") {
            multipleBindings.call(this, server2, httpHandler, options, listenOptions, () => {
              this[kState].listening = true;
              resolve2(address);
              onListenHookRunner(this);
            });
          } else {
            resolve2(address);
            onListenHookRunner(this);
          }
          return promise2;
        });
      }
      this.ready(listenCallback.call(this, server2, listenOptions));
    }
    const serverHasCloseAllConnections = typeof server2.closeAllConnections === "function";
    const serverHasCloseIdleConnections = typeof server2.closeIdleConnections === "function";
    const serverHasCloseHttp2Sessions = typeof server2.closeHttp2Sessions === "function";
    let forceCloseConnections = options.forceCloseConnections;
    if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
      throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE();
    } else if (typeof forceCloseConnections !== "boolean") {
      forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
    }
    const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet2();
    return {
      server: server2,
      listen,
      forceCloseConnections,
      serverHasCloseAllConnections,
      serverHasCloseHttp2Sessions,
      keepAliveConnections
    };
  }
  function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
    this[kState].listening = false;
    dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
      if (dnsErr || this[kState].aborted) {
        onListen();
        return;
      }
      const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
      let binding = 0;
      let bound = 0;
      if (!isMainServerListening) {
        const primaryAddress = mainServer.address();
        for (const adr of addresses) {
          if (adr.address !== primaryAddress.address) {
            binding++;
            const secondaryOpts = Object.assign({}, listenOptions, {
              host: adr.address,
              port: primaryAddress.port,
              cb: (_ignoreErr) => {
                bound++;
                if (!_ignoreErr) {
                  this[kServerBindings].push(secondaryServer);
                }
                if (bound === binding) {
                  onListen();
                }
              }
            });
            const secondaryServer = getServerInstance(serverOpts, httpHandler);
            const closeSecondary = () => {
              secondaryServer.close(() => {
              });
              if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
                secondaryServer.closeAllConnections();
              }
              if (typeof secondaryServer.closeHttp2Sessions === "function") {
                secondaryServer.closeHttp2Sessions();
              }
            };
            secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
            mainServer.on("unref", closeSecondary);
            mainServer.on("close", closeSecondary);
            mainServer.on("error", closeSecondary);
            this[kState].listening = false;
            listenCallback.call(this, secondaryServer, secondaryOpts)();
          }
        }
      }
      if (binding === 0) {
        onListen();
        return;
      }
      const originUnref = mainServer.unref;
      mainServer.unref = function() {
        originUnref.call(mainServer);
        mainServer.emit("unref");
      };
    });
  }
  function listenCallback(server2, listenOptions) {
    const wrap = (err2) => {
      server2.removeListener("error", wrap);
      server2.removeListener("listening", wrap);
      if (!err2) {
        const address = logServerAddress.call(
          this,
          server2,
          listenOptions.listenTextResolver || defaultResolveServerListeningText
        );
        listenOptions.cb(null, address);
      } else {
        this[kState].listening = false;
        listenOptions.cb(err2, null);
      }
    };
    return (err2) => {
      if (err2 != null) return listenOptions.cb(err2);
      if (this[kState].listening && this[kState].closing) {
        return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null);
      }
      if (this[kState].listening) {
        return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null);
      }
      server2.once("error", wrap);
      if (!this[kState].closing) {
        server2.once("listening", wrap);
        server2.listen(listenOptions);
        this[kState].listening = true;
      }
    };
  }
  function listenPromise(server2, listenOptions) {
    if (this[kState].listening && this[kState].closing) {
      return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER());
    }
    if (this[kState].listening) {
      return Promise.reject(new FST_ERR_REOPENED_SERVER());
    }
    return this.ready().then(() => {
      if (this[kState].aborted) return;
      const { promise: promise2, resolve: resolve2, reject } = PonyPromise.withResolvers();
      const errEventHandler = (err2) => {
        cleanup();
        this[kState].listening = false;
        reject(err2);
      };
      const listeningEventHandler = () => {
        cleanup();
        this[kState].listening = true;
        resolve2(logServerAddress.call(
          this,
          server2,
          listenOptions.listenTextResolver || defaultResolveServerListeningText
        ));
      };
      function cleanup() {
        server2.removeListener("error", errEventHandler);
        server2.removeListener("listening", listeningEventHandler);
      }
      server2.once("error", errEventHandler);
      server2.once("listening", listeningEventHandler);
      server2.listen(listenOptions);
      return promise2;
    });
  }
  function getServerInstance(options, httpHandler) {
    if (options.serverFactory) {
      return options.serverFactory(httpHandler, options);
    }
    const httpsOptions = options.https === true ? {} : options.https;
    if (options.http2) {
      const server3 = typeof httpsOptions === "object" ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
      server3.on("session", (session) => session.setTimeout(options.http2SessionTimeout, () => {
        session.close();
      }));
      if (options.forceCloseConnections === true) {
        server3.closeHttp2Sessions = createCloseHttp2SessionsByHttp2Server(server3);
      }
      server3.setTimeout(options.connectionTimeout);
      return server3;
    }
    const server2 = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
    server2.keepAliveTimeout = options.keepAliveTimeout;
    server2.requestTimeout = options.requestTimeout;
    server2.setTimeout(options.connectionTimeout);
    if (options.maxRequestsPerSocket > 0) {
      server2.maxRequestsPerSocket = options.maxRequestsPerSocket;
    }
    return server2;
  }
  function getAddresses(address) {
    if (address.address === "0.0.0.0") {
      return Object.values(os.networkInterfaces()).flatMap((iface) => {
        return iface.filter((iface2) => iface2.family === "IPv4");
      }).sort((iface) => {
        return iface.internal ? -1 : 1;
      }).map((iface) => {
        return iface.address;
      });
    }
    return [address.address];
  }
  function logServerAddress(server2, listenTextResolver) {
    let addresses;
    const isUnixSocket = typeof server2.address() === "string";
    if (!isUnixSocket) {
      if (server2.address().address.indexOf(":") === -1) {
        addresses = getAddresses(server2.address()).map((address) => address + ":" + server2.address().port);
      } else {
        addresses = ["[" + server2.address().address + "]:" + server2.address().port];
      }
      addresses = addresses.map((address) => "http" + (this[kOptions].https ? "s" : "") + "://" + address);
    } else {
      addresses = [server2.address()];
    }
    for (const address of addresses) {
      this.log.info(listenTextResolver(address));
    }
    return addresses[0];
  }
  function createCloseHttp2SessionsByHttp2Server(http2Server) {
    http2Server[kHttp2ServerSessions] = /* @__PURE__ */ new Set();
    http2Server.on("session", function(session) {
      session.once("connect", function() {
        http2Server[kHttp2ServerSessions].add(session);
      });
      session.once("close", function() {
        http2Server[kHttp2ServerSessions].delete(session);
      });
      session.once("frameError", function(type2, code2, streamId) {
        if (streamId === 0) {
          http2Server[kHttp2ServerSessions].delete(session);
        }
      });
      session.once("goaway", function() {
        http2Server[kHttp2ServerSessions].delete(session);
      });
    });
    return function closeHttp2Sessions() {
      if (http2Server[kHttp2ServerSessions].size === 0) {
        return;
      }
      for (const session of http2Server[kHttp2ServerSessions]) {
        session.close();
      }
    };
  }
  return server;
}
var reply = { exports: {} };
var handleRequest = { exports: {} };
var contentType;
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;
  const keyValuePairsReg = /([\w!#$%&'*+.^`|~-]+)=([^;]*)/gm;
  const typeNameReg = /^[\w!#$%&'*+.^`|~-]+$/;
  const subtypeNameReg = /^[\w!#$%&'*+.^`|~-]+\s*/;
  class ContentType {
    #valid = false;
    #empty = true;
    #type = "";
    #subtype = "";
    #parameters = /* @__PURE__ */ new Map();
    #string;
    constructor(headerValue) {
      if (headerValue == null || headerValue === "" || headerValue === "undefined") {
        return;
      }
      let sepIdx = headerValue.indexOf(";");
      if (sepIdx === -1) {
        sepIdx = headerValue.indexOf("/");
        if (sepIdx === -1) {
          return;
        }
        const type3 = headerValue.slice(0, sepIdx).trimStart().toLowerCase();
        const subtype2 = headerValue.slice(sepIdx + 1).trimEnd().toLowerCase();
        if (typeNameReg.test(type3) === true && subtypeNameReg.test(subtype2) === true) {
          this.#valid = true;
          this.#empty = false;
          this.#type = type3;
          this.#subtype = subtype2;
        }
        return;
      }
      const mediaType = headerValue.slice(0, sepIdx).toLowerCase();
      const paramsList = headerValue.slice(sepIdx + 1).trim();
      sepIdx = mediaType.indexOf("/");
      if (sepIdx === -1) {
        return;
      }
      const type2 = mediaType.slice(0, sepIdx).trimStart();
      const subtype = mediaType.slice(sepIdx + 1).trimEnd();
      if (typeNameReg.test(type2) === false || subtypeNameReg.test(subtype) === false) {
        return;
      }
      this.#type = type2;
      this.#subtype = subtype;
      this.#valid = true;
      this.#empty = false;
      let matches = keyValuePairsReg.exec(paramsList);
      while (matches) {
        const key = matches[1];
        const value = matches[2];
        if (value[0] === '"') {
          if (value.at(-1) !== '"') {
            this.#parameters.set(key, "invalid quoted string");
            matches = keyValuePairsReg.exec(paramsList);
            continue;
          }
          this.#parameters.set(key, value.slice(1, value.length - 1));
        } else {
          this.#parameters.set(key, value);
        }
        matches = keyValuePairsReg.exec(paramsList);
      }
    }
    get [Symbol.toStringTag]() {
      return "ContentType";
    }
    get isEmpty() {
      return this.#empty;
    }
    get isValid() {
      return this.#valid;
    }
    get mediaType() {
      return `${this.#type}/${this.#subtype}`;
    }
    get type() {
      return this.#type;
    }
    get subtype() {
      return this.#subtype;
    }
    get parameters() {
      return this.#parameters;
    }
    toString() {
      if (this.#string) return this.#string;
      const parameters = [];
      for (const [key, value] of this.#parameters.entries()) {
        parameters.push(`${key}="${value}"`);
      }
      const result = [this.#type, "/", this.#subtype];
      if (parameters.length > 0) {
        result.push("; ");
        result.push(parameters.join("; "));
      }
      this.#string = result.join("");
      return this.#string;
    }
  }
  contentType = ContentType;
  return contentType;
}
var errorStatus;
var hasRequiredErrorStatus;
function requireErrorStatus() {
  if (hasRequiredErrorStatus) return errorStatus;
  hasRequiredErrorStatus = 1;
  const {
    kReplyHasStatusCode
  } = requireSymbols$1();
  function setErrorStatusCode(reply2, err2) {
    if (!reply2[kReplyHasStatusCode] || reply2.statusCode === 200) {
      const statusCode = err2 && (err2.statusCode || err2.status);
      reply2.code(statusCode >= 400 ? statusCode : 500);
    }
  }
  errorStatus = { setErrorStatusCode };
  return errorStatus;
}
var wrapThenable_1;
var hasRequiredWrapThenable;
function requireWrapThenable() {
  if (hasRequiredWrapThenable) return wrapThenable_1;
  hasRequiredWrapThenable = 1;
  const {
    kReplyIsError,
    kReplyHijacked
  } = requireSymbols$1();
  const { setErrorStatusCode } = requireErrorStatus();
  const diagnostics = require$$0$4;
  const channels = diagnostics.tracingChannel("fastify.request.handler");
  function wrapThenable(thenable, reply2, store) {
    if (store) store.async = true;
    thenable.then(function(payload) {
      if (reply2[kReplyHijacked] === true) {
        return;
      }
      if (store) {
        channels.asyncStart.publish(store);
      }
      try {
        if (payload !== void 0 || //
        reply2.sent === false && //
        reply2.raw.headersSent === false && reply2.request.raw.aborted === false && reply2.request.socket && !reply2.request.socket.destroyed) {
          try {
            reply2.send(payload);
          } catch (err2) {
            reply2[kReplyIsError] = true;
            reply2.send(err2);
          }
        }
      } finally {
        if (store) {
          channels.asyncEnd.publish(store);
        }
      }
    }, function(err2) {
      if (store) {
        store.error = err2;
        setErrorStatusCode(reply2, err2);
        channels.error.publish(store);
        channels.asyncStart.publish(store);
      }
      try {
        if (reply2.sent === true) {
          reply2.log.error({ err: err2 }, "Promise errored, but reply.sent = true was set");
          return;
        }
        reply2[kReplyIsError] = true;
        reply2.send(err2);
      } catch (err3) {
        reply2.send(err3);
      } finally {
        if (store) {
          channels.asyncEnd.publish(store);
        }
      }
    });
  }
  wrapThenable_1 = wrapThenable;
  return wrapThenable_1;
}
var validation$1;
var hasRequiredValidation$1;
function requireValidation$1() {
  if (hasRequiredValidation$1) return validation$1;
  hasRequiredValidation$1 = 1;
  const {
    kSchemaHeaders: headersSchema,
    kSchemaParams: paramsSchema,
    kSchemaQuerystring: querystringSchema,
    kSchemaBody: bodySchema,
    kSchemaResponse: responseSchema
  } = requireSymbols$1();
  const scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
  const {
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
  } = requireErrors$2();
  const { FSTWRN001 } = requireWarnings();
  function compileSchemasForSerialization(context2, compile2) {
    if (!context2.schema || !context2.schema.response) {
      return;
    }
    const { method, url } = context2.config || {};
    context2[responseSchema] = Object.keys(context2.schema.response).reduce(function(acc, statusCode) {
      const schema = context2.schema.response[statusCode];
      statusCode = statusCode.toLowerCase();
      if (!scChecker.test(statusCode)) {
        throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX();
      }
      if (schema.content) {
        const contentTypesSchemas = {};
        for (const mediaName of Object.keys(schema.content)) {
          const contentSchema = schema.content[mediaName].schema;
          contentTypesSchemas[mediaName] = compile2({
            schema: contentSchema,
            url,
            method,
            httpStatus: statusCode,
            contentType: mediaName
          });
        }
        acc[statusCode] = contentTypesSchemas;
      } else {
        acc[statusCode] = compile2({
          schema,
          url,
          method,
          httpStatus: statusCode
        });
      }
      return acc;
    }, {});
  }
  function compileSchemasForValidation(context2, compile2, isCustom) {
    const { schema } = context2;
    if (!schema) {
      return;
    }
    const { method, url } = context2.config || {};
    const headers = schema.headers;
    if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
      context2[headersSchema] = compile2({ schema: headers, method, url, httpPart: "headers" });
    } else if (headers) {
      const headersSchemaLowerCase = {};
      Object.keys(headers).forEach((k) => {
        headersSchemaLowerCase[k] = headers[k];
      });
      if (headersSchemaLowerCase.required instanceof Array) {
        headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
      }
      if (headers.properties) {
        headersSchemaLowerCase.properties = {};
        Object.keys(headers.properties).forEach((k) => {
          headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
        });
      }
      context2[headersSchema] = compile2({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
    } else if (Object.hasOwn(schema, "headers")) {
      FSTWRN001("headers", method, url);
    }
    if (schema.body) {
      const contentProperty = schema.body.content;
      if (contentProperty) {
        const contentTypeSchemas = {};
        for (const contentType2 of Object.keys(contentProperty)) {
          const contentSchema = contentProperty[contentType2].schema;
          contentTypeSchemas[contentType2] = compile2({ schema: contentSchema, method, url, httpPart: "body", contentType: contentType2 });
        }
        context2[bodySchema] = contentTypeSchemas;
      } else {
        context2[bodySchema] = compile2({ schema: schema.body, method, url, httpPart: "body" });
      }
    } else if (Object.hasOwn(schema, "body")) {
      FSTWRN001("body", method, url);
    }
    if (schema.querystring) {
      context2[querystringSchema] = compile2({ schema: schema.querystring, method, url, httpPart: "querystring" });
    } else if (Object.hasOwn(schema, "querystring")) {
      FSTWRN001("querystring", method, url);
    }
    if (schema.params) {
      context2[paramsSchema] = compile2({ schema: schema.params, method, url, httpPart: "params" });
    } else if (Object.hasOwn(schema, "params")) {
      FSTWRN001("params", method, url);
    }
  }
  function validateParam(validatorFunction, request2, paramName) {
    const isUndefined2 = request2[paramName] === void 0;
    let ret;
    try {
      ret = validatorFunction?.(isUndefined2 ? null : request2[paramName]);
    } catch (err2) {
      err2.statusCode = 500;
      return err2;
    }
    if (ret && typeof ret.then === "function") {
      return ret.then((res2) => {
        return answer(res2);
      }).catch((err2) => {
        return err2;
      });
    }
    return answer(ret);
    function answer(ret2) {
      if (ret2 === false) return validatorFunction.errors;
      if (ret2 && ret2.error) return ret2.error;
      if (ret2 && ret2.value) request2[paramName] = ret2.value;
      return false;
    }
  }
  function validate2(context2, request2, execution) {
    const runExecution = execution === void 0;
    if (runExecution || !execution.skipParams) {
      const params = validateParam(context2[paramsSchema], request2, "params");
      if (params) {
        if (typeof params.then !== "function") {
          return wrapValidationError(params, "params", context2.schemaErrorFormatter);
        } else {
          return validateAsyncParams(params, context2, request2);
        }
      }
    }
    if (runExecution || !execution.skipBody) {
      let validatorFunction = null;
      if (typeof context2[bodySchema] === "function") {
        validatorFunction = context2[bodySchema];
      } else if (context2[bodySchema]) {
        const contentType2 = getEssenceMediaType(request2.headers["content-type"]);
        const contentSchema = context2[bodySchema][contentType2];
        if (contentSchema) {
          validatorFunction = contentSchema;
        }
      }
      const body = validateParam(validatorFunction, request2, "body");
      if (body) {
        if (typeof body.then !== "function") {
          return wrapValidationError(body, "body", context2.schemaErrorFormatter);
        } else {
          return validateAsyncBody(body, context2, request2);
        }
      }
    }
    if (runExecution || !execution.skipQuery) {
      const query = validateParam(context2[querystringSchema], request2, "query");
      if (query) {
        if (typeof query.then !== "function") {
          return wrapValidationError(query, "querystring", context2.schemaErrorFormatter);
        } else {
          return validateAsyncQuery(query, context2, request2);
        }
      }
    }
    const headers = validateParam(context2[headersSchema], request2, "headers");
    if (headers) {
      if (typeof headers.then !== "function") {
        return wrapValidationError(headers, "headers", context2.schemaErrorFormatter);
      } else {
        return validateAsyncHeaders(headers, context2);
      }
    }
    return false;
  }
  function validateAsyncParams(validatePromise, context2, request2) {
    return validatePromise.then((paramsResult) => {
      if (paramsResult) {
        return wrapValidationError(paramsResult, "params", context2.schemaErrorFormatter);
      }
      return validate2(context2, request2, { skipParams: true });
    });
  }
  function validateAsyncBody(validatePromise, context2, request2) {
    return validatePromise.then((bodyResult) => {
      if (bodyResult) {
        return wrapValidationError(bodyResult, "body", context2.schemaErrorFormatter);
      }
      return validate2(context2, request2, { skipParams: true, skipBody: true });
    });
  }
  function validateAsyncQuery(validatePromise, context2, request2) {
    return validatePromise.then((queryResult) => {
      if (queryResult) {
        return wrapValidationError(queryResult, "querystring", context2.schemaErrorFormatter);
      }
      return validate2(context2, request2, { skipParams: true, skipBody: true, skipQuery: true });
    });
  }
  function validateAsyncHeaders(validatePromise, context2, request2) {
    return validatePromise.then((headersResult) => {
      if (headersResult) {
        return wrapValidationError(headersResult, "headers", context2.schemaErrorFormatter);
      }
      return false;
    });
  }
  function wrapValidationError(result, dataVar, schemaErrorFormatter) {
    if (result instanceof Error) {
      result.statusCode = result.statusCode || 400;
      result.code = result.code || "FST_ERR_VALIDATION";
      result.validationContext = result.validationContext || dataVar;
      return result;
    }
    const error2 = schemaErrorFormatter(result, dataVar);
    error2.statusCode = error2.statusCode || 400;
    error2.code = error2.code || "FST_ERR_VALIDATION";
    error2.validation = result;
    error2.validationContext = dataVar;
    return error2;
  }
  function getEssenceMediaType(header) {
    if (!header) return "";
    return header.split(/[ ;]/, 1)[0].trim().toLowerCase();
  }
  validation$1 = {
    symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
    compileSchemasForValidation,
    compileSchemasForSerialization,
    validate: validate2
  };
  return validation$1;
}
var hasRequiredHandleRequest;
function requireHandleRequest() {
  if (hasRequiredHandleRequest) return handleRequest.exports;
  hasRequiredHandleRequest = 1;
  (function(module) {
    const diagnostics = require$$0$4;
    const ContentType = requireContentType();
    const wrapThenable = requireWrapThenable();
    const { validate: validateSchema } = requireValidation$1();
    const { preValidationHookRunner, preHandlerHookRunner } = requireHooks();
    const { FST_ERR_CTP_INVALID_MEDIA_TYPE } = requireErrors$2();
    const { setErrorStatusCode } = requireErrorStatus();
    const {
      kReplyIsError,
      kRouteContext,
      kFourOhFourContext,
      kSupportedHTTPMethods
    } = requireSymbols$1();
    const channels = diagnostics.tracingChannel("fastify.request.handler");
    function handleRequest2(err2, request2, reply2) {
      if (reply2.sent === true) return;
      if (err2 != null) {
        reply2[kReplyIsError] = true;
        reply2.send(err2);
        return;
      }
      const method = request2.method;
      if (this[kSupportedHTTPMethods].bodyless.has(method)) {
        handler(request2, reply2);
        return;
      }
      if (this[kSupportedHTTPMethods].bodywith.has(method)) {
        const headers = request2.headers;
        const ctHeader = headers["content-type"];
        if (ctHeader === void 0) {
          const contentLength = headers["content-length"];
          const transferEncoding = headers["transfer-encoding"];
          const isEmptyBody = transferEncoding === void 0 && (contentLength === void 0 || contentLength === "0");
          if (isEmptyBody) {
            handler(request2, reply2);
            return;
          }
          request2[kRouteContext].contentTypeParser.run("", handler, request2, reply2);
          return;
        }
        const contentType2 = new ContentType(ctHeader);
        if (contentType2.isValid === false) {
          reply2[kReplyIsError] = true;
          reply2.status(415).send(new FST_ERR_CTP_INVALID_MEDIA_TYPE());
          return;
        }
        request2[kRouteContext].contentTypeParser.run(contentType2.toString(), handler, request2, reply2);
        return;
      }
      handler(request2, reply2);
    }
    function handler(request2, reply2) {
      try {
        if (request2[kRouteContext].preValidation !== null) {
          preValidationHookRunner(
            request2[kRouteContext].preValidation,
            request2,
            reply2,
            preValidationCallback
          );
        } else {
          preValidationCallback(null, request2, reply2);
        }
      } catch (err2) {
        preValidationCallback(err2, request2, reply2);
      }
    }
    function preValidationCallback(err2, request2, reply2) {
      if (reply2.sent === true) return;
      if (err2 != null) {
        reply2[kReplyIsError] = true;
        reply2.send(err2);
        return;
      }
      const validationErr = validateSchema(reply2[kRouteContext], request2);
      const isAsync = validationErr && typeof validationErr.then === "function" || false;
      if (isAsync) {
        const cb = validationCompleted.bind(null, request2, reply2);
        validationErr.then(cb, cb);
      } else {
        validationCompleted(request2, reply2, validationErr);
      }
    }
    function validationCompleted(request2, reply2, validationErr) {
      if (validationErr) {
        if (reply2[kRouteContext].attachValidation === false) {
          reply2.send(validationErr);
          return;
        }
        reply2.request.validationError = validationErr;
      }
      if (request2[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          request2[kRouteContext].preHandler,
          request2,
          reply2,
          preHandlerCallback
        );
      } else {
        preHandlerCallback(null, request2, reply2);
      }
    }
    function preHandlerCallback(err2, request2, reply2) {
      if (reply2.sent) return;
      const context2 = request2[kRouteContext];
      if (!channels.hasSubscribers || context2[kFourOhFourContext] === null) {
        preHandlerCallbackInner(err2, request2, reply2);
      } else {
        const store = {
          request: request2,
          reply: reply2,
          async: false,
          route: {
            url: context2.config.url,
            method: context2.config.method
          }
        };
        channels.start.runStores(store, preHandlerCallbackInner, void 0, err2, request2, reply2, store);
      }
    }
    function preHandlerCallbackInner(err2, request2, reply2, store) {
      const context2 = request2[kRouteContext];
      try {
        if (err2 != null) {
          reply2[kReplyIsError] = true;
          if (store) {
            store.error = err2;
            setErrorStatusCode(reply2, err2);
            channels.error.publish(store);
          }
          reply2.send(err2);
          return;
        }
        let result;
        try {
          result = context2.handler(request2, reply2);
        } catch (err3) {
          if (store) {
            store.error = err3;
            setErrorStatusCode(reply2, err3);
            channels.error.publish(store);
          }
          reply2[kReplyIsError] = true;
          reply2.send(err3);
          return;
        }
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply2, store);
          } else {
            reply2.send(result);
          }
        }
      } finally {
        if (store) channels.end.publish(store);
      }
    }
    module.exports = handleRequest2;
    module.exports[/* @__PURE__ */ Symbol.for("internals")] = { handler, preHandlerCallback };
  })(handleRequest);
  return handleRequest.exports;
}
var abstractLogging = { exports: {} };
abstractLogging.exports;
var hasRequiredAbstractLogging;
function requireAbstractLogging() {
  if (hasRequiredAbstractLogging) return abstractLogging.exports;
  hasRequiredAbstractLogging = 1;
  (function(module) {
    function noop2() {
    }
    const proto2 = {
      fatal: noop2,
      error: noop2,
      warn: noop2,
      info: noop2,
      debug: noop2,
      trace: noop2
    };
    Object.defineProperty(module, "exports", {
      get() {
        return Object.create(proto2);
      }
    });
  })(abstractLogging);
  return abstractLogging.exports;
}
var pino = { exports: {} };
var errHelpers;
var hasRequiredErrHelpers;
function requireErrHelpers() {
  if (hasRequiredErrHelpers) return errHelpers;
  hasRequiredErrHelpers = 1;
  const isErrorLike = (err2) => {
    return err2 && typeof err2.message === "string";
  };
  const getErrorCause = (err2) => {
    if (!err2) return;
    const cause = err2.cause;
    if (typeof cause === "function") {
      const causeResult = err2.cause();
      return isErrorLike(causeResult) ? causeResult : void 0;
    } else {
      return isErrorLike(cause) ? cause : void 0;
    }
  };
  const _stackWithCauses = (err2, seen) => {
    if (!isErrorLike(err2)) return "";
    const stack = err2.stack || "";
    if (seen.has(err2)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  const stackWithCauses = (err2) => _stackWithCauses(err2, /* @__PURE__ */ new Set());
  const _messageWithCauses = (err2, seen, skip) => {
    if (!isErrorLike(err2)) return "";
    const message = skip ? "" : err2.message || "";
    if (seen.has(err2)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      const skipIfVErrorStyleCause = typeof err2.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  const messageWithCauses = (err2) => _messageWithCauses(err2, /* @__PURE__ */ new Set());
  errHelpers = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
  return errHelpers;
}
var errProto;
var hasRequiredErrProto;
function requireErrProto() {
  if (hasRequiredErrProto) return errProto;
  hasRequiredErrProto = 1;
  const seen = /* @__PURE__ */ Symbol("circular-ref-tag");
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-err-ref");
  const pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    message: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    stack: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  errProto = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
  return errProto;
}
var err;
var hasRequiredErr;
function requireErr() {
  if (hasRequiredErr) return err;
  hasRequiredErr = 1;
  err = errSerializer;
  const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = messageWithCauses(err2);
    _err.stack = stackWithCauses(err2);
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errSerializer(err3));
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return err;
}
var errWithCause;
var hasRequiredErrWithCause;
function requireErrWithCause() {
  if (hasRequiredErrWithCause) return errWithCause;
  hasRequiredErrWithCause = 1;
  errWithCause = errWithCauseSerializer;
  const { isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errWithCauseSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = err2.message;
    _err.stack = err2.stack;
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errWithCauseSerializer(err3));
    }
    if (isErrorLike(err2.cause) && !Object.prototype.hasOwnProperty.call(err2.cause, seen)) {
      _err.cause = errWithCauseSerializer(err2.cause);
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return errWithCause;
}
var req;
var hasRequiredReq;
function requireReq() {
  if (hasRequiredReq) return req;
  hasRequiredReq = 1;
  req = {
    mapHttpRequest,
    reqSerializer
  };
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-req-ref");
  const pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req2) {
    const connection = req2.info || req2.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req2.id === "function" ? req2.id() : req2.id || (req2.info ? req2.info.id : void 0);
    _req.method = req2.method;
    if (req2.originalUrl) {
      _req.url = req2.originalUrl;
    } else {
      const path2 = req2.path;
      _req.url = typeof path2 === "string" ? path2 : req2.url ? req2.url.path || req2.url : void 0;
    }
    if (req2.query) {
      _req.query = req2.query;
    }
    if (req2.params) {
      _req.params = req2.params;
    }
    _req.headers = req2.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req2.raw || req2;
    return _req;
  }
  function mapHttpRequest(req2) {
    return {
      req: reqSerializer(req2)
    };
  }
  return req;
}
var res;
var hasRequiredRes;
function requireRes() {
  if (hasRequiredRes) return res;
  hasRequiredRes = 1;
  res = {
    mapHttpResponse,
    resSerializer
  };
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-res-ref");
  const pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res2) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res2.headersSent ? res2.statusCode : null;
    _res.headers = res2.getHeaders ? res2.getHeaders() : res2._headers;
    _res.raw = res2;
    return _res;
  }
  function mapHttpResponse(res2) {
    return {
      res: resSerializer(res2)
    };
  }
  return res;
}
var pinoStdSerializers;
var hasRequiredPinoStdSerializers;
function requirePinoStdSerializers() {
  if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
  hasRequiredPinoStdSerializers = 1;
  const errSerializer = requireErr();
  const errWithCauseSerializer = requireErrWithCause();
  const reqSerializers = requireReq();
  const resSerializers = requireRes();
  pinoStdSerializers = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer) return customSerializer;
      return function wrapErrSerializer(err2) {
        return customSerializer(errSerializer(err2));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
      return function wrappedReqSerializer(req2) {
        return customSerializer(reqSerializers.reqSerializer(req2));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer) return customSerializer;
      return function wrappedResSerializer(res2) {
        return customSerializer(resSerializers.resSerializer(res2));
      };
    }
  };
  return pinoStdSerializers;
}
var caller;
var hasRequiredCaller;
function requireCaller() {
  if (hasRequiredCaller) return caller;
  hasRequiredCaller = 1;
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  caller = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return void 0;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
  return caller;
}
var redact;
var hasRequiredRedact;
function requireRedact() {
  if (hasRequiredRedact) return redact;
  hasRequiredRedact = 1;
  function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
      const cloned = [];
      for (let i = 0; i < obj.length; i++) {
        cloned[i] = deepClone(obj[i]);
      }
      return cloned;
    }
    if (typeof obj === "object") {
      const cloned = Object.create(Object.getPrototypeOf(obj));
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          cloned[key] = deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
  function parsePath(path2) {
    const parts = [];
    let current = "";
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0; i < path2.length; i++) {
      const char = path2[i];
      if (!inBrackets && char === ".") {
        if (current) {
          parts.push(current);
          current = "";
        }
      } else if (char === "[") {
        if (current) {
          parts.push(current);
          current = "";
        }
        inBrackets = true;
      } else if (char === "]" && inBrackets) {
        parts.push(current);
        current = "";
        inBrackets = false;
        inQuotes = false;
      } else if ((char === '"' || char === "'") && inBrackets) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        } else {
          current += char;
        }
      } else {
        current += char;
      }
    }
    if (current) {
      parts.push(current);
    }
    return parts;
  }
  function setValue(obj, parts, value) {
    let current = obj;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0; i < current.length; i++) {
          current[i] = value;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            current[key] = value;
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        current[lastKey] = value;
      }
    }
    return true;
  }
  function removeKey(obj, parts) {
    let current = obj;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0; i < current.length; i++) {
          current[i] = void 0;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            delete current[key];
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        delete current[lastKey];
      }
    }
    return true;
  }
  const PATH_NOT_FOUND = /* @__PURE__ */ Symbol("PATH_NOT_FOUND");
  function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return PATH_NOT_FOUND;
      }
      if (typeof current !== "object" || current === null) {
        return PATH_NOT_FOUND;
      }
      if (!(part in current)) {
        return PATH_NOT_FOUND;
      }
      current = current[part];
    }
    return current;
  }
  function getValue(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return void 0;
      }
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[part];
    }
    return current;
  }
  function redactPaths(obj, paths, censor, remove = false) {
    for (const path2 of paths) {
      const parts = parsePath(path2);
      if (parts.includes("*")) {
        redactWildcardPath(obj, parts, censor, path2, remove);
      } else {
        if (remove) {
          removeKey(obj, parts);
        } else {
          const value = getValueIfExists(obj, parts);
          if (value === PATH_NOT_FOUND) {
            continue;
          }
          const actualCensor = typeof censor === "function" ? censor(value, parts) : censor;
          setValue(obj, parts, actualCensor);
        }
      }
    }
  }
  function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf("*");
    if (wildcardIndex === parts.length - 1) {
      const parentParts = parts.slice(0, -1);
      let current = obj;
      for (const part of parentParts) {
        if (current === null || current === void 0) return;
        if (typeof current !== "object" || current === null) return;
        current = current[part];
      }
      if (Array.isArray(current)) {
        if (remove) {
          for (let i = 0; i < current.length; i++) {
            current[i] = void 0;
          }
        } else {
          for (let i = 0; i < current.length; i++) {
            const indexPath = [...parentParts, i.toString()];
            const actualCensor = typeof censor === "function" ? censor(current[i], indexPath) : censor;
            current[i] = actualCensor;
          }
        }
      } else if (typeof current === "object" && current !== null) {
        if (remove) {
          const keysToDelete = [];
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              keysToDelete.push(key);
            }
          }
          for (const key of keysToDelete) {
            delete current[key];
          }
        } else {
          for (const key in current) {
            const keyPath = [...parentParts, key];
            const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
            current[key] = actualCensor;
          }
        }
      }
    } else {
      redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
  }
  function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [];
    function traverse(current, pathLength) {
      if (pathLength === beforeWildcard.length) {
        if (Array.isArray(current)) {
          for (let i = 0; i < current.length; i++) {
            pathArray[pathLength] = i.toString();
            traverse(current[i], pathLength + 1);
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            pathArray[pathLength] = key;
            traverse(current[key], pathLength + 1);
          }
        }
      } else if (pathLength < beforeWildcard.length) {
        const nextKey = beforeWildcard[pathLength];
        if (current && typeof current === "object" && current !== null && nextKey in current) {
          pathArray[pathLength] = nextKey;
          traverse(current[nextKey], pathLength + 1);
        }
      } else {
        if (afterWildcard.includes("*")) {
          const wrappedCensor = typeof censor === "function" ? (value, path2) => {
            const fullPath = [...pathArray.slice(0, pathLength), ...path2];
            return censor(value, fullPath);
          } : censor;
          redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
        } else {
          if (remove) {
            removeKey(current, afterWildcard);
          } else {
            const actualCensor = typeof censor === "function" ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
            setValue(current, afterWildcard, actualCensor);
          }
        }
      }
    }
    if (beforeWildcard.length === 0) {
      traverse(obj, 0);
    } else {
      let current = obj;
      for (let i = 0; i < beforeWildcard.length; i++) {
        const part = beforeWildcard[i];
        if (current === null || current === void 0) return;
        if (typeof current !== "object" || current === null) return;
        current = current[part];
        pathArray[i] = part;
      }
      if (current !== null && current !== void 0) {
        traverse(current, beforeWildcard.length);
      }
    }
  }
  function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
      return null;
    }
    const pathStructure = /* @__PURE__ */ new Map();
    for (const path2 of pathsToClone) {
      const parts = parsePath(path2);
      let current = pathStructure;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!current.has(part)) {
          current.set(part, /* @__PURE__ */ new Map());
        }
        current = current.get(part);
      }
    }
    return pathStructure;
  }
  function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
      return obj;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
      if (!pathMap || pathMap.size === 0) {
        return source;
      }
      if (source === null || typeof source !== "object") {
        return source;
      }
      if (source instanceof Date) {
        return new Date(source.getTime());
      }
      if (Array.isArray(source)) {
        const cloned2 = [];
        for (let i = 0; i < source.length; i++) {
          const indexStr = i.toString();
          if (pathMap.has(indexStr) || pathMap.has("*")) {
            cloned2[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get("*"));
          } else {
            cloned2[i] = source[i];
          }
        }
        return cloned2;
      }
      const cloned = Object.create(Object.getPrototypeOf(source));
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          if (pathMap.has(key) || pathMap.has("*")) {
            cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
          } else {
            cloned[key] = source[key];
          }
        }
      }
      return cloned;
    }
    return cloneSelectively(obj, pathStructure);
  }
  function validatePath(path2) {
    if (typeof path2 !== "string") {
      throw new Error("Paths must be (non-empty) strings");
    }
    if (path2 === "") {
      throw new Error("Invalid redaction path ()");
    }
    if (path2.includes("..")) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
    if (path2.includes(",")) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0; i < path2.length; i++) {
      const char = path2[i];
      if ((char === '"' || char === "'") && bracketCount > 0) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        }
      } else if (char === "[" && !inQuotes) {
        bracketCount++;
      } else if (char === "]" && !inQuotes) {
        bracketCount--;
        if (bracketCount < 0) {
          throw new Error(`Invalid redaction path (${path2})`);
        }
      }
    }
    if (bracketCount !== 0) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
  }
  function validatePaths(paths) {
    if (!Array.isArray(paths)) {
      throw new TypeError("paths must be an array");
    }
    for (const path2 of paths) {
      validatePath(path2);
    }
  }
  function slowRedact(options = {}) {
    const {
      paths = [],
      censor = "[REDACTED]",
      serialize: serialize2 = JSON.stringify,
      strict = true,
      remove = false
    } = options;
    validatePaths(paths);
    const pathStructure = buildPathStructure(paths);
    return function redact2(obj) {
      if (strict && (obj === null || typeof obj !== "object")) {
        if (obj === null || obj === void 0) {
          return serialize2 ? serialize2(obj) : obj;
        }
        if (typeof obj !== "object") {
          return serialize2 ? serialize2(obj) : obj;
        }
      }
      const cloned = selectiveClone(obj, pathStructure);
      const original = obj;
      let actualCensor = censor;
      if (typeof censor === "function") {
        actualCensor = censor;
      }
      redactPaths(cloned, paths, actualCensor, remove);
      if (serialize2 === false) {
        cloned.restore = function() {
          return deepClone(original);
        };
        return cloned;
      }
      if (typeof serialize2 === "function") {
        return serialize2(cloned);
      }
      return JSON.stringify(cloned);
    };
  }
  redact = slowRedact;
  return redact;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  const setLevelSym = /* @__PURE__ */ Symbol("pino.setLevel");
  const getLevelSym = /* @__PURE__ */ Symbol("pino.getLevel");
  const levelValSym = /* @__PURE__ */ Symbol("pino.levelVal");
  const levelCompSym = /* @__PURE__ */ Symbol("pino.levelComp");
  const useLevelLabelsSym = /* @__PURE__ */ Symbol("pino.useLevelLabels");
  const useOnlyCustomLevelsSym = /* @__PURE__ */ Symbol("pino.useOnlyCustomLevels");
  const mixinSym = /* @__PURE__ */ Symbol("pino.mixin");
  const lsCacheSym = /* @__PURE__ */ Symbol("pino.lsCache");
  const chindingsSym = /* @__PURE__ */ Symbol("pino.chindings");
  const asJsonSym = /* @__PURE__ */ Symbol("pino.asJson");
  const writeSym = /* @__PURE__ */ Symbol("pino.write");
  const redactFmtSym = /* @__PURE__ */ Symbol("pino.redactFmt");
  const timeSym = /* @__PURE__ */ Symbol("pino.time");
  const timeSliceIndexSym = /* @__PURE__ */ Symbol("pino.timeSliceIndex");
  const streamSym = /* @__PURE__ */ Symbol("pino.stream");
  const stringifySym = /* @__PURE__ */ Symbol("pino.stringify");
  const stringifySafeSym = /* @__PURE__ */ Symbol("pino.stringifySafe");
  const stringifiersSym = /* @__PURE__ */ Symbol("pino.stringifiers");
  const endSym = /* @__PURE__ */ Symbol("pino.end");
  const formatOptsSym = /* @__PURE__ */ Symbol("pino.formatOpts");
  const messageKeySym = /* @__PURE__ */ Symbol("pino.messageKey");
  const errorKeySym = /* @__PURE__ */ Symbol("pino.errorKey");
  const nestedKeySym = /* @__PURE__ */ Symbol("pino.nestedKey");
  const nestedKeyStrSym = /* @__PURE__ */ Symbol("pino.nestedKeyStr");
  const mixinMergeStrategySym = /* @__PURE__ */ Symbol("pino.mixinMergeStrategy");
  const msgPrefixSym = /* @__PURE__ */ Symbol("pino.msgPrefix");
  const wildcardFirstSym = /* @__PURE__ */ Symbol("pino.wildcardFirst");
  const serializersSym = /* @__PURE__ */ Symbol.for("pino.serializers");
  const formattersSym = /* @__PURE__ */ Symbol.for("pino.formatters");
  const hooksSym = /* @__PURE__ */ Symbol.for("pino.hooks");
  const needsMetadataGsym = /* @__PURE__ */ Symbol.for("pino.metadata");
  symbols = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
  return symbols;
}
var redaction_1;
var hasRequiredRedaction;
function requireRedaction() {
  if (hasRequiredRedaction) return redaction_1;
  hasRequiredRedaction = 1;
  const Redact = requireRedact();
  const { redactFmtSym, wildcardFirstSym } = requireSymbols();
  const rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
  const CENSOR = "[Redacted]";
  const strict = false;
  function redaction(opts, serialize2) {
    const { paths, censor, remove } = handle(opts);
    const shape = paths.reduce((o, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next = rx.exec(str);
      let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index } = next;
      const nextPath = `${str.substr(index, str.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: Redact({ paths, censor, serialize: serialize2, strict, remove })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize2(censor(...args)) : serialize2(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path2) => {
          return censor(value, [k, ...path2]);
        } : censor;
        o[k] = Redact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize: serialize2,
          strict,
          remove
        });
      }
      return o;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino – redact must contain an array of strings");
    }
    if (remove === true) censor = void 0;
    return { paths, censor, remove };
  }
  redaction_1 = redaction;
  return redaction_1;
}
var time$2;
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time$2;
  hasRequiredTime = 1;
  const nullTime = () => "";
  const epochTime = () => `,"time":${Date.now()}`;
  const unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
  const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  const NS_PER_MS = 1000000n;
  const NS_PER_SEC = 1000000000n;
  const startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
  const startHrTime = process.hrtime.bigint();
  const isoTimeNano = () => {
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
    const date2 = new Date(msSinceEpoch);
    const year = date2.getUTCFullYear();
    const month = (date2.getUTCMonth() + 1).toString().padStart(2, "0");
    const day = date2.getUTCDate().toString().padStart(2, "0");
    const hours = date2.getUTCHours().toString().padStart(2, "0");
    const minutes = date2.getUTCMinutes().toString().padStart(2, "0");
    const seconds = date2.getUTCSeconds().toString().padStart(2, "0");
    return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
  };
  time$2 = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
  return time$2;
}
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format2;
  function format2(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset;
      if (len === 1) return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index = 1; index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0; i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          // 'd'
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          // 'O'
          case 111:
          // 'o'
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === void 0) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            var type2 = typeof args[a];
            if (type2 === "string") {
              str += "'" + args[a] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type2 === "function") {
              str += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  }
  return quickFormatUnescaped;
}
var atomicSleep = { exports: {} };
var hasRequiredAtomicSleep;
function requireAtomicSleep() {
  if (hasRequiredAtomicSleep) return atomicSleep.exports;
  hasRequiredAtomicSleep = 1;
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid2 = ms > 0 && ms < Infinity;
      if (valid2 === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    atomicSleep.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid2 = ms > 0 && ms < Infinity;
      if (valid2 === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
    };
    atomicSleep.exports = sleep;
  }
  return atomicSleep.exports;
}
var sonicBoom;
var hasRequiredSonicBoom;
function requireSonicBoom() {
  if (hasRequiredSonicBoom) return sonicBoom;
  hasRequiredSonicBoom = 1;
  const fs$1 = fs;
  const EventEmitter = require$$1$1;
  const inherits = require$$2$1.inherits;
  const path$1 = path;
  const sleep = requireAtomicSleep();
  const assert = require$$5;
  const BUSY_WRITE_TIMEOUT = 100;
  const kEmptyBuffer = Buffer.allocUnsafe(0);
  const MAX_WRITE = 16 * 1024;
  const kContentModeBuffer = "buffer";
  const kContentModeUtf8 = "utf8";
  const [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  const kCopyBuffer = major >= 22 && minor >= 7;
  function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err2, fd) {
      if (err2) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err2);
            }
          });
        } else {
          sonic.emit("error", err2);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir) fs$1.mkdirSync(path$1.dirname(file), { recursive: true });
        const fd = fs$1.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err2) {
        fileOpened(err2);
        throw err2;
      }
    } else if (sonic.mkdir) {
      fs$1.mkdir(path$1.dirname(file), { recursive: true }, (err2) => {
        if (err2) return fileOpened(err2);
        fs$1.open(file, flags, mode, fileOpened);
      });
    } else {
      fs$1.open(file, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = void 0;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs$1.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs$1.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => {
        if (Buffer.isBuffer(this._writingBuf)) {
          return fs$1.writeSync(this.fd, this._writingBuf);
        }
        return fs$1.writeSync(this.fd, this._writingBuf, "utf8");
      };
      fsWrite = () => {
        if (Buffer.isBuffer(this._writingBuf)) {
          return fs$1.write(this.fd, this._writingBuf, this.release);
        }
        return fs$1.write(this.fd, this._writingBuf, "utf8", this.release);
      };
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err2, n) => {
      if (err2) {
        if ((err2.code === "EAGAIN" || err2.code === "EBUSY") && this.retryEAGAIN(err2, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(void 0, 0);
            } catch (err3) {
              this.release(err3);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err2);
        }
        return;
      }
      this.emit("write", n);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n2 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err3) {
          this.release(err3);
          return;
        }
      }
      if (this._fsync) {
        fs$1.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n) {
    if (typeof writingBuf === "string") {
      writingBuf = Buffer.from(writingBuf);
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.subarray(n);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits(SonicBoom, EventEmitter);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    data = "" + data;
    const dataLen = Buffer.byteLength(data);
    const len = this._len + dataLen;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || Buffer.byteLength(bufs[bufs.length - 1]) + dataLen > this.maxWrite) {
      bufs.push(data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs$1.fsync(this.fd, (err2) => {
            this._flushPending = false;
            cb(err2);
          });
        } catch (err2) {
          cb(err2);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err2) => {
      this._flushPending = false;
      cb(err2);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file) {
      this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs$1.close(fd, (err2) => {
          if (err2) {
            return this.emit("error", err2);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = Buffer.isBuffer(buf) ? fs$1.writeSync(this.fd, buf) : fs$1.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs$1.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n = fs$1.writeSync(this.fd, buf);
        buf = buf.subarray(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = Buffer.isBuffer(this._writingBuf) ? fs$1.writeSync(this.fd, this._writingBuf) : fs$1.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      fs$1.write(this.fd, this._writingBuf, release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs$1.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs$1.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== void 0) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs$1.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs$1.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err2) {
      if (err2) {
        sonic.emit("error", err2);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  sonicBoom = SonicBoom;
  return sonicBoom;
}
var onExitLeakFree;
var hasRequiredOnExitLeakFree;
function requireOnExitLeakFree() {
  if (hasRequiredOnExitLeakFree) return onExitLeakFree;
  hasRequiredOnExitLeakFree = 1;
  const refs = {
    exit: [],
    beforeExit: []
  };
  const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  let registry2;
  function ensureRegistry() {
    if (registry2 === void 0) {
      registry2 = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry2 = void 0;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref2 of refs[event]) {
      const obj = ref2.deref();
      const fn = ref2.fn;
      if (obj !== void 0) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref2) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref2);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === void 0) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref2 = new WeakRef(obj);
    ref2.fn = fn;
    ensureRegistry();
    registry2.register(obj, ref2);
    refs[event].push(ref2);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry2 === void 0) {
      return;
    }
    registry2.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref2) => {
        const _obj = ref2.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  onExitLeakFree = {
    register,
    registerBeforeExit,
    unregister
  };
  return onExitLeakFree;
}
const version$1 = "4.0.0";
const require$$0 = {
  version: version$1
};
var wait_1;
var hasRequiredWait;
function requireWait() {
  if (hasRequiredWait) return wait_1;
  hasRequiredWait = 1;
  const WAIT_MS = 1e4;
  function wait(state, index, expected, timeout, done) {
    const max = timeout === Infinity ? Infinity : Date.now() + timeout;
    const check = () => {
      const current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      if (max !== Infinity && Date.now() > max) {
        done(null, "timed-out");
        return;
      }
      const remaining = max === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max - Date.now()));
      const result = Atomics.waitAsync(state, index, current, remaining);
      if (result.async) {
        result.value.then(check);
      } else {
        setImmediate(check);
      }
    };
    check();
  }
  function waitDiff(state, index, expected, timeout, done) {
    const max = timeout === Infinity ? Infinity : Date.now() + timeout;
    const check = () => {
      const current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      if (max !== Infinity && Date.now() > max) {
        done(null, "timed-out");
        return;
      }
      const remaining = max === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max - Date.now()));
      const result = Atomics.waitAsync(state, index, expected, remaining);
      if (result.async) {
        result.value.then(check);
      } else {
        setImmediate(check);
      }
    };
    check();
  }
  wait_1 = { wait, waitDiff };
  return wait_1;
}
var indexes;
var hasRequiredIndexes;
function requireIndexes() {
  if (hasRequiredIndexes) return indexes;
  hasRequiredIndexes = 1;
  const WRITE_INDEX = 4;
  const READ_INDEX = 8;
  indexes = {
    WRITE_INDEX,
    READ_INDEX
  };
  return indexes;
}
var threadStream;
var hasRequiredThreadStream;
function requireThreadStream() {
  if (hasRequiredThreadStream) return threadStream;
  hasRequiredThreadStream = 1;
  const { version: version2 } = require$$0;
  const { EventEmitter } = require$$1$1;
  const { Worker } = require$$2$2;
  const { join } = path;
  const { pathToFileURL } = require$$4$1;
  const { wait } = requireWait();
  const {
    WRITE_INDEX,
    READ_INDEX
  } = requireIndexes();
  const buffer = require$$7;
  const assert = require$$5;
  const kImpl = /* @__PURE__ */ Symbol("kImpl");
  const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }
  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  const FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
  const WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;
  const registry2 = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version2
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry2.register(stream, worker);
    return worker;
  }
  function drain(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  }
  function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          Atomics.notify(stream[kImpl].state, READ_INDEX);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream[kImpl].state, READ_INDEX);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === void 0) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code2) {
    const stream = this.stream.deref();
    if (stream === void 0) {
      return;
    }
    registry2.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code2 !== 0 ? new Error("the worker thread exited") : null);
  }
  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message, transferList) => {
        this.worker.postMessage(message, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error2(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error2(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err2, res2) => {
        if (err2) {
          destroy(this, err2);
          process.nextTick(cb, err2);
          return;
        }
        if (res2 === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error2(stream, err2) {
    setImmediate(() => {
      stream.emit("error", err2);
    });
  }
  function destroy(stream, err2) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err2) {
      stream[kImpl].errored = err2;
      error2(stream, err2);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {
      }).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  }
  function write(stream, data, cb) {
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err2) {
      destroy(stream, err2);
    }
  }
  function writeSync(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream[kImpl].state, READ_INDEX);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream[kImpl].state, READ_INDEX);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  }
  function flushSync(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  threadStream = ThreadStream;
  return threadStream;
}
var transport_1;
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport_1;
  hasRequiredTransport = 1;
  const { createRequire } = require$$0$5;
  const { existsSync } = require$$1$2;
  const getCallers = requireCaller();
  const { join, isAbsolute, sep } = require$$3$2;
  const { fileURLToPath } = require$$4$2;
  const sleep = requireAtomicSleep();
  const onExit = requireOnExitLeakFree();
  const ThreadStream = requireThreadStream();
  function setupOnExit(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  }
  function hasPreloadFlags() {
    const execArgv = process.execArgv;
    for (let i = 0; i < execArgv.length; i++) {
      const arg = execArgv[i];
      if (arg === "--import" || arg === "--require" || arg === "-r") {
        return true;
      }
      if (arg.startsWith("--import=") || arg.startsWith("--require=") || arg.startsWith("-r=")) {
        return true;
      }
    }
    return false;
  }
  function sanitizeNodeOptions(nodeOptions) {
    const tokens2 = nodeOptions.match(/(?:[^\s"']+|"[^"]*"|'[^']*')+/g);
    if (!tokens2) {
      return nodeOptions;
    }
    const sanitized = [];
    let changed = false;
    for (let i = 0; i < tokens2.length; i++) {
      const token = tokens2[i];
      if (token === "--require" || token === "-r" || token === "--import") {
        const next = tokens2[i + 1];
        if (next && shouldDropPreload(next)) {
          changed = true;
          i++;
          continue;
        }
        sanitized.push(token);
        if (next) {
          sanitized.push(next);
          i++;
        }
        continue;
      }
      if (token.startsWith("--require=") || token.startsWith("-r=") || token.startsWith("--import=")) {
        const value = token.slice(token.indexOf("=") + 1);
        if (shouldDropPreload(value)) {
          changed = true;
          continue;
        }
      }
      sanitized.push(token);
    }
    return changed ? sanitized.join(" ") : nodeOptions;
  }
  function shouldDropPreload(value) {
    const unquoted = stripQuotes(value);
    if (!unquoted) {
      return false;
    }
    let path2 = unquoted;
    if (path2.startsWith("file://")) {
      try {
        path2 = fileURLToPath(path2);
      } catch {
        return false;
      }
    }
    return isAbsolute(path2) && !existsSync(path2);
  }
  function stripQuotes(value) {
    const first = value[0];
    const last = value[value.length - 1];
    if (first === '"' && last === '"' || first === "'" && last === "'") {
      return value.slice(1, -1);
    }
    return value;
  }
  function buildStream(filename, workerData, workerOpts, sync, name) {
    if (!workerOpts.execArgv && hasPreloadFlags() && require.main === void 0) {
      workerOpts = {
        ...workerOpts,
        execArgv: []
      };
    }
    if (!workerOpts.env && process.env.NODE_OPTIONS) {
      const nodeOptions = sanitizeNodeOptions(process.env.NODE_OPTIONS);
      if (nodeOptions !== process.env.NODE_OPTIONS) {
        workerOpts = {
          ...workerOpts,
          env: {
            ...process.env,
            NODE_OPTIONS: nodeOptions
          }
        };
      }
    }
    workerOpts = { ...workerOpts, name };
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  }
  function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  }
  function flush(stream) {
    stream.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels: levels2, dedupe, worker = {}, caller: caller2 = getCallers(), sync = false } = fullOptions;
    const options = {
      ...fullOptions.options
    };
    const callers = typeof caller2 === "string" ? [caller2] : caller2;
    const bundlerOverrides = typeof globalThis === "object" && Object.prototype.hasOwnProperty.call(globalThis, "__bundlerPathsOverrides") && globalThis.__bundlerPathsOverrides && typeof globalThis.__bundlerPathsOverrides === "object" ? globalThis.__bundlerPathsOverrides : /* @__PURE__ */ Object.create(null);
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t) => {
          return {
            ...t,
            level: dest.level,
            // duplicate the pipeline `level` property defined in the upper level
            target: fixTarget(t.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels2) {
      options.levels = levels2;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    const name = targets || pipeline ? "pino.transport" : target;
    return buildStream(fixTarget(target), options, worker, sync, name);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context2 = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context2).resolve(origin);
          break;
        } catch (err2) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  transport_1 = transport;
  return transport_1;
}
var tools;
var hasRequiredTools;
function requireTools() {
  if (hasRequiredTools) return tools;
  hasRequiredTools = 1;
  const diagChan = require$$0$4;
  const format2 = requireQuickFormatUnescaped();
  const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
  const SonicBoom = requireSonicBoom();
  const onExit = requireOnExitLeakFree();
  const {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = requireSymbols();
  const { isMainThread } = require$$2$2;
  const transport = requireTransport();
  const [nodeMajor] = process.versions.node.split(".").map((v) => Number(v));
  const asJsonChan = diagChan.tracingChannel("pino_asJson");
  const asString = nodeMajor >= 25 ? (str) => JSON.stringify(str) : _asString;
  function noop2() {
  }
  function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format2(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === void 0 ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format2(msg, n, this[formatOptsSym]), level);
      }
    }
  }
  function _asString(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0; i < l && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time2) {
    if (asJsonChan.hasSubscribers === false) {
      return _asJson.call(this, obj, msg, num, time2);
    }
    const store = { instance: this, arguments };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time2);
  }
  function _asJson(obj, msg, num, time2) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time2;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
        }
        if (value === void 0) continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== void 0) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        // this case explicitly falls through to the next one
        case "boolean":
          if (stringifier) value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify2)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid2 = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value !== void 0;
      if (valid2 === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
        if (value === void 0) continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
  }
  function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err2) {
      if (err2.code === "EPIPE") {
        stream.write = noop2;
        stream.end = noop2;
        stream.flushSync = noop2;
        stream.destroy = noop2;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err2);
    }
  }
  function autoEnd(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller2, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller: caller2, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false) opts.level = "silent";
      if (!onChild) opts.onChild = noop2;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  }
  function stringify(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log2) {
    return {
      level,
      bindings,
      log: log2
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === void 0) {
      return 1;
    }
    return destination;
  }
  tools = {
    noop: noop2,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
  return tools;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  const SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  constants$1 = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
  return constants$1;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = requireSymbols();
  const { noop: noop2, genLog } = requireTools();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$1();
  const levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
    o[DEFAULT_LEVELS[k]] = k;
    return o;
  }, {});
  const initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values: values2 } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === void 0) throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values2[level] === void 0) throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values2[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values2) {
      if (levelComparison(values2[key], levelVal) === false) {
        this[key] = noop2;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values2[key], hook);
    }
    this.emit(
      "level-change",
      level,
      levelVal,
      labels[preLevelVal],
      preLevelVal,
      this
    );
  }
  function getLevel(level) {
    const { levels: levels2, levelVal } = this;
    return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values: values2 } = this.levels;
    const logLevelVal = values2[logLevel];
    return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      useOnlyCustomLevels ? null : nums,
      customNums
    );
    const values2 = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    return { labels, values: values2 };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values2 = [].concat(
        Object.keys(customLevels || {}).map((key) => customLevels[key]),
        useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
        Infinity
      );
      if (!values2.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels2, customLevels) {
    const { labels, values: values2 } = levels2;
    for (const k in customLevels) {
      if (k in values2) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  levels = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
  return levels;
}
var meta;
var hasRequiredMeta;
function requireMeta() {
  if (hasRequiredMeta) return meta;
  hasRequiredMeta = 1;
  meta = { version: "10.3.1" };
  return meta;
}
var proto;
var hasRequiredProto;
function requireProto() {
  if (hasRequiredProto) return proto;
  hasRequiredProto = 1;
  const { EventEmitter } = require$$0$2;
  const {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = requireSymbols();
  const {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = requireLevels();
  const {
    asChindings,
    asJson,
    buildFormatters,
    stringify,
    noop: noop2
  } = requireTools();
  const {
    version: version2
  } = requireMeta();
  const redaction = requireRedaction();
  const constructor = class Pino {
  };
  const prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version2,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    get msgPrefix() {
      return this[msgPrefixSym];
    },
    get [Symbol.toStringTag]() {
      return "Pino";
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  proto = function() {
    return Object.create(prototype);
  };
  const resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options == null) {
      if (instance[formattersSym].bindings !== resetChildingsFormatter) {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      if (this.onChild !== noop2) {
        this.onChild(instance);
      }
      return instance;
    }
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = /* @__PURE__ */ Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0; i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0; bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log: log2 } = options.formatters;
      instance[formattersSym] = buildFormatters(
        level || formatters.level,
        chindings || resetChildingsFormatter,
        log2 || formatters.log
      );
    } else {
      instance[formattersSym] = buildFormatters(
        formatters.level,
        resetChildingsFormatter,
        formatters.log
      );
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    if (options.level !== void 0 && options.level !== this.level || options.hasOwnProperty("customLevels")) {
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
    }
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === void 0 || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === void 0) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop2);
    } else if (cb) cb();
  }
  return proto;
}
var safeStableStringify = { exports: {} };
var hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
  if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
  hasRequiredSafeStableStringify = 1;
  (function(module, exports$1) {
    const { hasOwnProperty } = Object.prototype;
    const stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports$1.stringify = stringify;
    exports$1.configure = configure;
    module.exports = stringify;
    const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array2, comparator2) {
      if (array2.length > 200 || comparator2) {
        return array2.sort(comparator2);
      }
      for (let i = 1; i < array2.length; i++) {
        const currentValue = array2[i];
        let position = i;
        while (position !== 0 && array2[position - 1] > currentValue) {
          array2[position] = array2[position - 1];
          position--;
        }
        array2[position] = currentValue;
      }
      return array2;
    }
    const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array2, separator, maximumBreadth) {
      if (array2.length < maximumBreadth) {
        maximumBreadth = array2.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res2 = `"0":${whitespace}${array2[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res2 += `${separator}"${i}":${whitespace}${array2[i]}`;
      }
      return res2;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number2) {
      if (number2 === 1) {
        return "1 item";
      }
      return `${number2} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator2 = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res2 = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res3 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res3 += tmp2 !== void 0 ? tmp2 : "null";
                res3 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res3 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res3 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res3 += `
${originalIndentation}`;
              stack.pop();
              return `[${res3}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res2 = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  })(safeStableStringify, safeStableStringify.exports);
  return safeStableStringify.exports;
}
var multistream_1;
var hasRequiredMultistream;
function requireMultistream() {
  if (hasRequiredMultistream) return multistream_1;
  hasRequiredMultistream = 1;
  const metadata2 = /* @__PURE__ */ Symbol.for("pino.metadata");
  const { DEFAULT_LEVELS } = requireConstants$1();
  const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res2 = {
      write,
      add,
      remove,
      emit,
      flushSync,
      end,
      minLevel: 0,
      lastId: 0,
      streams: [],
      clone: clone2,
      [metadata2]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res2);
    } else {
      add.call(res2, streamsArray);
    }
    streamsArray = null;
    return res2;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata2]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream } of this.streams) {
        if (typeof stream.emit === "function") {
          stream.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res2;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: void 0,
        id: ++res2.lastId
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res2;
    }
    function remove(id2) {
      const { streams } = this;
      const index = streams.findIndex((s) => s.id === id2);
      if (index >= 0) {
        streams.splice(index, 1);
        streams.sort(compareByLevel);
        this.minLevel = streams.length > 0 ? streams[0].level : -1;
      }
      return res2;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone2(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0; i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        remove,
        minLevel: level,
        streams,
        clone: clone2,
        emit,
        flushSync,
        [metadata2]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  multistream_1 = multistream;
  return multistream_1;
}
var hasRequiredPino;
function requirePino() {
  if (hasRequiredPino) return pino.exports;
  hasRequiredPino = 1;
  const os = require$$4;
  const stdSerializers = requirePinoStdSerializers();
  const caller2 = requireCaller();
  const redaction = requireRedaction();
  const time2 = requireTime();
  const proto2 = requireProto();
  const symbols2 = requireSymbols();
  const { configure } = requireSafeStableStringify();
  const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$1();
  const {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop: noop2
  } = requireTools();
  const { version: version2 } = requireMeta();
  const {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols2;
  const { epochTime, nullTime } = time2;
  const { pid } = process;
  const hostname = os.hostname();
  const defaultErrorSerializer = stdSerializers.err;
  const defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number2) {
        return { level: number2 };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: epochTime,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  const normalize = createArgsNormalizer(defaultOptions);
  const serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
  function pino$1(...args) {
    const instance = {};
    const { opts, stream } = normalize(instance, caller2(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
    const {
      redact: redact2,
      crlf,
      serializers: serializers2,
      timestamp: timestamp2,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks: hooks2,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(
      formatters.level,
      formatters.bindings,
      formatters.log
    );
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact2 ? redaction(redact2, stringifyFn) : {};
    const formatOpts = redact2 ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === void 0) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time3 = timestamp2 instanceof Function ? timestamp2 : timestamp2 ? epochTime : nullTime;
    const timeSliceIndex = time3().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels2 = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === "function") {
      stream.emit("message", { code: "PINO_CONFIG", config: { levels: levels2, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels: levels2,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time3,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      // protect against injection
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks2,
      silent: noop2,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto2());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  pino.exports = pino$1;
  pino.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  pino.exports.transport = requireTransport();
  pino.exports.multistream = requireMultistream();
  pino.exports.levels = mappings();
  pino.exports.stdSerializers = serializers;
  pino.exports.stdTimeFunctions = Object.assign({}, time2);
  pino.exports.symbols = symbols2;
  pino.exports.version = version2;
  pino.exports.default = pino$1;
  pino.exports.pino = pino$1;
  return pino.exports;
}
var loggerPino;
var hasRequiredLoggerPino;
function requireLoggerPino() {
  if (hasRequiredLoggerPino) return loggerPino;
  hasRequiredLoggerPino = 1;
  const pino2 = requirePino();
  const { serializersSym } = pino2.symbols;
  const {
    FST_ERR_LOG_INVALID_DESTINATION
  } = requireErrors$2();
  function createPinoLogger(opts) {
    if (opts.stream && opts.file) {
      throw new FST_ERR_LOG_INVALID_DESTINATION();
    } else if (opts.file) {
      opts.stream = pino2.destination(opts.file);
      delete opts.file;
    }
    const prevLogger = opts.logger;
    const prevGenReqId = opts.genReqId;
    let logger = null;
    if (prevLogger) {
      opts.logger = void 0;
      opts.genReqId = void 0;
      if (prevLogger[serializersSym]) {
        opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
      }
      logger = prevLogger.child({}, opts);
      opts.logger = prevLogger;
      opts.genReqId = prevGenReqId;
    } else {
      logger = pino2(opts, opts.stream);
    }
    return logger;
  }
  const serializers = {
    req: function asReqValue(req2) {
      return {
        method: req2.method,
        url: req2.url,
        version: req2.headers && req2.headers["accept-version"],
        host: req2.host,
        remoteAddress: req2.ip,
        remotePort: req2.socket ? req2.socket.remotePort : void 0
      };
    },
    err: pino2.stdSerializers.err,
    res: function asResValue(reply2) {
      return {
        statusCode: reply2.statusCode
      };
    }
  };
  loggerPino = {
    serializers,
    createPinoLogger
  };
  return loggerPino;
}
var loggerFactory;
var hasRequiredLoggerFactory;
function requireLoggerFactory() {
  if (hasRequiredLoggerFactory) return loggerFactory;
  hasRequiredLoggerFactory = 1;
  const {
    FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
    FST_ERR_LOG_INVALID_LOGGER_CONFIG,
    FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
    FST_ERR_LOG_INVALID_LOGGER
  } = requireErrors$2();
  function createChildLogger(context2, logger, req2, reqId, loggerOpts) {
    const loggerBindings = {
      [context2.requestIdLogLabel]: reqId
    };
    const child = context2.childLoggerFactory.call(context2.server, logger, loggerBindings, loggerOpts || {}, req2);
    if (context2.childLoggerFactory !== defaultChildLoggerFactory) {
      validateLogger(child, true);
    }
    return child;
  }
  function defaultChildLoggerFactory(logger, bindings, opts) {
    return logger.child(bindings, opts);
  }
  function validateLogger(logger, strict) {
    const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
    const missingMethods = logger ? methods.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods;
    if (!missingMethods.length) {
      return true;
    } else if (missingMethods.length === methods.length && !strict) {
      return false;
    } else {
      throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
    }
  }
  function createLogger(options) {
    if (options.logger && options.loggerInstance) {
      throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED();
    }
    if (!options.loggerInstance && !options.logger) {
      const nullLogger = requireAbstractLogging();
      const logger2 = nullLogger;
      logger2.child = () => logger2;
      return { logger: logger2, hasLogger: false };
    }
    const { createPinoLogger, serializers } = requireLoggerPino();
    if (validateLogger(options.loggerInstance)) {
      const logger2 = createPinoLogger({
        logger: options.loggerInstance,
        serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
      });
      return { logger: logger2, hasLogger: true };
    }
    if (validateLogger(options.logger)) {
      throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
    }
    if (options.loggerInstance) {
      throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
    }
    const localLoggerOptions = {};
    if (Object.prototype.toString.call(options.logger) === "[object Object]") {
      Reflect.ownKeys(options.logger).forEach((prop) => {
        Object.defineProperty(localLoggerOptions, prop, {
          value: options.logger[prop],
          writable: true,
          enumerable: true,
          configurable: true
        });
      });
    }
    localLoggerOptions.level = localLoggerOptions.level || "info";
    localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
    options.logger = localLoggerOptions;
    const logger = createPinoLogger(options.logger);
    return { logger, hasLogger: true };
  }
  function now() {
    const ts = process.hrtime();
    return ts[0] * 1e3 + ts[1] / 1e6;
  }
  loggerFactory = {
    createChildLogger,
    defaultChildLoggerFactory,
    createLogger,
    validateLogger,
    now
  };
  return loggerFactory;
}
var rfdc_1;
var hasRequiredRfdc;
function requireRfdc() {
  if (hasRequiredRfdc) return rfdc_1;
  hasRequiredRfdc = 1;
  rfdc_1 = rfdc;
  function copyBuffer(cur) {
    if (cur instanceof Buffer) {
      return Buffer.from(cur);
    }
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
  }
  function rfdc(opts) {
    opts = opts || {};
    if (opts.circles) return rfdcCircles(opts);
    const constructorHandlers = /* @__PURE__ */ new Map();
    constructorHandlers.set(Date, (o) => new Date(o));
    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone2;
    function cloneArray(a, fn) {
      const keys = Object.keys(a);
      const a2 = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a2[k] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          a2[k] = fn(cur);
        }
      }
      return a2;
    }
    function clone2(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, clone2);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, clone2);
      }
      const o2 = {};
      for (const k in o) {
        if (Object.hasOwnProperty.call(o, k) === false) continue;
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, clone2);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = clone2(cur);
        }
      }
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, cloneProto);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, cloneProto);
      }
      const o2 = {};
      for (const k in o) {
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = cloneProto(cur);
        }
      }
      return o2;
    }
  }
  function rfdcCircles(opts) {
    const refs = [];
    const refsNew = [];
    const constructorHandlers = /* @__PURE__ */ new Map();
    constructorHandlers.set(Date, (o) => new Date(o));
    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone2;
    function cloneArray(a, fn) {
      const keys = Object.keys(a);
      const a2 = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a2[k] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          const index = refs.indexOf(cur);
          if (index !== -1) {
            a2[k] = refsNew[index];
          } else {
            a2[k] = fn(cur);
          }
        }
      }
      return a2;
    }
    function clone2(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, clone2);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, clone2);
      }
      const o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (const k in o) {
        if (Object.hasOwnProperty.call(o, k) === false) continue;
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, clone2);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = clone2(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, cloneProto);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, cloneProto);
      }
      const o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (const k in o) {
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = cloneProto(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
  }
  return rfdc_1;
}
var schemas;
var hasRequiredSchemas;
function requireSchemas() {
  if (hasRequiredSchemas) return schemas;
  hasRequiredSchemas = 1;
  const fastClone = requireRfdc()({ circles: false, proto: true });
  const { kSchemaVisited, kSchemaResponse } = requireSymbols$1();
  const kFluentSchema = /* @__PURE__ */ Symbol.for("fluent-schema-object");
  const {
    FST_ERR_SCH_MISSING_ID,
    FST_ERR_SCH_ALREADY_PRESENT,
    FST_ERR_SCH_DUPLICATE,
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA
  } = requireErrors$2();
  const SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
  function Schemas(initStore) {
    this.store = initStore || {};
  }
  Schemas.prototype.add = function(inputSchema) {
    const schema = fastClone(
      inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema
    );
    const id2 = schema.$id;
    if (!id2) {
      throw new FST_ERR_SCH_MISSING_ID();
    }
    if (this.store[id2]) {
      throw new FST_ERR_SCH_ALREADY_PRESENT(id2);
    }
    this.store[id2] = schema;
  };
  Schemas.prototype.getSchemas = function() {
    return Object.assign({}, this.store);
  };
  Schemas.prototype.getSchema = function(schemaId) {
    return this.store[schemaId];
  };
  function isCustomSchemaPrototype(schema) {
    return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
  }
  function normalizeSchema(routeSchemas, serverOptions) {
    if (routeSchemas[kSchemaVisited]) {
      return routeSchemas;
    }
    if (routeSchemas.query) {
      if (routeSchemas.querystring) {
        throw new FST_ERR_SCH_DUPLICATE("querystring");
      }
      routeSchemas.querystring = routeSchemas.query;
    }
    generateFluentSchema(routeSchemas);
    for (const key of SCHEMAS_SOURCE) {
      const schema = routeSchemas[key];
      if (schema && !isCustomSchemaPrototype(schema)) {
        if (key === "body" && schema.content) {
          const contentProperty = schema.content;
          const keys = Object.keys(contentProperty);
          for (let i = 0; i < keys.length; i++) {
            const contentType2 = keys[i];
            const contentSchema = contentProperty[contentType2].schema;
            if (!contentSchema) {
              throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType2);
            }
          }
          continue;
        }
      }
    }
    if (routeSchemas.response) {
      const httpCodes = Object.keys(routeSchemas.response);
      for (const code2 of httpCodes) {
        if (isCustomSchemaPrototype(routeSchemas.response[code2])) {
          continue;
        }
        const contentProperty = routeSchemas.response[code2].content;
        if (contentProperty) {
          const keys = Object.keys(contentProperty);
          for (let i = 0; i < keys.length; i++) {
            const mediaName = keys[i];
            if (!contentProperty[mediaName].schema) {
              throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
            }
          }
        }
      }
    }
    routeSchemas[kSchemaVisited] = true;
    return routeSchemas;
  }
  function generateFluentSchema(schema) {
    for (const key of SCHEMAS_SOURCE) {
      if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
        schema[key] = schema[key].valueOf();
      }
    }
    if (schema.response) {
      const httpCodes = Object.keys(schema.response);
      for (const code2 of httpCodes) {
        if (schema.response[code2].isFluentSchema || schema.response[code2][kFluentSchema]) {
          schema.response[code2] = schema.response[code2].valueOf();
        }
      }
    }
  }
  function getSchemaSerializer(context2, statusCode, contentType2) {
    const responseSchemaDef = context2[kSchemaResponse];
    if (!responseSchemaDef) {
      return false;
    }
    if (responseSchemaDef[statusCode]) {
      if (responseSchemaDef[statusCode].constructor === Object && contentType2) {
        const mediaName = contentType2.split(";", 1)[0];
        if (responseSchemaDef[statusCode][mediaName]) {
          return responseSchemaDef[statusCode][mediaName];
        }
        if (responseSchemaDef[statusCode]["*/*"]) {
          return responseSchemaDef[statusCode]["*/*"];
        }
        return false;
      }
      return responseSchemaDef[statusCode];
    }
    const fallbackStatusCode = (statusCode + "")[0] + "xx";
    if (responseSchemaDef[fallbackStatusCode]) {
      if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType2) {
        const mediaName = contentType2.split(";", 1)[0];
        if (responseSchemaDef[fallbackStatusCode][mediaName]) {
          return responseSchemaDef[fallbackStatusCode][mediaName];
        }
        if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
          return responseSchemaDef[fallbackStatusCode]["*/*"];
        }
        return false;
      }
      return responseSchemaDef[fallbackStatusCode];
    }
    if (responseSchemaDef.default) {
      if (responseSchemaDef.default.constructor === Object && contentType2) {
        const mediaName = contentType2.split(";", 1)[0];
        if (responseSchemaDef.default[mediaName]) {
          return responseSchemaDef.default[mediaName];
        }
        if (responseSchemaDef.default["*/*"]) {
          return responseSchemaDef.default["*/*"];
        }
        return false;
      }
      return responseSchemaDef.default;
    }
    return false;
  }
  schemas = {
    buildSchemas(initStore) {
      return new Schemas(initStore);
    },
    getSchemaSerializer,
    normalizeSchema
  };
  return schemas;
}
var serializer;
var hasRequiredSerializer;
function requireSerializer() {
  if (hasRequiredSerializer) return serializer;
  hasRequiredSerializer = 1;
  const STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  serializer = class Serializer {
    constructor(options) {
      switch (options && options.rounding) {
        case "floor":
          this.parseInteger = Math.floor;
          break;
        case "ceil":
          this.parseInteger = Math.ceil;
          break;
        case "round":
          this.parseInteger = Math.round;
          break;
        case "trunc":
        default:
          this.parseInteger = Math.trunc;
          break;
      }
      this._options = options;
    }
    asInteger(i) {
      if (Number.isInteger(i)) {
        return "" + i;
      } else if (typeof i === "bigint") {
        return i.toString();
      }
      const integer2 = this.parseInteger(i);
      if (integer2 === Infinity || integer2 === -Infinity || integer2 !== integer2) {
        throw new Error(`The value "${i}" cannot be converted to an integer.`);
      }
      return "" + integer2;
    }
    asNumber(i) {
      const num = Number(i);
      if (num !== num) {
        throw new Error(`The value "${i}" cannot be converted to a number.`);
      } else if (num === Infinity || num === -Infinity) {
        return "null";
      } else {
        return "" + num;
      }
    }
    asBoolean(bool) {
      return bool && "true" || "false";
    }
    asDateTime(date2) {
      if (date2 === null) return '""';
      if (date2 instanceof Date) {
        return '"' + date2.toISOString() + '"';
      }
      if (typeof date2 === "string") {
        return '"' + date2 + '"';
      }
      throw new Error(`The value "${date2}" cannot be converted to a date-time.`);
    }
    asDate(date2) {
      if (date2 === null) return '""';
      if (date2 instanceof Date) {
        return '"' + new Date(date2.getTime() - date2.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
      }
      if (typeof date2 === "string") {
        return '"' + date2 + '"';
      }
      throw new Error(`The value "${date2}" cannot be converted to a date.`);
    }
    asTime(date2) {
      if (date2 === null) return '""';
      if (date2 instanceof Date) {
        return '"' + new Date(date2.getTime() - date2.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
      }
      if (typeof date2 === "string") {
        return '"' + date2 + '"';
      }
      throw new Error(`The value "${date2}" cannot be converted to a time.`);
    }
    asString(str) {
      const len = str.length;
      if (len === 0) {
        return '""';
      } else if (len < 42) {
        let result = "";
        let last = -1;
        let point = 255;
        for (let i = 0; i < len; i++) {
          point = str.charCodeAt(i);
          if (point === 34 || // '"'
          point === 92) {
            last === -1 && (last = 0);
            result += str.slice(last, i) + "\\";
            last = i;
          } else if (point < 32 || point >= 55296 && point <= 57343) {
            return JSON.stringify(str);
          }
        }
        return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
      } else if (len < 5e3 && STR_ESCAPE.test(str) === false) {
        return '"' + str + '"';
      } else {
        return JSON.stringify(str);
      }
    }
    asUnsafeString(str) {
      return '"' + str + '"';
    }
    getState() {
      return this._options;
    }
    static restoreFromState(state) {
      return new Serializer(state);
    }
  };
  return serializer;
}
var errorSerializer;
var hasRequiredErrorSerializer;
function requireErrorSerializer() {
  if (hasRequiredErrorSerializer) return errorSerializer;
  hasRequiredErrorSerializer = 1;
  const Serializer = requireSerializer();
  const serializerState = { "mode": "standalone" };
  const serializer2 = Serializer.restoreFromState(serializerState);
  const validator2 = null;
  errorSerializer = (function anonymous(validator3, serializer3) {
    const {
      asString,
      asNumber,
      asBoolean,
      asDateTime,
      asDate,
      asTime,
      asUnsafeString
    } = serializer3;
    serializer3.asInteger.bind(serializer3);
    const JSON_STR_BEGIN_OBJECT = "{";
    const JSON_STR_END_OBJECT = "}";
    const JSON_STR_COMMA = ",";
    const JSON_STR_QUOTE = '"';
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
    function anonymous0(input) {
      const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
      if (obj === null) return JSON_STR_EMPTY_OBJECT;
      let value;
      let json = JSON_STR_BEGIN_OBJECT;
      let addComma = false;
      value = obj["statusCode"];
      if (value !== void 0) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"statusCode":';
        json += asNumber(value);
      }
      value = obj["code"];
      if (value !== void 0) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"code":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += asString(value.source);
          } else {
            json += asString(value.toString());
          }
        } else {
          json += asString(value);
        }
      }
      value = obj["error"];
      if (value !== void 0) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"error":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += asString(value.source);
          } else {
            json += asString(value.toString());
          }
        } else {
          json += asString(value);
        }
      }
      value = obj["message"];
      if (value !== void 0) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"message":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += asString(value.source);
          } else {
            json += asString(value.toString());
          }
        } else {
          json += asString(value);
        }
      }
      return json + JSON_STR_END_OBJECT;
    }
    const main = anonymous0;
    return main;
  })(validator2, serializer2);
  return errorSerializer;
}
var errorHandler;
var hasRequiredErrorHandler;
function requireErrorHandler() {
  if (hasRequiredErrorHandler) return errorHandler;
  hasRequiredErrorHandler = 1;
  const statusCodes = require$$0$3.STATUS_CODES;
  const wrapThenable = requireWrapThenable();
  const { setErrorStatusCode } = requireErrorStatus();
  const {
    kReplyHeaders,
    kReplyNextErrorHandler,
    kReplyIsRunningOnErrorHook,
    kRouteContext,
    kDisableRequestLogging
  } = requireSymbols$1();
  const {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_FAILED_ERROR_SERIALIZATION
  } = requireErrors$2();
  const { getSchemaSerializer } = requireSchemas();
  const serializeError = requireErrorSerializer();
  const rootErrorHandler = {
    func: defaultErrorHandler,
    toJSON() {
      return this.func.name.toString() + "()";
    }
  };
  function handleError(reply2, error2, cb) {
    reply2[kReplyIsRunningOnErrorHook] = false;
    const context2 = reply2[kRouteContext];
    if (reply2[kReplyNextErrorHandler] === false) {
      fallbackErrorHandler(error2, reply2, function(reply3, payload) {
        try {
          reply3.raw.writeHead(reply3.raw.statusCode, reply3[kReplyHeaders]);
        } catch (error3) {
          if (!reply3.log[kDisableRequestLogging]) {
            reply3.log.warn(
              { req: reply3.request, res: reply3, err: error3 },
              error3?.message
            );
          }
          reply3.raw.writeHead(reply3.raw.statusCode);
        }
        reply3.raw.end(payload);
      });
      return;
    }
    const errorHandler2 = reply2[kReplyNextErrorHandler] || context2.errorHandler;
    reply2[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler2);
    delete reply2[kReplyHeaders]["content-type"];
    delete reply2[kReplyHeaders]["content-length"];
    const func = errorHandler2.func;
    if (!func) {
      reply2[kReplyNextErrorHandler] = false;
      fallbackErrorHandler(error2, reply2, cb);
      return;
    }
    try {
      const result = func(error2, reply2.request, reply2);
      if (result !== void 0) {
        if (result !== null && typeof result.then === "function") {
          wrapThenable(result, reply2);
        } else {
          reply2.send(result);
        }
      }
    } catch (err2) {
      reply2.send(err2);
    }
  }
  function defaultErrorHandler(error2, request2, reply2) {
    setErrorHeaders(error2, reply2);
    setErrorStatusCode(reply2, error2);
    if (reply2.statusCode < 500) {
      if (!reply2.log[kDisableRequestLogging]) {
        reply2.log.info(
          { res: reply2, err: error2 },
          error2?.message
        );
      }
    } else {
      if (!reply2.log[kDisableRequestLogging]) {
        reply2.log.error(
          { req: request2, res: reply2, err: error2 },
          error2?.message
        );
      }
    }
    reply2.send(error2);
  }
  function fallbackErrorHandler(error2, reply2, cb) {
    const res2 = reply2.raw;
    const statusCode = reply2.statusCode;
    reply2[kReplyHeaders]["content-type"] = reply2[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
    let payload;
    try {
      const serializerFn = getSchemaSerializer(reply2[kRouteContext], statusCode, reply2[kReplyHeaders]["content-type"]);
      if (serializerFn === false) {
        payload = serializeError({
          error: statusCodes[statusCode + ""],
          code: error2.code,
          message: error2.message,
          statusCode
        });
      } else {
        payload = serializerFn(Object.create(error2, {
          error: { value: statusCodes[statusCode + ""] },
          message: { value: error2.message },
          statusCode: { value: statusCode }
        }));
      }
    } catch (err2) {
      if (!reply2.log[kDisableRequestLogging]) {
        reply2.log.error({ err: err2, statusCode: res2.statusCode }, "The serializer for the given status code failed");
      }
      reply2.code(500);
      payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err2.message, error2.message));
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
    }
    reply2[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
    cb(reply2, payload);
  }
  function buildErrorHandler(parent = rootErrorHandler, func) {
    if (!func) {
      return parent;
    }
    const errorHandler2 = Object.create(parent);
    errorHandler2.func = func;
    return errorHandler2;
  }
  function setErrorHeaders(error2, reply2) {
    const res2 = reply2.raw;
    let statusCode = res2.statusCode;
    statusCode = statusCode >= 400 ? statusCode : 500;
    if (error2 != null) {
      if (error2.headers !== void 0) {
        reply2.headers(error2.headers);
      }
      if (error2.status >= 400) {
        statusCode = error2.status;
      } else if (error2.statusCode >= 400) {
        statusCode = error2.statusCode;
      }
    }
    res2.statusCode = statusCode;
  }
  errorHandler = {
    buildErrorHandler,
    handleError
  };
  return errorHandler;
}
var decorate_1;
var hasRequiredDecorate;
function requireDecorate() {
  if (hasRequiredDecorate) return decorate_1;
  hasRequiredDecorate = 1;
  const {
    kReply,
    kRequest,
    kState,
    kHasBeenDecorated
  } = requireSymbols$1();
  const {
    FST_ERR_DEC_ALREADY_PRESENT,
    FST_ERR_DEC_MISSING_DEPENDENCY,
    FST_ERR_DEC_AFTER_START,
    FST_ERR_DEC_REFERENCE_TYPE,
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
    FST_ERR_DEC_UNDECLARED
  } = requireErrors$2();
  function decorate(instance, name, fn, dependencies2) {
    if (Object.hasOwn(instance, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    checkDependencies(instance, name, dependencies2);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else {
      instance[name] = fn;
    }
  }
  function getInstanceDecorator(name) {
    if (!checkExistence(this, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "instance");
    }
    if (typeof this[name] === "function") {
      return this[name].bind(this);
    }
    return this[name];
  }
  function decorateConstructor(konstructor, name, fn, dependencies2) {
    const instance = konstructor.prototype;
    if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    konstructor[kHasBeenDecorated] = true;
    checkDependencies(konstructor, name, dependencies2);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else if (typeof fn === "function") {
      instance[name] = fn;
    } else {
      konstructor.props.push({ key: name, value: fn });
    }
  }
  function checkReferenceType(name, fn) {
    if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
      throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
    }
  }
  function decorateFastify(name, fn, dependencies2) {
    assertNotStarted(this, name);
    decorate(this, name, fn, dependencies2);
    return this;
  }
  function checkExistence(instance, name) {
    if (name) {
      return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
    }
    return instance in this;
  }
  function hasKey(fn, name) {
    if (fn.props) {
      return fn.props.find(({ key }) => key === name);
    }
    return false;
  }
  function checkRequestExistence(name) {
    if (name && hasKey(this[kRequest], name)) return true;
    return checkExistence(this[kRequest].prototype, name);
  }
  function checkReplyExistence(name) {
    if (name && hasKey(this[kReply], name)) return true;
    return checkExistence(this[kReply].prototype, name);
  }
  function checkDependencies(instance, name, deps) {
    if (deps === void 0 || deps === null) {
      return;
    }
    if (!Array.isArray(deps)) {
      throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
    }
    for (let i = 0; i !== deps.length; ++i) {
      if (!checkExistence(instance, deps[i])) {
        throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
      }
    }
  }
  function decorateReply(name, fn, dependencies2) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kReply], name, fn, dependencies2);
    return this;
  }
  function decorateRequest(name, fn, dependencies2) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kRequest], name, fn, dependencies2);
    return this;
  }
  function assertNotStarted(instance, name) {
    if (instance[kState].started) {
      throw new FST_ERR_DEC_AFTER_START(name);
    }
  }
  decorate_1 = {
    add: decorateFastify,
    exist: checkExistence,
    existRequest: checkRequestExistence,
    existReply: checkReplyExistence,
    dependencies: checkDependencies,
    decorateReply,
    decorateRequest,
    getInstanceDecorator,
    hasKey
  };
  return decorate_1;
}
var hasRequiredReply;
function requireReply() {
  if (hasRequiredReply) return reply.exports;
  hasRequiredReply = 1;
  const eos = require$$0$6.finished;
  const {
    kFourOhFourContext,
    kReplyErrorHandlerCalled,
    kReplyHijacked,
    kReplyStartTime,
    kReplyEndTime,
    kReplySerializer,
    kReplySerializerDefault,
    kReplyIsError,
    kReplyHeaders,
    kReplyTrailers,
    kReplyHasStatusCode,
    kReplyIsRunningOnErrorHook,
    kReplyNextErrorHandler,
    kDisableRequestLogging,
    kSchemaResponse,
    kReplyCacheSerializeFns,
    kSchemaController,
    kOptions,
    kRouteContext
  } = requireSymbols$1();
  const {
    onSendHookRunner,
    onResponseHookRunner,
    preHandlerHookRunner,
    preSerializationHookRunner
  } = requireHooks();
  const internals = requireHandleRequest()[/* @__PURE__ */ Symbol.for("internals")];
  const loggerUtils = requireLoggerFactory();
  const now = loggerUtils.now;
  const { handleError } = requireErrorHandler();
  const { getSchemaSerializer } = requireSchemas();
  const CONTENT_TYPE = {
    JSON: "application/json; charset=utf-8",
    PLAIN: "text/plain; charset=utf-8",
    OCTET: "application/octet-stream"
  };
  const {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_REP_RESPONSE_BODY_CONSUMED,
    FST_ERR_REP_READABLE_STREAM_LOCKED,
    FST_ERR_REP_ALREADY_SENT,
    FST_ERR_SEND_INSIDE_ONERR,
    FST_ERR_BAD_STATUS_CODE,
    FST_ERR_BAD_TRAILER_NAME,
    FST_ERR_BAD_TRAILER_VALUE,
    FST_ERR_MISSING_SERIALIZATION_FN,
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
    FST_ERR_DEC_UNDECLARED
  } = requireErrors$2();
  const decorators = requireDecorate();
  const toString = Object.prototype.toString;
  function Reply(res2, request2, log2) {
    this.raw = res2;
    this[kReplySerializer] = null;
    this[kReplyErrorHandlerCalled] = false;
    this[kReplyIsError] = false;
    this[kReplyIsRunningOnErrorHook] = false;
    this.request = request2;
    this[kReplyHeaders] = {};
    this[kReplyTrailers] = null;
    this[kReplyHasStatusCode] = false;
    this[kReplyStartTime] = void 0;
    this.log = log2;
  }
  Reply.props = [];
  Object.defineProperties(Reply.prototype, {
    [kRouteContext]: {
      get() {
        return this.request[kRouteContext];
      }
    },
    elapsedTime: {
      get() {
        if (this[kReplyStartTime] === void 0) {
          return 0;
        }
        return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
      }
    },
    server: {
      get() {
        return this.request[kRouteContext].server;
      }
    },
    sent: {
      enumerable: true,
      get() {
        return (this[kReplyHijacked] || this.raw.writableEnded) === true;
      }
    },
    statusCode: {
      get() {
        return this.raw.statusCode;
      },
      set(value) {
        this.code(value);
      }
    },
    routeOptions: {
      get() {
        return this.request.routeOptions;
      }
    }
  });
  Reply.prototype.writeEarlyHints = function(hints, callback) {
    this.raw.writeEarlyHints(hints, callback);
    return this;
  };
  Reply.prototype.hijack = function() {
    this[kReplyHijacked] = true;
    return this;
  };
  Reply.prototype.send = function(payload) {
    if (this[kReplyIsRunningOnErrorHook]) {
      throw new FST_ERR_SEND_INSIDE_ONERR();
    }
    if (this.sent === true) {
      this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
      return this;
    }
    if (this[kReplyIsError] || payload instanceof Error) {
      this[kReplyIsError] = false;
      onErrorHook(this, payload, onSendHook);
      return this;
    }
    if (payload === void 0) {
      onSendHook(this, payload);
      return this;
    }
    const contentType2 = this.getHeader("content-type");
    const hasContentType = contentType2 !== void 0;
    if (payload !== null) {
      if (
        // node:stream
        typeof payload.pipe === "function" || // node:stream/web
        typeof payload.getReader === "function" || // Response
        toString.call(payload) === "[object Response]"
      ) {
        onSendHook(this, payload);
        return this;
      }
      if (payload.buffer instanceof ArrayBuffer) {
        if (!hasContentType) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
        }
        const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
        onSendHook(this, payloadToSend);
        return this;
      }
      if (!hasContentType && typeof payload === "string") {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
        onSendHook(this, payload);
        return this;
      }
    }
    if (this[kReplySerializer] !== null) {
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      }
      payload = this[kReplySerializer](payload);
    } else if (!hasContentType || contentType2.indexOf("json") !== -1) {
      if (!hasContentType) {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
      } else if (contentType2.indexOf("charset") === -1) {
        const customContentType = contentType2.trim();
        if (customContentType.endsWith(";")) {
          this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
        } else {
          this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
        }
      }
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      }
    }
    onSendHook(this, payload);
    return this;
  };
  Reply.prototype.getHeader = function(key) {
    key = key.toLowerCase();
    const value = this[kReplyHeaders][key];
    return value !== void 0 ? value : this.raw.getHeader(key);
  };
  Reply.prototype.getHeaders = function() {
    return {
      ...this.raw.getHeaders(),
      ...this[kReplyHeaders]
    };
  };
  Reply.prototype.hasHeader = function(key) {
    key = key.toLowerCase();
    return this[kReplyHeaders][key] !== void 0 || this.raw.hasHeader(key);
  };
  Reply.prototype.removeHeader = function(key) {
    delete this[kReplyHeaders][key.toLowerCase()];
    return this;
  };
  Reply.prototype.header = function(key, value = "") {
    key = key.toLowerCase();
    if (this[kReplyHeaders][key] && key === "set-cookie") {
      if (typeof this[kReplyHeaders][key] === "string") {
        this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
      }
      if (Array.isArray(value)) {
        Array.prototype.push.apply(this[kReplyHeaders][key], value);
      } else {
        this[kReplyHeaders][key].push(value);
      }
    } else {
      this[kReplyHeaders][key] = value;
    }
    return this;
  };
  Reply.prototype.headers = function(headers) {
    const keys = Object.keys(headers);
    for (let i = 0; i !== keys.length; ++i) {
      const key = keys[i];
      this.header(key, headers[key]);
    }
    return this;
  };
  const INVALID_TRAILERS = /* @__PURE__ */ new Set([
    "transfer-encoding",
    "content-length",
    "host",
    "cache-control",
    "max-forwards",
    "te",
    "authorization",
    "set-cookie",
    "content-encoding",
    "content-type",
    "content-range",
    "trailer"
  ]);
  Reply.prototype.trailer = function(key, fn) {
    key = key.toLowerCase();
    if (INVALID_TRAILERS.has(key)) {
      throw new FST_ERR_BAD_TRAILER_NAME(key);
    }
    if (typeof fn !== "function") {
      throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
    }
    if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
    this[kReplyTrailers][key] = fn;
    return this;
  };
  Reply.prototype.hasTrailer = function(key) {
    return this[kReplyTrailers]?.[key.toLowerCase()] !== void 0;
  };
  Reply.prototype.removeTrailer = function(key) {
    if (this[kReplyTrailers] === null) return this;
    this[kReplyTrailers][key.toLowerCase()] = void 0;
    return this;
  };
  Reply.prototype.code = function(code2) {
    const statusCode = +code2;
    if (!(statusCode >= 100 && statusCode <= 599)) {
      throw new FST_ERR_BAD_STATUS_CODE(code2 || String(code2));
    }
    this.raw.statusCode = statusCode;
    this[kReplyHasStatusCode] = true;
    return this;
  };
  Reply.prototype.status = Reply.prototype.code;
  Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType2) {
    let serialize3;
    if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
      if (typeof contentType2 === "string") {
        serialize3 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType2];
      } else {
        serialize3 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
      }
    } else if (typeof schemaOrStatus === "object") {
      serialize3 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
    }
    return serialize3;
  };
  Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType2 = null) {
    const { request: request2 } = this;
    const { method, url } = request2;
    if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
      return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
    }
    const serializerCompiler2 = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
    // nor set
    (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
    const serializeFn = serializerCompiler2({
      schema,
      method,
      url,
      httpStatus,
      contentType: contentType2
    });
    if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
      this[kRouteContext][kReplyCacheSerializeFns] = /* @__PURE__ */ new WeakMap();
    }
    this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
    return serializeFn;
  };
  Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType2) {
    const possibleContentType = httpStatus;
    let serialize3;
    httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
    contentType2 = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType2;
    if (httpStatus != null) {
      if (contentType2 != null) {
        serialize3 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType2];
      } else {
        serialize3 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
      }
      if (serialize3 == null) {
        if (contentType2) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType2);
        throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
      }
    } else {
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        serialize3 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      } else {
        serialize3 = this.compileSerializationSchema(schema, httpStatus, contentType2);
      }
    }
    return serialize3(input);
  };
  Reply.prototype.serialize = function(payload) {
    if (this[kReplySerializer] !== null) {
      return this[kReplySerializer](payload);
    } else {
      if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
        return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
      } else {
        return serialize2(this[kRouteContext], payload, this.raw.statusCode);
      }
    }
  };
  Reply.prototype.serializer = function(fn) {
    this[kReplySerializer] = fn;
    return this;
  };
  Reply.prototype.type = function(type2) {
    this[kReplyHeaders]["content-type"] = type2;
    return this;
  };
  Reply.prototype.redirect = function(url, code2) {
    if (!code2) {
      code2 = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
    }
    return this.header("location", url).code(code2).send();
  };
  Reply.prototype.callNotFound = function() {
    notFound(this);
    return this;
  };
  Reply.prototype.then = function(fulfilled, rejected) {
    if (this.sent) {
      fulfilled();
      return;
    }
    eos(this.raw, (err2) => {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        if (rejected) {
          rejected(err2);
        } else {
          this.log && this.log.warn("unhandled rejection on reply.then");
        }
      } else {
        fulfilled();
      }
    });
  };
  Reply.prototype.getDecorator = function(name) {
    if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "reply");
    }
    const decorator = this[name];
    if (typeof decorator === "function") {
      return decorator.bind(this);
    }
    return decorator;
  };
  function preSerializationHook(reply2, payload) {
    if (reply2[kRouteContext].preSerialization !== null) {
      preSerializationHookRunner(
        reply2[kRouteContext].preSerialization,
        reply2.request,
        reply2,
        payload,
        preSerializationHookEnd
      );
    } else {
      preSerializationHookEnd(null, void 0, reply2, payload);
    }
  }
  function preSerializationHookEnd(err2, _request, reply2, payload) {
    if (err2 != null) {
      onErrorHook(reply2, err2);
      return;
    }
    try {
      if (reply2[kReplySerializer] !== null) {
        payload = reply2[kReplySerializer](payload);
      } else if (reply2[kRouteContext] && reply2[kRouteContext][kReplySerializerDefault]) {
        payload = reply2[kRouteContext][kReplySerializerDefault](payload, reply2.raw.statusCode);
      } else {
        payload = serialize2(reply2[kRouteContext], payload, reply2.raw.statusCode, reply2[kReplyHeaders]["content-type"]);
      }
    } catch (e) {
      wrapSerializationError(e, reply2);
      onErrorHook(reply2, e);
      return;
    }
    onSendHook(reply2, payload);
  }
  function wrapSerializationError(error2, reply2) {
    error2.serialization = reply2[kRouteContext].config;
  }
  function onSendHook(reply2, payload) {
    if (reply2[kRouteContext].onSend !== null) {
      onSendHookRunner(
        reply2[kRouteContext].onSend,
        reply2.request,
        reply2,
        payload,
        wrapOnSendEnd
      );
    } else {
      onSendEnd(reply2, payload);
    }
  }
  function wrapOnSendEnd(err2, request2, reply2, payload) {
    if (err2 != null) {
      onErrorHook(reply2, err2);
    } else {
      onSendEnd(reply2, payload);
    }
  }
  function safeWriteHead(reply2, statusCode) {
    const res2 = reply2.raw;
    try {
      res2.writeHead(statusCode, reply2[kReplyHeaders]);
    } catch (err2) {
      if (err2.code === "ERR_HTTP_HEADERS_SENT") {
        reply2.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply2.request.raw.url}" (${reply2.request.raw.method}) route?`);
      }
      throw err2;
    }
  }
  function onSendEnd(reply2, payload) {
    const res2 = reply2.raw;
    const req2 = reply2.request;
    if (reply2[kReplyTrailers] !== null) {
      const trailerHeaders = Object.keys(reply2[kReplyTrailers]);
      let header = "";
      for (const trailerName of trailerHeaders) {
        if (typeof reply2[kReplyTrailers][trailerName] !== "function") continue;
        header += " ";
        header += trailerName;
      }
      reply2.header("Transfer-Encoding", "chunked");
      reply2.header("Trailer", header.trim());
    }
    if (toString.call(payload) === "[object Response]") {
      if (typeof payload.status === "number") {
        reply2.code(payload.status);
      }
      if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
        for (const [headerName, headerValue] of payload.headers) {
          reply2.header(headerName, headerValue);
        }
      }
      if (payload.body !== null) {
        if (payload.bodyUsed) {
          throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED();
        }
      }
      payload = payload.body;
    }
    const statusCode = res2.statusCode;
    if (payload === void 0 || payload === null) {
      if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req2.method !== "HEAD" && reply2[kReplyTrailers] === null) {
        reply2[kReplyHeaders]["content-length"] = "0";
      }
      safeWriteHead(reply2, statusCode);
      sendTrailer(payload, res2, reply2);
      return;
    }
    if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
      reply2.removeHeader("content-type");
      reply2.removeHeader("content-length");
      safeWriteHead(reply2, statusCode);
      sendTrailer(void 0, res2, reply2);
      if (typeof payload.resume === "function") {
        payload.on("error", noop2);
        payload.resume();
      }
      return;
    }
    if (typeof payload.pipe === "function") {
      sendStream(payload, res2, reply2);
      return;
    }
    if (typeof payload.getReader === "function") {
      sendWebStream(payload, res2, reply2);
      return;
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
    }
    if (reply2[kReplyTrailers] === null) {
      const contentLength = reply2[kReplyHeaders]["content-length"];
      if (!contentLength || req2.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
        reply2[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      }
    }
    safeWriteHead(reply2, statusCode);
    res2.write(payload);
    sendTrailer(payload, res2, reply2);
  }
  function logStreamError(logger, err2, res2) {
    if (err2.code === "ERR_STREAM_PREMATURE_CLOSE") {
      if (!logger[kDisableRequestLogging]) {
        logger.info({ res: res2 }, "stream closed prematurely");
      }
    } else {
      logger.warn({ err: err2 }, "response terminated with an error with headers already sent");
    }
  }
  function sendWebStream(payload, res2, reply2) {
    if (payload.locked) {
      throw new FST_ERR_REP_READABLE_STREAM_LOCKED();
    }
    let sourceOpen = true;
    let errorLogged = false;
    let waitingDrain = false;
    const reader = payload.getReader();
    eos(res2, function(err2) {
      if (sourceOpen) {
        if (err2 != null && res2.headersSent && !errorLogged) {
          errorLogged = true;
          logStreamError(reply2.log, err2, res2);
        }
        reader.cancel().catch(noop2);
      }
    });
    if (!res2.headersSent) {
      for (const key in reply2[kReplyHeaders]) {
        res2.setHeader(key, reply2[kReplyHeaders][key]);
      }
    } else {
      reply2.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
    }
    function onRead(result) {
      if (result.done) {
        sourceOpen = false;
        sendTrailer(null, res2, reply2);
        return;
      }
      if (res2.destroyed) {
        sourceOpen = false;
        reader.cancel().catch(noop2);
        return;
      }
      const shouldContinue = res2.write(result.value);
      if (shouldContinue === false) {
        waitingDrain = true;
        res2.once("drain", onDrain);
        return;
      }
      reader.read().then(onRead, onReadError);
    }
    function onDrain() {
      if (!waitingDrain || !sourceOpen || res2.destroyed) {
        return;
      }
      waitingDrain = false;
      reader.read().then(onRead, onReadError);
    }
    function onReadError(err2) {
      sourceOpen = false;
      if (res2.headersSent || reply2.request.raw.aborted === true) {
        if (!errorLogged) {
          errorLogged = true;
          logStreamError(reply2.log, err2, reply2);
        }
        res2.destroy();
      } else {
        onErrorHook(reply2, err2);
      }
    }
    reader.read().then(onRead, onReadError);
  }
  function sendStream(payload, res2, reply2) {
    let sourceOpen = true;
    let errorLogged = false;
    sendStreamTrailer(payload, res2, reply2);
    eos(payload, { readable: true, writable: false }, function(err2) {
      sourceOpen = false;
      if (err2 != null) {
        if (res2.headersSent || reply2.request.raw.aborted === true) {
          if (!errorLogged) {
            errorLogged = true;
            logStreamError(reply2.log, err2, reply2);
          }
          res2.destroy();
        } else {
          onErrorHook(reply2, err2);
        }
      }
    });
    eos(res2, function(err2) {
      if (sourceOpen) {
        if (err2 != null && res2.headersSent && !errorLogged) {
          errorLogged = true;
          logStreamError(reply2.log, err2, res2);
        }
        if (typeof payload.destroy === "function") {
          payload.destroy();
        } else if (typeof payload.close === "function") {
          payload.close(noop2);
        } else if (typeof payload.abort === "function") {
          payload.abort();
        } else {
          reply2.log.warn("stream payload does not end properly");
        }
      }
    });
    if (!res2.headersSent) {
      for (const key in reply2[kReplyHeaders]) {
        res2.setHeader(key, reply2[kReplyHeaders][key]);
      }
    } else {
      reply2.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
    }
    payload.pipe(res2);
  }
  function sendTrailer(payload, res2, reply2) {
    if (reply2[kReplyTrailers] === null) {
      res2.end(null, null, null);
      return;
    }
    const trailerHeaders = Object.keys(reply2[kReplyTrailers]);
    const trailers = {};
    let handled = 0;
    let skipped = true;
    function send() {
      if (handled === 0) {
        res2.addTrailers(trailers);
        res2.end(null, null, null);
      }
    }
    for (const trailerName of trailerHeaders) {
      let cb = function(err2, value) {
        handled++;
        if (err2) reply2.log.debug(err2);
        else trailers[trailerName] = value;
        process.nextTick(send);
      };
      if (typeof reply2[kReplyTrailers][trailerName] !== "function") continue;
      skipped = false;
      handled--;
      const result = reply2[kReplyTrailers][trailerName](reply2, payload, cb);
      if (typeof result === "object" && typeof result.then === "function") {
        result.then((v) => cb(null, v), cb);
      }
    }
    if (skipped) res2.end(null, null, null);
  }
  function sendStreamTrailer(payload, res2, reply2) {
    if (reply2[kReplyTrailers] === null) return;
    payload.on("end", () => sendTrailer(null, res2, reply2));
  }
  function onErrorHook(reply2, error2, cb) {
    if (reply2[kRouteContext].onError !== null && !reply2[kReplyNextErrorHandler]) {
      reply2[kReplyIsRunningOnErrorHook] = true;
      onSendHookRunner(
        reply2[kRouteContext].onError,
        reply2.request,
        reply2,
        error2,
        () => handleError(reply2, error2, cb)
      );
    } else {
      handleError(reply2, error2, cb);
    }
  }
  function setupResponseListeners(reply2) {
    reply2[kReplyStartTime] = now();
    const onResFinished = (err2) => {
      reply2[kReplyEndTime] = now();
      reply2.raw.removeListener("finish", onResFinished);
      reply2.raw.removeListener("error", onResFinished);
      const ctx = reply2[kRouteContext];
      if (ctx && ctx.onResponse !== null) {
        onResponseHookRunner(
          ctx.onResponse,
          reply2.request,
          reply2,
          onResponseCallback
        );
      } else {
        onResponseCallback(err2, reply2.request, reply2);
      }
    };
    reply2.raw.on("finish", onResFinished);
    reply2.raw.on("error", onResFinished);
  }
  function onResponseCallback(err2, request2, reply2) {
    if (reply2.log[kDisableRequestLogging]) {
      return;
    }
    const responseTime = reply2.elapsedTime;
    if (err2 != null) {
      reply2.log.error({
        res: reply2,
        err: err2,
        responseTime
      }, "request errored");
      return;
    }
    reply2.log.info({
      res: reply2,
      responseTime
    }, "request completed");
  }
  function buildReply(R) {
    const props = R.props.slice();
    function _Reply(res2, request2, log2) {
      this.raw = res2;
      this[kReplyIsError] = false;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyHijacked] = false;
      this[kReplySerializer] = null;
      this.request = request2;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyStartTime] = void 0;
      this[kReplyEndTime] = void 0;
      this.log = log2;
      let prop;
      for (let i = 0; i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Reply.prototype, R.prototype);
    Object.setPrototypeOf(_Reply, R);
    _Reply.parent = R;
    _Reply.props = props;
    return _Reply;
  }
  function notFound(reply2) {
    if (reply2[kRouteContext][kFourOhFourContext] === null) {
      reply2.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
      reply2.code(404).send("404 Not Found");
      return;
    }
    reply2.request[kRouteContext] = reply2[kRouteContext][kFourOhFourContext];
    if (reply2[kRouteContext].preHandler !== null) {
      preHandlerHookRunner(
        reply2[kRouteContext].preHandler,
        reply2.request,
        reply2,
        internals.preHandlerCallback
      );
    } else {
      internals.preHandlerCallback(null, reply2.request, reply2);
    }
  }
  function serialize2(context2, data, statusCode, contentType2) {
    const fnSerialize = getSchemaSerializer(context2, statusCode, contentType2);
    if (fnSerialize) {
      return fnSerialize(data);
    }
    return JSON.stringify(data);
  }
  function noop2() {
  }
  reply.exports = Reply;
  reply.exports.buildReply = buildReply;
  reply.exports.setupResponseListeners = setupResponseListeners;
  return reply.exports;
}
var request$1 = { exports: {} };
var proxyAddr = { exports: {} };
var forwarded = { exports: {} };
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded) return forwarded.exports;
  hasRequiredForwarded = 1;
  function forwarded$1(req2) {
    if (!req2) {
      throw new TypeError("argument req is required");
    }
    const header = req2.headers["x-forwarded-for"];
    const socketAddr = req2.socket.remoteAddress;
    if (!header || typeof header !== "string") {
      return [socketAddr];
    } else if (header.indexOf(",") === -1) {
      const remote = header.trim();
      return remote.length ? [socketAddr, remote] : [socketAddr];
    } else {
      return parse2(header, socketAddr);
    }
  }
  function parse2(header, socketAddr) {
    const result = [socketAddr];
    let end = header.length;
    let start = end;
    let char;
    let i;
    for (i = end - 1; i >= 0; --i) {
      char = header[i];
      if (char === " ") {
        start === end && (start = end = i);
      } else if (char === ",") {
        start !== end && result.push(header.slice(start, end));
        start = end = i;
      } else {
        start = i;
      }
    }
    start !== end && result.push(header.substring(start, end));
    return result;
  }
  forwarded.exports = forwarded$1;
  forwarded.exports.default = forwarded$1;
  forwarded.exports.forwarded = forwarded$1;
  return forwarded.exports;
}
var ipaddr$1 = { exports: {} };
var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr) return ipaddr$1.exports;
  hasRequiredIpaddr = 1;
  (function(module) {
    (function(root) {
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string2, parts) {
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts = (function() {
          const ref2 = string2.split(":");
          const results = [];
          for (let i = 0; i < ref2.length; i++) {
            results.push(parseInt(ref2[i], 16));
          }
          return results;
        })();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string2) {
        if (hexRegex.test(string2)) {
          return parseInt(string2, 16);
        }
        if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
          if (octalRegex.test(string2)) {
            return parseInt(string2, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string2} as octal`);
        }
        return parseInt(string2, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr2 = {};
      ipaddr2.IPv4 = (function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ],
          // RFC7534, RFC7535
          as112: [
            [new IPv4([192, 175, 48, 0]), 24],
            [new IPv4([192, 31, 196, 0]), 24]
          ],
          // RFC7450
          amt: [
            [new IPv4([192, 52, 193, 0]), 24]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref2;
          if (cidrRange === void 0) {
            ref2 = other;
            other = ref2[0];
            cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      })();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv4.isValid = function(string2) {
        try {
          new this(this.parser(string2));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidCIDR = function(string2) {
        try {
          this.parseCIDR(string2);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.isValidCIDRFourPartDecimal = function(string2) {
        const match = string2.match(/^(.+)\/(\d+)$/);
        if (!ipaddr2.IPv4.isValidCIDR(string2) || !match) {
          return false;
        }
        return ipaddr2.IPv4.isValidFourPartDecimal(match[1]);
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string2) {
        const parts = this.parser(string2);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr2.IPv4.parseCIDR = function(string2) {
        let match;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string2) {
        let match, part, value;
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return (function() {
            const ref2 = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref2.length; i++) {
              part = ref2[i];
              results.push(parseIntAuto(part));
            }
            return results;
          })();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return (function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          })().reverse();
        } else if (match = string2.match(ipv4Regexes.twoOctet)) {
          return (function() {
            const ref2 = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref2[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref2[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          })();
        } else if (match = string2.match(ipv4Regexes.threeOctet)) {
          return (function() {
            const ref2 = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref2[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref2[0]));
            results.push(parseIntAuto(ref2[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          })();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = (function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6666
          discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC5180
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          // RFC7450
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [
            [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
            [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
          ],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
          droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
          reserved: [
            // RFC3849
            [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
            // RFC2928
            [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
          ]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref2;
          if (cidrRange === void 0) {
            ref2 = other;
            other = ref2[0];
            cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref2 = this.parts;
          for (let i = 0; i < ref2.length; i++) {
            part = ref2[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref2 = this.parts.slice(-2);
          const high = ref2[0];
          const low = ref2[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string2 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      })();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv6.isValid = function(string2) {
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.isValidCIDR = function(string2) {
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          this.parseCIDR(string2);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string2) {
        const addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string2) {
        let maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string2) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string2)) {
          return expandIPv6(string2, 8);
        }
        if (match = string2.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = match[1];
          if (!match[1].endsWith("::")) {
            addr = addr.slice(0, -1);
          }
          addr = expandIPv6(addr + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr2.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr2.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string2) {
        return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
      };
      ipaddr2.isValidCIDR = function(string2) {
        return ipaddr2.IPv6.isValidCIDR(string2) || ipaddr2.IPv4.isValidCIDR(string2);
      };
      ipaddr2.parse = function(string2) {
        if (ipaddr2.IPv6.isValid(string2)) {
          return ipaddr2.IPv6.parse(string2);
        } else if (ipaddr2.IPv4.isValid(string2)) {
          return ipaddr2.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string2) {
        try {
          return ipaddr2.IPv6.parseCIDR(string2);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string2);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string2) {
        const addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (module.exports) {
        module.exports = ipaddr2;
      } else {
        root.ipaddr = ipaddr2;
      }
    })(ipaddr);
  })(ipaddr$1);
  return ipaddr$1.exports;
}
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr) return proxyAddr.exports;
  hasRequiredProxyAddr = 1;
  proxyAddr.exports = proxyaddr;
  proxyAddr.exports.default = proxyaddr;
  proxyAddr.exports.proxyaddr = proxyaddr;
  proxyAddr.exports.all = alladdrs;
  proxyAddr.exports.compile = compile2;
  const forwarded2 = requireForwarded();
  const ipaddr2 = requireIpaddr();
  const DIGIT_REGEXP = /^\d+$/u;
  const isip = ipaddr2.isValid;
  const parseip = ipaddr2.parse;
  const IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req2, trust) {
    const addrs = forwarded2(req2);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile2(trust);
    }
    for (let i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile2(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    let trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (let i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.hasOwn(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    const rangeSubnets = new Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    const len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    const pos = note.lastIndexOf("/");
    const str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    let ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    const max = ip.kind() === "ipv6" ? 128 : 32;
    let range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range2 === null) {
      range2 = max;
    } else if (DIGIT_REGEXP.test(range2)) {
      range2 = parseInt(range2, 10);
    } else if (ip.kind() === "ipv4" && isip(range2)) {
      range2 = parseNetmask(range2);
    } else {
      range2 = null;
    }
    if (range2 <= 0 || range2 > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range2];
  }
  function parseNetmask(netmask) {
    const ip = parseip(netmask);
    const kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req2, trust) {
    if (!req2) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    const addrs = alladdrs(req2, trust);
    return addrs[addrs.length - 1];
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;
      const ip = parseip(addr);
      let ipconv;
      const kind = ip.kind();
      for (let i = 0; i < subnets.length; i++) {
        const subnet = subnets[i];
        const subnetip = subnet[0];
        const subnetkind = subnetip.kind();
        const subnetrange = subnet[1];
        let trusted = ip;
        if (kind !== subnetkind) {
          const subnetisipv4 = subnetkind === "ipv4";
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    const subnetip = subnet[0];
    const subnetkind = subnetip.kind();
    const subnetisipv4 = subnetkind === "ipv4";
    const subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr)) return false;
      let ip = parseip(addr);
      const kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr.exports;
}
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request$1.exports;
  hasRequiredRequest$1 = 1;
  const proxyAddr2 = requireProxyAddr();
  const {
    kHasBeenDecorated,
    kSchemaBody,
    kSchemaHeaders,
    kSchemaParams,
    kSchemaQuerystring,
    kSchemaController,
    kOptions,
    kRequestCacheValidateFns,
    kRouteContext,
    kRequestOriginalUrl
  } = requireSymbols$1();
  const { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = requireErrors$2();
  const decorators = requireDecorate();
  const HTTP_PART_SYMBOL_MAP = {
    body: kSchemaBody,
    headers: kSchemaHeaders,
    params: kSchemaParams,
    querystring: kSchemaQuerystring,
    query: kSchemaQuerystring
  };
  function Request(id2, params, req2, query, log2, context2) {
    this.id = id2;
    this[kRouteContext] = context2;
    this.params = params;
    this.raw = req2;
    this.query = query;
    this.log = log2;
    this.body = void 0;
  }
  Request.props = [];
  function getTrustProxyFn(tp) {
    if (typeof tp === "function") {
      return tp;
    }
    if (tp === true) {
      return null;
    }
    if (typeof tp === "number") {
      return function(a, i) {
        return i < tp;
      };
    }
    if (typeof tp === "string") {
      const values2 = tp.split(",").map((it) => it.trim());
      return proxyAddr2.compile(values2);
    }
    return proxyAddr2.compile(tp);
  }
  function buildRequest(R, trustProxy) {
    if (trustProxy) {
      return buildRequestWithTrustProxy(R, trustProxy);
    }
    return buildRegularRequest(R);
  }
  function buildRegularRequest(R) {
    const props = R.props.slice();
    function _Request(id2, params, req2, query, log2, context2) {
      this.id = id2;
      this[kRouteContext] = context2;
      this.params = params;
      this.raw = req2;
      this.query = query;
      this.log = log2;
      this.body = void 0;
      let prop;
      for (let i = 0; i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Request.prototype, R.prototype);
    Object.setPrototypeOf(_Request, R);
    _Request.props = props;
    _Request.parent = R;
    return _Request;
  }
  function getLastEntryInMultiHeaderValue(headerValue) {
    const lastIndex = headerValue.lastIndexOf(",");
    return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
  }
  function buildRequestWithTrustProxy(R, trustProxy) {
    const _Request = buildRegularRequest(R);
    const proxyFn = getTrustProxyFn(trustProxy);
    _Request[kHasBeenDecorated] = true;
    Object.defineProperties(_Request.prototype, {
      ip: {
        get() {
          const addrs = proxyAddr2.all(this.raw, proxyFn);
          return addrs[addrs.length - 1];
        }
      },
      ips: {
        get() {
          return proxyAddr2.all(this.raw, proxyFn);
        }
      },
      host: {
        get() {
          if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
          }
          return this.headers.host ?? this.headers[":authority"] ?? "";
        }
      },
      protocol: {
        get() {
          if (this.headers["x-forwarded-proto"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
          }
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      }
    });
    return _Request;
  }
  function assertsRequestDecoration(request2, name) {
    if (!decorators.hasKey(request2, name) && !decorators.exist(request2, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "request");
    }
  }
  Object.defineProperties(Request.prototype, {
    server: {
      get() {
        return this[kRouteContext].server;
      }
    },
    url: {
      get() {
        return this.raw.url;
      }
    },
    originalUrl: {
      get() {
        if (!this[kRequestOriginalUrl]) {
          this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
        }
        return this[kRequestOriginalUrl];
      }
    },
    method: {
      get() {
        return this.raw.method;
      }
    },
    routeOptions: {
      get() {
        const context2 = this[kRouteContext];
        const routeLimit = context2._parserOptions.limit;
        const serverLimit = context2.server.initialConfig.bodyLimit;
        const version2 = context2.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0;
        const options = {
          method: context2.config?.method,
          url: context2.config?.url,
          bodyLimit: routeLimit || serverLimit,
          attachValidation: context2.attachValidation,
          logLevel: context2.logLevel,
          exposeHeadRoute: context2.exposeHeadRoute,
          prefixTrailingSlash: context2.prefixTrailingSlash,
          handler: context2.handler,
          config: context2.config,
          schema: context2.schema,
          version: version2
        };
        return options;
      }
    },
    is404: {
      get() {
        return this[kRouteContext].config?.url === void 0;
      }
    },
    socket: {
      get() {
        return this.raw.socket;
      }
    },
    ip: {
      get() {
        if (this.socket) {
          return this.socket.remoteAddress;
        }
      }
    },
    host: {
      get() {
        return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
      }
    },
    hostname: {
      get() {
        if (this.host[0] === "[") {
          return this.host.slice(0, this.host.indexOf("]") + 1);
        }
        return this.host.split(":", 1)[0];
      }
    },
    port: {
      get() {
        const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
        if (!isNaN(portFromHost)) {
          return portFromHost;
        }
        const host = this.headers.host ?? this.headers[":authority"] ?? "";
        const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
        if (!isNaN(portFromHeader)) {
          return portFromHeader;
        }
        return null;
      }
    },
    protocol: {
      get() {
        if (this.socket) {
          return this.socket.encrypted ? "https" : "http";
        }
      }
    },
    headers: {
      get() {
        if (this.additionalHeaders) {
          return Object.assign({}, this.raw.headers, this.additionalHeaders);
        }
        return this.raw.headers;
      },
      set(headers) {
        this.additionalHeaders = headers;
      }
    },
    getValidationFunction: {
      value: function(httpPartOrSchema) {
        if (typeof httpPartOrSchema === "string") {
          const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
          return this[kRouteContext][symbol];
        } else if (typeof httpPartOrSchema === "object") {
          return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
        }
      }
    },
    compileValidationSchema: {
      value: function(schema, httpPart = null) {
        const { method, url } = this;
        if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
          return this[kRouteContext][kRequestCacheValidateFns].get(schema);
        }
        const validatorCompiler2 = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
        // nor set
        (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
        const validateFn = validatorCompiler2({
          schema,
          method,
          url,
          httpPart
        });
        if (this[kRouteContext][kRequestCacheValidateFns] == null) {
          this[kRouteContext][kRequestCacheValidateFns] = /* @__PURE__ */ new WeakMap();
        }
        this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
        return validateFn;
      }
    },
    validateInput: {
      value: function(input, schema, httpPart) {
        httpPart = typeof schema === "string" ? schema : httpPart;
        const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
        let validate2;
        if (symbol) {
          validate2 = this[kRouteContext][symbol];
        }
        if (validate2 == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
          throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
        }
        if (validate2 == null) {
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            validate2 = this[kRouteContext][kRequestCacheValidateFns].get(schema);
          } else {
            validate2 = this.compileValidationSchema(schema, httpPart);
          }
        }
        return validate2(input);
      }
    },
    getDecorator: {
      value: function(name) {
        assertsRequestDecoration(this, name);
        const decorator = this[name];
        if (typeof decorator === "function") {
          return decorator.bind(this);
        }
        return decorator;
      }
    },
    setDecorator: {
      value: function(name, value) {
        assertsRequestDecoration(this, name);
        this[name] = value;
      }
    }
  });
  request$1.exports = Request;
  request$1.exports.buildRequest = buildRequest;
  return request$1.exports;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  const {
    kFourOhFourContext,
    kReplySerializerDefault,
    kSchemaErrorFormatter,
    kErrorHandler,
    kChildLoggerFactory,
    kOptions,
    kReply,
    kRequest,
    kBodyLimit,
    kLogLevel,
    kContentTypeParser,
    kRouteByFastify,
    kRequestCacheValidateFns,
    kReplyCacheSerializeFns
  } = requireSymbols$1();
  function Context({
    schema,
    handler,
    config: config2,
    requestIdLogLabel,
    childLoggerFactory,
    errorHandler: errorHandler2,
    bodyLimit,
    logLevel,
    logSerializers,
    attachValidation,
    validatorCompiler: validatorCompiler2,
    serializerCompiler: serializerCompiler2,
    replySerializer,
    schemaErrorFormatter,
    exposeHeadRoute,
    prefixTrailingSlash,
    server: server2,
    isFastify
  }) {
    this.schema = schema;
    this.handler = handler;
    this.Reply = server2[kReply];
    this.Request = server2[kRequest];
    this.contentTypeParser = server2[kContentTypeParser];
    this.onRequest = null;
    this.onSend = null;
    this.onError = null;
    this.onTimeout = null;
    this.preHandler = null;
    this.onResponse = null;
    this.preSerialization = null;
    this.onRequestAbort = null;
    this.config = config2;
    this.errorHandler = errorHandler2 || server2[kErrorHandler];
    this.requestIdLogLabel = requestIdLogLabel || server2[kOptions].requestIdLogLabel;
    this.childLoggerFactory = childLoggerFactory || server2[kChildLoggerFactory];
    this._middie = null;
    this._parserOptions = {
      limit: bodyLimit || server2[kBodyLimit]
    };
    this.exposeHeadRoute = exposeHeadRoute;
    this.prefixTrailingSlash = prefixTrailingSlash;
    this.logLevel = logLevel || server2[kLogLevel];
    this.logSerializers = logSerializers;
    this[kFourOhFourContext] = null;
    this.attachValidation = attachValidation;
    this[kReplySerializerDefault] = replySerializer;
    this.schemaErrorFormatter = schemaErrorFormatter || server2[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
    this[kRouteByFastify] = isFastify;
    this[kRequestCacheValidateFns] = null;
    this[kReplyCacheSerializeFns] = null;
    this.validatorCompiler = validatorCompiler2 || null;
    this.serializerCompiler = serializerCompiler2 || null;
    this.server = server2;
  }
  function defaultSchemaErrorFormatter(errors2, dataVar) {
    let text = "";
    const separator = ", ";
    for (let i = 0; i !== errors2.length; ++i) {
      const e = errors2[i];
      text += dataVar + (e.instancePath || "") + " " + e.message + separator;
    }
    return new Error(text.slice(0, -separator.length));
  }
  context = Context;
  return context;
}
var contentTypeParser = { exports: {} };
var toadCache = {};
var hasRequiredToadCache;
function requireToadCache() {
  if (hasRequiredToadCache) return toadCache;
  hasRequiredToadCache = 1;
  class FifoMap {
    constructor(max = 1e3, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = /* @__PURE__ */ new Map();
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    clear() {
      this.items = /* @__PURE__ */ new Map();
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const deletedItem = this.items.get(key);
        this.items.delete(key);
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0; i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  class LruMap {
    constructor(max = 1e3, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = /* @__PURE__ */ new Map();
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = /* @__PURE__ */ new Map();
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        this.items.delete(key);
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0; i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  class LruObject {
    constructor(max = 1e3, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = /* @__PURE__ */ Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = /* @__PURE__ */ Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        delete this.items[key];
        this.size--;
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0; i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  class HitStatisticsRecord {
    constructor() {
      this.records = {};
    }
    initForCache(cacheId, currentTimeStamp) {
      this.records[cacheId] = {
        [currentTimeStamp]: {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        }
      };
    }
    resetForCache(cacheId) {
      for (let key of Object.keys(this.records[cacheId])) {
        this.records[cacheId][key] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        };
      }
    }
    getStatistics() {
      return this.records;
    }
  }
  function getTimestamp(date2) {
    return `${date2.getFullYear()}-${(date2.getMonth() + 1).toString().padStart(2, "0")}-${date2.getDate().toString().padStart(2, "0")}`;
  }
  class HitStatistics {
    constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
      this.cacheId = cacheId;
      this.statisticTtlInHours = statisticTtlInHours;
      this.collectionStart = /* @__PURE__ */ new Date();
      this.currentTimeStamp = getTimestamp(this.collectionStart);
      this.records = globalStatisticsRecord || new HitStatisticsRecord();
      this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
    get currentRecord() {
      if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
        this.records.records[this.cacheId][this.currentTimeStamp] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          sets: 0,
          invalidateOne: 0,
          invalidateAll: 0
        };
      }
      return this.records.records[this.cacheId][this.currentTimeStamp];
    }
    hoursPassed() {
      return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
    }
    addHit() {
      this.archiveIfNeeded();
      this.currentRecord.hits++;
    }
    addFalsyHit() {
      this.archiveIfNeeded();
      this.currentRecord.falsyHits++;
    }
    addEmptyHit() {
      this.archiveIfNeeded();
      this.currentRecord.emptyHits++;
    }
    addMiss() {
      this.archiveIfNeeded();
      this.currentRecord.misses++;
    }
    addEviction() {
      this.archiveIfNeeded();
      this.currentRecord.evictions++;
    }
    setCacheSize(currentSize) {
      this.archiveIfNeeded();
      this.currentRecord.cacheSize = currentSize;
    }
    addExpiration() {
      this.archiveIfNeeded();
      this.currentRecord.expirations++;
    }
    addSet() {
      this.archiveIfNeeded();
      this.currentRecord.sets++;
    }
    addInvalidateOne() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateOne++;
    }
    addInvalidateAll() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateAll++;
    }
    getStatistics() {
      return this.records.getStatistics();
    }
    archiveIfNeeded() {
      if (this.hoursPassed() >= this.statisticTtlInHours) {
        this.collectionStart = /* @__PURE__ */ new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
    }
  }
  class LruObjectHitStatistics extends LruObject {
    constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
      super(max || 1e3, ttlInMsecs || 0);
      if (!cacheId) {
        throw new Error("Cache id is mandatory");
      }
      this.hitStatistics = new HitStatistics(
        cacheId,
        statisticTtlInHours !== void 0 ? statisticTtlInHours : 24,
        globalStatisticsRecord
      );
    }
    getStatistics() {
      return this.hitStatistics.getStatistics();
    }
    set(key, value) {
      super.set(key, value);
      this.hitStatistics.addSet();
      this.hitStatistics.setCacheSize(this.size);
    }
    evict() {
      super.evict();
      this.hitStatistics.addEviction();
      this.hitStatistics.setCacheSize(this.size);
    }
    delete(key, isExpiration = false) {
      super.delete(key);
      if (!isExpiration) {
        this.hitStatistics.addInvalidateOne();
      }
      this.hitStatistics.setCacheSize(this.size);
    }
    clear() {
      super.clear();
      this.hitStatistics.addInvalidateAll();
      this.hitStatistics.setCacheSize(this.size);
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key, true);
          this.hitStatistics.addExpiration();
          return;
        }
        this.bumpLru(item);
        if (!item.value) {
          this.hitStatistics.addFalsyHit();
        }
        if (item.value === void 0 || item.value === null || item.value === "") {
          this.hitStatistics.addEmptyHit();
        }
        this.hitStatistics.addHit();
        return item.value;
      }
      this.hitStatistics.addMiss();
    }
  }
  class FifoObject {
    constructor(max = 1e3, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = /* @__PURE__ */ Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    clear() {
      this.items = /* @__PURE__ */ Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const deletedItem = this.items[key];
        delete this.items[key];
        this.size--;
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0; i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  toadCache.Fifo = FifoObject;
  toadCache.FifoMap = FifoMap;
  toadCache.FifoObject = FifoObject;
  toadCache.HitStatisticsRecord = HitStatisticsRecord;
  toadCache.Lru = LruObject;
  toadCache.LruHitStatistics = LruObjectHitStatistics;
  toadCache.LruMap = LruMap;
  toadCache.LruObject = LruObject;
  toadCache.LruObjectHitStatistics = LruObjectHitStatistics;
  return toadCache;
}
var secureJsonParse = { exports: {} };
var hasRequiredSecureJsonParse;
function requireSecureJsonParse() {
  if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
  hasRequiredSecureJsonParse = 1;
  const hasBuffer = typeof Buffer !== "undefined";
  const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function _parse2(text, reviver, options) {
    if (options == null) {
      if (reviver !== null && typeof reviver === "object") {
        options = reviver;
        reviver = void 0;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
      text = text.toString();
    }
    if (text && text.charCodeAt(0) === 65279) {
      text = text.slice(1);
    }
    const obj = JSON.parse(text, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options && options.protoAction || "error";
    const constructorAction = options && options.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text) === false) {
        return obj;
      }
    }
    return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
  }
  function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node2 of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node2, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node2.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node2, "constructor") && node2.constructor !== null && typeof node2.constructor === "object" && Object.prototype.hasOwnProperty.call(node2.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node2.constructor;
        }
        for (const key in node2) {
          const value = node2[key];
          if (value && typeof value === "object") {
            next.push(value);
          }
        }
      }
    }
    return obj;
  }
  function parse2(text, reviver, options) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse2(text, reviver, options);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  function safeParse2(text, reviver) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse2(text, reviver, { safe: true });
    } catch {
      return void 0;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  secureJsonParse.exports = parse2;
  secureJsonParse.exports.default = parse2;
  secureJsonParse.exports.parse = parse2;
  secureJsonParse.exports.safeParse = safeParse2;
  secureJsonParse.exports.scan = filter;
  return secureJsonParse.exports;
}
var hasRequiredContentTypeParser;
function requireContentTypeParser() {
  if (hasRequiredContentTypeParser) return contentTypeParser.exports;
  hasRequiredContentTypeParser = 1;
  (function(module) {
    const { AsyncResource } = require$$0$7;
    const { FifoMap: Fifo } = requireToadCache();
    const { parse: secureJsonParse2 } = requireSecureJsonParse();
    const ContentType = requireContentType();
    const {
      kDefaultJsonParse,
      kContentTypeParser,
      kBodyLimit,
      kRequestPayloadStream,
      kState,
      kTestInternals,
      kReplyIsError,
      kRouteContext
    } = requireSymbols$1();
    const {
      FST_ERR_CTP_INVALID_TYPE,
      FST_ERR_CTP_EMPTY_TYPE,
      FST_ERR_CTP_ALREADY_PRESENT,
      FST_ERR_CTP_INVALID_HANDLER,
      FST_ERR_CTP_INVALID_PARSE_TYPE,
      FST_ERR_CTP_BODY_TOO_LARGE,
      FST_ERR_CTP_INVALID_MEDIA_TYPE,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH,
      FST_ERR_CTP_EMPTY_JSON_BODY,
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED,
      FST_ERR_CTP_INVALID_JSON_BODY
    } = requireErrors$2();
    const { FSTSEC001 } = requireWarnings();
    function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
      this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
      this.customParsers = /* @__PURE__ */ new Map();
      this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
      this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
      this.parserList = ["application/json", "text/plain"];
      this.parserRegExpList = [];
      this.cache = new Fifo(100);
    }
    ContentTypeParser.prototype.add = function(contentType2, opts, parserFn) {
      const contentTypeIsString = typeof contentType2 === "string";
      if (contentTypeIsString) {
        contentType2 = contentType2.trim().toLowerCase();
        if (contentType2.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
      } else if (!(contentType2 instanceof RegExp)) {
        throw new FST_ERR_CTP_INVALID_TYPE();
      }
      if (typeof parserFn !== "function") {
        throw new FST_ERR_CTP_INVALID_HANDLER();
      }
      if (this.existingParser(contentType2)) {
        throw new FST_ERR_CTP_ALREADY_PRESENT(contentType2);
      }
      if (opts.parseAs !== void 0) {
        if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
          throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
        }
      }
      const parser = new Parser(
        opts.parseAs === "string",
        opts.parseAs === "buffer",
        opts.bodyLimit,
        parserFn
      );
      if (contentType2 === "*") {
        this.customParsers.set("", parser);
      } else {
        if (contentTypeIsString) {
          const ct = new ContentType(contentType2);
          if (ct.isValid === false) {
            throw new FST_ERR_CTP_INVALID_TYPE();
          }
          const normalizedContentType = ct.toString();
          this.parserList.unshift(normalizedContentType);
          this.customParsers.set(normalizedContentType, parser);
        } else {
          validateRegExp(contentType2);
          this.parserRegExpList.unshift(contentType2);
          this.customParsers.set(contentType2.toString(), parser);
        }
      }
    };
    ContentTypeParser.prototype.hasParser = function(contentType2) {
      if (typeof contentType2 === "string") {
        contentType2 = new ContentType(contentType2).toString();
      } else {
        if (!(contentType2 instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType2 = contentType2.toString();
      }
      return this.customParsers.has(contentType2);
    };
    ContentTypeParser.prototype.existingParser = function(contentType2) {
      if (typeof contentType2 === "string") {
        const ct = new ContentType(contentType2).toString();
        if (contentType2 === "application/json" && this.customParsers.has(contentType2)) {
          return this.customParsers.get(ct).fn !== this[kDefaultJsonParse];
        }
        if (contentType2 === "text/plain" && this.customParsers.has(contentType2)) {
          return this.customParsers.get(ct).fn !== defaultPlainTextParser;
        }
      }
      return this.hasParser(contentType2);
    };
    ContentTypeParser.prototype.getParser = function(contentType2) {
      if (typeof contentType2 === "string") {
        contentType2 = new ContentType(contentType2);
      }
      const ct = contentType2.toString();
      let parser = this.cache.get(ct);
      if (parser !== void 0) return parser;
      parser = this.customParsers.get(ct);
      if (parser !== void 0) {
        this.cache.set(ct, parser);
        return parser;
      }
      parser = this.customParsers.get(contentType2.mediaType);
      if (parser !== void 0) {
        return parser;
      }
      for (let j = 0; j !== this.parserRegExpList.length; ++j) {
        const parserRegExp = this.parserRegExpList[j];
        if (parserRegExp.test(ct)) {
          parser = this.customParsers.get(parserRegExp.toString());
          this.cache.set(ct, parser);
          return parser;
        }
      }
      return this.customParsers.get("");
    };
    ContentTypeParser.prototype.removeAll = function() {
      this.customParsers = /* @__PURE__ */ new Map();
      this.parserRegExpList = [];
      this.parserList = [];
      this.cache = new Fifo(100);
    };
    ContentTypeParser.prototype.remove = function(contentType2) {
      let parsers;
      if (typeof contentType2 === "string") {
        contentType2 = new ContentType(contentType2).toString();
        parsers = this.parserList;
      } else {
        if (!(contentType2 instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType2 = contentType2.toString();
        parsers = this.parserRegExpList;
      }
      const removed = this.customParsers.delete(contentType2);
      const idx = parsers.findIndex((ct) => ct.toString() === contentType2);
      if (idx > -1) {
        parsers.splice(idx, 1);
      }
      return removed || idx > -1;
    };
    ContentTypeParser.prototype.run = function(contentType2, handler, request2, reply2) {
      const parser = this.getParser(contentType2);
      if (parser === void 0) {
        if (request2.is404 === true) {
          handler(request2, reply2);
          return;
        }
        reply2[kReplyIsError] = true;
        reply2.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType2 || void 0));
        return;
      }
      const resource = new AsyncResource("content-type-parser:run", request2);
      const done = resource.bind(onDone);
      if (parser.asString === true || parser.asBuffer === true) {
        rawBody(
          request2,
          reply2,
          reply2[kRouteContext]._parserOptions,
          parser,
          done
        );
        return;
      }
      const result = parser.fn(request2, request2[kRequestPayloadStream], done);
      if (result && typeof result.then === "function") {
        result.then((body) => {
          done(null, body);
        }, done);
      }
      function onDone(error2, body) {
        resource.emitDestroy();
        if (error2 != null) {
          reply2.header("connection", "close");
          reply2[kReplyIsError] = true;
          reply2.send(error2);
          return;
        }
        request2.body = body;
        handler(request2, reply2);
      }
    };
    function rawBody(request2, reply2, options, parser, done) {
      const asString = parser.asString === true;
      const limit2 = options.limit === null ? parser.bodyLimit : options.limit;
      const contentLength = Number(request2.headers["content-length"]);
      if (contentLength > limit2) {
        done(new FST_ERR_CTP_BODY_TOO_LARGE(), void 0);
        return;
      }
      let receivedLength = 0;
      let body = asString ? "" : [];
      const payload = request2[kRequestPayloadStream] || request2.raw;
      if (asString) {
        payload.setEncoding("utf8");
      }
      payload.on("data", onData);
      payload.on("end", onEnd);
      payload.on("error", onEnd);
      payload.resume();
      function onData(chunk) {
        receivedLength += asString ? Buffer.byteLength(chunk) : chunk.length;
        const { receivedEncodedLength = 0 } = payload;
        if (receivedLength > limit2 || receivedEncodedLength > limit2) {
          payload.removeListener("data", onData);
          payload.removeListener("end", onEnd);
          payload.removeListener("error", onEnd);
          done(new FST_ERR_CTP_BODY_TOO_LARGE(), void 0);
          return;
        }
        if (asString) {
          body += chunk;
        } else {
          body.push(chunk);
        }
      }
      function onEnd(err2) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        if (err2 != null) {
          if (!(typeof err2.statusCode === "number" && err2.statusCode >= 400)) {
            err2.statusCode = 400;
          }
          done(err2, void 0);
          return;
        }
        if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
          done(new FST_ERR_CTP_INVALID_CONTENT_LENGTH(), void 0);
          return;
        }
        if (!asString) {
          body = Buffer.concat(body);
        }
        const result = parser.fn(request2, body, done);
        if (result && typeof result.then === "function") {
          result.then((body2) => {
            done(null, body2);
          }, done);
        }
      }
    }
    function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
      const parseOptions = { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning };
      return defaultJsonParser;
      function defaultJsonParser(req2, body, done) {
        if (body.length === 0) {
          done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
          return;
        }
        try {
          done(null, secureJsonParse2(body, parseOptions));
        } catch {
          done(new FST_ERR_CTP_INVALID_JSON_BODY(), void 0);
        }
      }
    }
    function defaultPlainTextParser(req2, body, done) {
      done(null, body);
    }
    function Parser(asString, asBuffer, bodyLimit, fn) {
      this.asString = asString;
      this.asBuffer = asBuffer;
      this.bodyLimit = bodyLimit;
      this.fn = fn;
    }
    function buildContentTypeParser(c) {
      const contentTypeParser2 = new ContentTypeParser();
      contentTypeParser2[kDefaultJsonParse] = c[kDefaultJsonParse];
      contentTypeParser2.customParsers = new Map(c.customParsers.entries());
      contentTypeParser2.parserList = c.parserList.slice();
      contentTypeParser2.parserRegExpList = c.parserRegExpList.slice();
      return contentTypeParser2;
    }
    function addContentTypeParser(contentType2, opts, parser) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
      }
      if (typeof opts === "function") {
        parser = opts;
        opts = {};
      }
      if (!opts) opts = {};
      if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];
      if (Array.isArray(contentType2)) {
        contentType2.forEach((type2) => this[kContentTypeParser].add(type2, opts, parser));
      } else {
        this[kContentTypeParser].add(contentType2, opts, parser);
      }
      return this;
    }
    function hasContentTypeParser(contentType2) {
      return this[kContentTypeParser].hasParser(contentType2);
    }
    function removeContentTypeParser(contentType2) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
      }
      if (Array.isArray(contentType2)) {
        for (const type2 of contentType2) {
          this[kContentTypeParser].remove(type2);
        }
      } else {
        this[kContentTypeParser].remove(contentType2);
      }
    }
    function removeAllContentTypeParsers() {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
      }
      this[kContentTypeParser].removeAll();
    }
    function validateRegExp(regexp) {
      if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
        FSTSEC001(regexp.source);
      }
    }
    module.exports = ContentTypeParser;
    module.exports.helpers = {
      buildContentTypeParser,
      addContentTypeParser,
      hasContentTypeParser,
      removeContentTypeParser,
      removeAllContentTypeParsers
    };
    module.exports.defaultParsers = {
      getDefaultJsonParser,
      defaultTextParser: defaultPlainTextParser
    };
    module.exports[kTestInternals] = { rawBody };
  })(contentTypeParser);
  return contentTypeParser.exports;
}
var ajvCompiler = { exports: {} };
var ajv = { exports: {} };
var core$1 = {};
var validate = {};
var boolSchema = {};
var errors$1 = {};
var codegen = {};
var code$1 = {};
var hasRequiredCode$1;
function requireCode$1() {
  if (hasRequiredCode$1) return code$1;
  hasRequiredCode$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports$1.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    exports$1.Name = Name;
    class _Code extends _CodeOrName {
      constructor(code2) {
        super();
        this._items = typeof code2 === "string" ? [code2] : code2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
          if (c instanceof Name)
            names2[c.str] = (names2[c.str] || 0) + 1;
          return names2;
        }, {});
      }
    }
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _(strs, ...args) {
      const code2 = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code2, args[i]);
        code2.push(strs[++i]);
      }
      return new _Code(code2);
    }
    exports$1._ = _;
    const plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code2, arg) {
      if (arg instanceof _Code)
        code2.push(...arg._items);
      else if (arg instanceof Name)
        code2.push(arg);
      else
        code2.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res2 = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res2 !== void 0) {
            expr.splice(i - 1, 3, res2);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports$1.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  })(code$1);
  return code$1;
}
var scope = {};
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    const code_1 = /* @__PURE__ */ requireCode$1();
    class ValueError extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    }
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    class Scope {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    }
    exports$1.Scope = Scope;
    class ValueScopeName extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    }
    exports$1.ValueScopeName = ValueScopeName;
    const line = (0, code_1._)`\n`;
    class ValueScope extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values2 = this._values) {
        return this._reduceValues(values2, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values2 = this._values, usedValues, getCode) {
        return this._reduceValues(values2, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values2, valueCode, usedValues = {}, getCode) {
        let code2 = code_1.nil;
        for (const prefix in values2) {
          const vs = values2[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code2 = (0, code_1._)`${code2}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code2;
      }
    }
    exports$1.ValueScope = ValueScope;
  })(scope);
  return scope;
}
var hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen;
  hasRequiredCodegen = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    const code_1 = /* @__PURE__ */ requireCode$1();
    const scope_1 = /* @__PURE__ */ requireScope();
    var code_2 = /* @__PURE__ */ requireCode$1();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = /* @__PURE__ */ requireScope();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    class Node {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }
    class Def extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names2, constants2) {
        if (!names2[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names2, constants2);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }
    class Assign extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names2, constants2) {
        if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
        return this;
      }
      get names() {
        const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names2, this.rhs);
      }
    }
    class AssignOp extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }
    class Label extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }
    class Break extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    }
    class Throw extends Node {
      constructor(error2) {
        super();
        this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }
    class AnyCode extends Node {
      constructor(code2) {
        super();
        this.code = code2;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names2, constants2) {
        this.code = optimizeExpr(this.code, names2, constants2);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }
    class ParentNode extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names2, constants2) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names2, constants2))
            continue;
          subtractNames(names2, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
      }
    }
    class BlockNode extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }
    class Root extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code2 = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code2 += "else " + this.else.render(opts);
        return code2;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not2(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names2, constants2) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants2);
        if (!(super.optimizeNames(names2, constants2) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names2, constants2);
        return this;
      }
      get names() {
        const names2 = super.names;
        addExprNames(names2, this.condition);
        if (this.else)
          addNames(names2, this.else.names);
        return names2;
      }
    }
    If.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names2, constants2) {
        if (!super.optimizeNames(names2, constants2))
          return;
        this.iteration = optimizeExpr(this.iteration, names2, constants2);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }
    class ForRange extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names2 = addExprNames(super.names, this.from);
        return addExprNames(names2, this.to);
      }
    }
    class ForIter extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names2, constants2) {
        if (!super.optimizeNames(names2, constants2))
          return;
        this.iterable = optimizeExpr(this.iterable, names2, constants2);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }
    class Func extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    }
    Func.kind = "func";
    class Return extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    }
    Return.kind = "return";
    class Try extends BlockNode {
      render(opts) {
        let code2 = "try" + super.render(opts);
        if (this.catch)
          code2 += this.catch.render(opts);
        if (this.finally)
          code2 += this.finally.render(opts);
        return code2;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names2, constants2) {
        var _a2, _b;
        super.optimizeNames(names2, constants2);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants2);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
        return this;
      }
      get names() {
        const names2 = super.names;
        if (this.catch)
          addNames(names2, this.catch.names);
        if (this.finally)
          addNames(names2, this.finally.names);
        return names2;
      }
    }
    class Catch extends BlockNode {
      constructor(error2) {
        super();
        this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    }
    Finally.kind = "finally";
    class CodeGen {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code2 = ["{"];
        for (const [key, value] of keyValues) {
          if (code2.length > 1)
            code2.push(",");
          code2.push(key);
          if (key !== value || this.opts.es5) {
            code2.push(":");
            (0, code_1.addCodeArg)(code2, value);
          }
        }
        code2.push("}");
        return new code_1._Code(code2);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node2, forBody) {
        this._blockNode(node2);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node2 = new Return();
        this._blockNode(node2);
        this.code(value);
        if (node2.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node2 = new Try();
        this._blockNode(node2);
        this.code(tryBody);
        if (catchCode) {
          const error2 = this.name("e");
          this._currNode = node2.catch = new Catch(error2);
          catchCode(error2);
        }
        if (finallyCode) {
          this._currNode = node2.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node2) {
        this._currNode.nodes.push(node2);
        return this;
      }
      _blockNode(node2) {
        this._currNode.nodes.push(node2);
        this._nodes.push(node2);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node2) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node2;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node2) {
        const ns = this._nodes;
        ns[ns.length - 1] = node2;
      }
    }
    exports$1.CodeGen = CodeGen;
    function addNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) + (from[n] || 0);
      return names2;
    }
    function addExprNames(names2, from) {
      return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
    }
    function optimizeExpr(expr, names2, constants2) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items2, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items2.push(...c._items);
        else
          items2.push(c);
        return items2;
      }, []));
      function replaceName(n) {
        const c = constants2[n.str];
        if (c === void 0 || names2[n.str] !== 1)
          return n;
        delete names2[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
      }
    }
    function subtractNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) - (from[n] || 0);
    }
    function not2(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports$1.not = not2;
    const andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    const orCode = mappend(exports$1.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  })(codegen);
  return codegen;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  Object.defineProperty(util$1, "__esModule", { value: true });
  util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const code_1 = /* @__PURE__ */ requireCode$1();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  util$1.toHash = toHash;
  function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  }
  util$1.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  util$1.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules2[key])
        return true;
    return false;
  }
  util$1.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  util$1.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
  }
  util$1.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  util$1.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  util$1.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  util$1.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  util$1.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  util$1.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
    return (gen, from, to, toName) => {
      const res2 = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
      return toName === codegen_1.Name && !(res2 instanceof codegen_1.Name) ? resultToName(gen, res2) : res2;
    };
  }
  util$1.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  util$1.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  }
  util$1.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  }
  util$1.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (util$1.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber2 = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  util$1.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  util$1.checkStrictMode = checkStrictMode;
  return util$1;
}
var names = {};
var hasRequiredNames;
function requireNames() {
  if (hasRequiredNames) return names;
  hasRequiredNames = 1;
  Object.defineProperty(names, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names$1 = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    // null or array of validation errors
    errors: new codegen_1.Name("errors"),
    // counter of validation errors
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  names.default = names$1;
  return names;
}
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const names_1 = /* @__PURE__ */ requireNames();
    exports$1.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error2, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError;
    function reportExtraError(cxt, error2 = exports$1.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err2 = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err2, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err2}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err2}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err2}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err2}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err2}.data`, data);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err2 = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err2}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err2})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    const E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error2, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  })(errors$1);
  return errors$1;
}
var hasRequiredBoolSchema;
function requireBoolSchema() {
  if (hasRequiredBoolSchema) return boolSchema;
  hasRequiredBoolSchema = 1;
  Object.defineProperty(boolSchema, "__esModule", { value: true });
  boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it, valid2) {
    const { gen, schema } = it;
    if (schema === false) {
      gen.var(valid2, false);
      falseSchemaError(it);
    } else {
      gen.var(valid2, true);
    }
  }
  boolSchema.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
  }
  return boolSchema;
}
var dataType = {};
var rules = {};
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  Object.defineProperty(rules, "__esModule", { value: true });
  rules.getRules = rules.isJSONType = void 0;
  const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  const jsonTypes = new Set(_jsonTypes);
  function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
  }
  rules.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  rules.getRules = getRules;
  return rules;
}
var applicability = {};
var hasRequiredApplicability;
function requireApplicability() {
  if (hasRequiredApplicability) return applicability;
  hasRequiredApplicability = 1;
  Object.defineProperty(applicability, "__esModule", { value: true });
  applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
  function schemaHasRulesForType({ schema, self: self2 }, type2) {
    const group = self2.RULES.types[type2];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  applicability.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  applicability.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
  }
  applicability.shouldUseRule = shouldUseRule;
  return applicability;
}
var hasRequiredDataType;
function requireDataType() {
  if (hasRequiredDataType) return dataType;
  hasRequiredDataType = 1;
  Object.defineProperty(dataType, "__esModule", { value: true });
  dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
  const rules_1 = /* @__PURE__ */ requireRules();
  const applicability_1 = /* @__PURE__ */ requireApplicability();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (dataType.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types2 = getJSONTypes(schema.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  dataType.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  dataType.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  dataType.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts } = it;
    const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  dataType.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_1.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t in types2)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  dataType.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  }
  dataType.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  }
  return dataType;
}
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  Object.defineProperty(defaults, "__esModule", { value: true });
  defaults.assignDefaults = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  function assignDefaults(it, ty) {
    const { properties: properties2, items: items2 } = it.schema;
    if (ty === "object" && properties2) {
      for (const key in properties2) {
        assignDefault(it, key, properties2[key].default);
      }
    } else if (ty === "array" && Array.isArray(items2)) {
      items2.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  }
  defaults.assignDefaults = assignDefaults;
  function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === void 0)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
  return defaults;
}
var keyword = {};
var code = {};
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code;
  hasRequiredCode = 1;
  Object.defineProperty(code, "__esModule", { value: true });
  code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const names_1 = /* @__PURE__ */ requireNames();
  const util_2 = /* @__PURE__ */ requireUtil$1();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  code.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
    return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  code.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  code.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  code.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  code.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  code.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  code.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  }
  code.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  }
  code.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context2, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context2 !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context2}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  code.callValidateCode = callValidateCode;
  const newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern2) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern2, u);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
    });
  }
  code.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    if (it.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid2, true);
    validateItems(() => gen.break());
    return valid2;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: keyword2,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid2);
        gen.if((0, codegen_1.not)(valid2), notValid);
      });
    }
  }
  code.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword: keyword2, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid2 = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid2, (0, codegen_1._)`${valid2} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid2));
    }));
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
  }
  code.validateUnion = validateUnion;
  return code;
}
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", { value: true });
  keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const code_1 = /* @__PURE__ */ requireCode();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword2, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid2 = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid2);
    cxt.pass(valid2, () => cxt.error(true));
  }
  keyword.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a2;
    const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate2 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword2, validate2);
    const valid2 = gen.let("valid");
    cxt.block$data(valid2, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid2);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !("compile" in def && !$data || def.schema === false);
      gen.assign(valid2, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors2) {
      var _a3;
      gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid2), errors2);
    }
  }
  keyword.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword2, result) {
    if (result === void 0)
      throw new Error(`keyword "${keyword2}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  }
  keyword.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid2 = def.validateSchema(schema[keyword2]);
      if (!valid2) {
        const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  keyword.validateKeywordUsage = validateKeywordUsage;
  return keyword;
}
var subschema = {};
var hasRequiredSubschema;
function requireSubschema() {
  if (hasRequiredSubschema) return subschema;
  hasRequiredSubschema = 1;
  Object.defineProperty(subschema, "__esModule", { value: true });
  subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword2 !== void 0 && schema !== void 0) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword2 !== void 0) {
      const sch = it.schema[keyword2];
      return schemaProp === void 0 ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== void 0) {
      if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  subschema.getSubschema = getSubschema;
  function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== void 0 && dataProp !== void 0) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== void 0) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
    }
    if (data !== void 0) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== void 0)
        subschema2.propertyName = propertyName;
    }
    if (dataTypes)
      subschema2.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema2.data = _nextData;
      subschema2.dataLevel = it.dataLevel + 1;
      subschema2.dataTypes = [];
      it.definedProperties = /* @__PURE__ */ new Set();
      subschema2.parentData = it.data;
      subschema2.dataNames = [...it.dataNames, _nextData];
    }
  }
  subschema.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== void 0)
      subschema2.compositeRule = compositeRule;
    if (createErrors !== void 0)
      subschema2.createErrors = createErrors;
    if (allErrors !== void 0)
      subschema2.allErrors = allErrors;
    subschema2.jtdDiscriminator = jtdDiscriminator;
    subschema2.jtdMetadata = jtdMetadata;
  }
  subschema.extendSubschemaMode = extendSubschemaMode;
  return subschema;
}
var resolve = {};
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (!equal2(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal2(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
  return fastDeepEqual;
}
var jsonSchemaTraverse = { exports: {} };
var hasRequiredJsonSchemaTraverse;
function requireJsonSchemaTraverse() {
  if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
  hasRequiredJsonSchemaTraverse = 1;
  var traverse = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse.exports;
}
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve) return resolve;
  hasRequiredResolve = 1;
  Object.defineProperty(resolve, "__esModule", { value: true });
  resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal2 = requireFastDeepEqual();
  const traverse = requireJsonSchemaTraverse();
  const SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit2 = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit2 === true)
      return !hasRef(schema);
    if (!limit2)
      return false;
    return countKeys(schema) <= limit2;
  }
  resolve.inlineRef = inlineRef;
  const REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id2 = "", normalize) {
    if (normalize !== false)
      id2 = normalizeId(id2);
    const p = resolver.parse(id2);
    return _getFullPath(resolver, p);
  }
  resolve.getFullPath = getFullPath;
  function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  }
  resolve._getFullPath = _getFullPath;
  const TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  resolve.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id2) {
    id2 = normalizeId(id2);
    return resolver.resolve(baseId, id2);
  }
  resolve.resolveUrl = resolveUrl;
  const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref2) {
        const _resolve = this.opts.uriResolver.resolve;
        ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
        if (schemaRefs.has(ref2))
          throw ambiguos(ref2);
        schemaRefs.add(ref2);
        let schOrRef = this.refs[ref2];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref2);
        } else if (ref2 !== normalizeId(fullPath)) {
          if (ref2[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref2], ref2);
            localRefs[ref2] = sch;
          } else {
            this.refs[ref2] = fullPath;
          }
        }
        return ref2;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref2) {
      if (sch2 !== void 0 && !equal2(sch1, sch2))
        throw ambiguos(ref2);
    }
    function ambiguos(ref2) {
      return new Error(`reference "${ref2}" resolves to more than one schema`);
    }
  }
  resolve.getSchemaRefs = getSchemaRefs;
  return resolve;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", { value: true });
  validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
  const boolSchema_1 = /* @__PURE__ */ requireBoolSchema();
  const dataType_1 = /* @__PURE__ */ requireDataType();
  const applicability_1 = /* @__PURE__ */ requireApplicability();
  const dataType_2 = /* @__PURE__ */ requireDataType();
  const defaults_1 = /* @__PURE__ */ requireDefaults();
  const keyword_1 = /* @__PURE__ */ requireKeyword();
  const subschema_1 = /* @__PURE__ */ requireSubschema();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const resolve_1 = /* @__PURE__ */ requireResolve();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  }
  validate.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  }
  function resetEvaluated(it) {
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it, valid2) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid2);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid2);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it) {
    return typeof it.schema != "boolean";
  }
  function subSchemaObjCode(it, valid2) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen.var(valid2, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  }
  function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
    schemaKeywords(it, types2, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  }
  function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  }
  function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items: items2 }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items2 instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
  }
  function schemaKeywords(it, types2, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types2);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types2.length === 1 && types2[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it, types2) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types2);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types2);
    checkKeywordTypes(it, it.dataTypes);
  }
  function checkContextTypes(it, types2) {
    if (!types2.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types2;
      return;
    }
    types2.forEach((t) => {
      if (!includesType(it.dataTypes, t)) {
        strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types2);
  }
  function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it, ts) {
    const rules2 = it.self.RULES.all;
    for (const keyword2 in rules2) {
      const rule = rules2[keyword2];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type: type2 } = rule.definition;
        if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  }
  function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  }
  class KeywordCxt {
    constructor(it, def, keyword2) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword2);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword2;
      this.data = it.data;
      this.schema = it.schema[keyword2];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), void 0, failAction);
    }
    fail(condition) {
      if (condition === void 0) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid2, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid2, $dataValid);
        codeBlock();
      });
    }
    check$data(valid2 = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid2 !== codegen_1.nil)
        gen.assign(valid2, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid2 !== codegen_1.nil)
          gen.assign(valid2, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid2) {
      const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema2, appl);
      const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
      subschemaCode(nextContext, valid2);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== void 0) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== void 0) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid2) {
      const { it, gen } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  validate.KeywordCxt = KeywordCxt;
  function keywordCode(it, keyword2, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword2);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  validate.getData = getData;
  return validate;
}
var validation_error = {};
var hasRequiredValidation_error;
function requireValidation_error() {
  if (hasRequiredValidation_error) return validation_error;
  hasRequiredValidation_error = 1;
  Object.defineProperty(validation_error, "__esModule", { value: true });
  class ValidationError extends Error {
    constructor(errors2) {
      super("validation failed");
      this.errors = errors2;
      this.ajv = this.validation = true;
    }
  }
  validation_error.default = ValidationError;
  return validation_error;
}
var ref_error = {};
var hasRequiredRef_error;
function requireRef_error() {
  if (hasRequiredRef_error) return ref_error;
  hasRequiredRef_error = 1;
  Object.defineProperty(ref_error, "__esModule", { value: true });
  const resolve_1 = /* @__PURE__ */ requireResolve();
  class MissingRefError extends Error {
    constructor(resolver, baseId, ref2, msg) {
      super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  ref_error.default = MissingRefError;
  return ref_error;
}
var compile = {};
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile;
  hasRequiredCompile = 1;
  Object.defineProperty(compile, "__esModule", { value: true });
  compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const validation_error_1 = /* @__PURE__ */ requireValidation_error();
  const names_1 = /* @__PURE__ */ requireNames();
  const resolve_1 = /* @__PURE__ */ requireResolve();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const validate_1 = /* @__PURE__ */ requireValidate();
  class SchemaEnv {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  }
  compile.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate2 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate2 });
      validate2.errors = null;
      validate2.schema = sch.schema;
      validate2.schemaEnv = sch;
      if (sch.$async)
        validate2.$async = true;
      if (this.opts.code.source === true) {
        validate2.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items: items2 } = schemaCxt;
        validate2.evaluated = {
          props: props instanceof codegen_1.Name ? void 0 : props,
          items: items2 instanceof codegen_1.Name ? void 0 : items2,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items2 instanceof codegen_1.Name
        };
        if (validate2.source)
          validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
      }
      sch.validate = validate2;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  compile.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref2) {
    var _a2;
    ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
    const schOrFunc = root.refs[ref2];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve2.call(this, root, ref2);
    if (_sch === void 0) {
      const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === void 0)
      return;
    return root.refs[ref2] = inlineOrCompile.call(this, _sch);
  }
  compile.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  compile.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve2(root, ref2) {
    let sch;
    while (typeof (sch = this.refs[ref2]) == "string")
      ref2 = sch;
    return sch || this.schemas[ref2] || resolveSchema2.call(this, root, ref2);
  }
  function resolveSchema2(root, ref2) {
    const p = this.opts.uriResolver.parse(ref2);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root);
    }
    const id2 = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id2] || this.schemas[id2];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema2.call(this, root, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id2 === (0, resolve_1.normalizeId)(ref2)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  }
  compile.resolveSchema = resolveSchema2;
  const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema2.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return void 0;
  }
  return compile;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$2 = "object";
const required$2 = ["$data"];
const properties$3 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$2,
  required: required$2,
  properties: properties$3,
  additionalProperties: additionalProperties$1
};
var uri = {};
var fastUri = { exports: {} };
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code2 = 0;
    let i = 0;
    for (i = 0; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (code2 === 48) {
        continue;
      }
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex = stringArrayToHexStripped(buffer);
      if (hex !== "") {
        address.push(hex);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0; i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv62 = getIPV6(host);
    if (!ipv62.error) {
      let newHost = ipv62.address;
      let escapedHost = ipv62.address;
      if (ipv62.zone) {
        newHost += "%" + ipv62.zone;
        escapedHost += "%25" + ipv62.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === token) ind++;
    }
    return ind;
  }
  function removeDotSegments(path2) {
    let input = path2;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc2) {
    const func = esc2 !== true ? escape : unescape;
    if (component.scheme !== void 0) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== void 0) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== void 0) {
      component.host = func(component.host);
    }
    if (component.path !== void 0) {
      component.path = func(component.path);
    }
    if (component.query !== void 0) {
      component.query = func(component.query);
    }
    if (component.fragment !== void 0) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== void 0) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== void 0) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : void 0;
  }
  utils = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
  return utils;
}
var schemes;
var hasRequiredSchemes;
function requireSchemes() {
  if (hasRequiredSchemes) return schemes;
  hasRequiredSchemes = 1;
  const { isUUID } = requireUtils();
  const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  const supportedSchemeNames = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(
      /** @type {*} */
      name
    ) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = void 0;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = void 0;
    wsComponent.query = void 0;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = void 0;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = void 0;
    }
    if (wsComponent.resourceName) {
      const [path2, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path2 && path2 !== "/" ? path2 : void 0;
      wsComponent.query = query;
      wsComponent.resourceName = void 0;
    }
    wsComponent.fragment = void 0;
    return wsComponent;
  }
  function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = void 0;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === void 0) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = void 0;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  const http = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const https = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const ws = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    }
  );
  const wss = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    }
  );
  const urn = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    }
  );
  const urnuuid = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    }
  );
  const SCHEMES = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    }
  );
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[
      /** @type {SchemeName} */
      scheme
    ] || SCHEMES[
      /** @type {SchemeName} */
      scheme.toLowerCase()
    ]) || void 0;
  }
  schemes = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
  return schemes;
}
var hasRequiredFastUri;
function requireFastUri() {
  if (hasRequiredFastUri) return fastUri.exports;
  hasRequiredFastUri = 1;
  const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = requireUtils();
  const { SCHEMES, getSchemeHandler } = requireSchemes();
  function normalize(uri2, options) {
    if (typeof uri2 === "string") {
      uri2 = /** @type {T} */
      serialize2(parse2(uri2, options), options);
    } else if (typeof uri2 === "object") {
      uri2 = /** @type {T} */
      parse2(serialize2(uri2, options), options);
    }
    return uri2;
  }
  function resolve2(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
    const resolved = resolveComponent(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize2(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse2(serialize2(base, options), options);
      relative = parse2(serialize2(relative, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== void 0) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal2(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize2(normalizeComponentEncoding(parse2(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize2(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize2(normalizeComponentEncoding(parse2(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize2(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize2(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
    if (component.path !== void 0) {
      if (!options.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== void 0) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== void 0) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== void 0) {
      let s = component.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === void 0 && s[0] === "/" && s[1] === "/") {
        s = "/%2F" + s.slice(2);
      }
      uriTokens.push(s);
    }
    if (component.query !== void 0) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== void 0) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse2(uri2, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let isIP = false;
    if (options.reference === "suffix") {
      if (options.scheme) {
        uri2 = options.scheme + ":" + uri2;
      } else {
        uri2 = "//" + uri2;
      }
    }
    const matches = uri2.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === void 0) {
        parsed.reference = "relative";
      } else if (parsed.fragment === void 0) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri2.indexOf("%") !== -1) {
          if (parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  const fastUri$1 = {
    SCHEMES,
    normalize,
    resolve: resolve2,
    resolveComponent,
    equal: equal2,
    serialize: serialize2,
    parse: parse2
  };
  fastUri.exports = fastUri$1;
  fastUri.exports.default = fastUri$1;
  fastUri.exports.fastUri = fastUri$1;
  return fastUri.exports;
}
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  Object.defineProperty(uri, "__esModule", { value: true });
  const uri$1 = requireFastUri();
  uri$1.code = 'require("ajv/dist/runtime/uri").default';
  uri.default = uri$1;
  return uri;
}
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1) return core$1;
  hasRequiredCore$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = /* @__PURE__ */ requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    const validation_error_1 = /* @__PURE__ */ requireValidation_error();
    const ref_error_1 = /* @__PURE__ */ requireRef_error();
    const rules_1 = /* @__PURE__ */ requireRules();
    const compile_1 = /* @__PURE__ */ requireCompile();
    const codegen_2 = /* @__PURE__ */ requireCodegen();
    const resolve_1 = /* @__PURE__ */ requireResolve();
    const dataType_1 = /* @__PURE__ */ requireDataType();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const $dataRefSchema = require$$9;
    const uri_1 = /* @__PURE__ */ requireUri();
    const defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    const removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    const MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    class Ajv {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta2, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta2, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid2 = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid2;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta2);
        }
        async function _loadSchema(ref2) {
          const p = this._loading[ref2];
          if (p)
            return p;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema2;
        $schema2 = schema.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid2 = this.validate($schema2, schema);
        if (!valid2 && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid2;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions2) {
        for (const def of definitions2)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors2 || errors2.length === 0)
          return "No errors";
        return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules2 = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules2) {
            const rule = rules2[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas2, regex) {
        for (const keyRef in schemas2) {
          const sch = schemas2[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas2[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas2[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta2, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    }
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv;
    function checkOptions(checkOpts, options, msg, log2 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    const noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType2) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType2 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  })(core$1);
  return core$1;
}
var draft7 = {};
var core = {};
var id = {};
var hasRequiredId;
function requireId() {
  if (hasRequiredId) return id;
  hasRequiredId = 1;
  Object.defineProperty(id, "__esModule", { value: true });
  const def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  id.default = def;
  return id;
}
var ref$1 = {};
var hasRequiredRef$1;
function requireRef$1() {
  if (hasRequiredRef$1) return ref$1;
  hasRequiredRef$1 = 1;
  Object.defineProperty(ref$1, "__esModule", { value: true });
  ref$1.callRef = ref$1.getValidate = void 0;
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const compile_1 = /* @__PURE__ */ requireCompile();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid2 = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid2);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid2);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  ref$1.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid2 = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid2, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid2, false);
      });
      cxt.ok(valid2);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
          }
        } else {
          const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
        }
      }
    }
  }
  ref$1.callRef = callRef;
  ref$1.default = def;
  return ref$1;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", { value: true });
  const id_1 = /* @__PURE__ */ requireId();
  const ref_1 = /* @__PURE__ */ requireRef$1();
  const core$12 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  core.default = core$12;
  return core;
}
var validation = {};
var limitNumber = {};
var hasRequiredLimitNumber;
function requireLimitNumber() {
  if (hasRequiredLimitNumber) return limitNumber;
  hasRequiredLimitNumber = 1;
  Object.defineProperty(limitNumber, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const ops = codegen_1.operators;
  const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
  };
  const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  limitNumber.default = def;
  return limitNumber;
}
var multipleOf = {};
var hasRequiredMultipleOf;
function requireMultipleOf() {
  if (hasRequiredMultipleOf) return multipleOf;
  hasRequiredMultipleOf = 1;
  Object.defineProperty(multipleOf, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res2 = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res2}) - ${res2}) > 1e-${prec}` : (0, codegen_1._)`${res2} !== parseInt(${res2})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res2} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  multipleOf.default = def;
  return multipleOf;
}
var limitLength = {};
var ucs2length = {};
var hasRequiredUcs2length;
function requireUcs2length() {
  if (hasRequiredUcs2length) return ucs2length;
  hasRequiredUcs2length = 1;
  Object.defineProperty(ucs2length, "__esModule", { value: true });
  function ucs2length$1(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  ucs2length.default = ucs2length$1;
  ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
  return ucs2length;
}
var hasRequiredLimitLength;
function requireLimitLength() {
  if (hasRequiredLimitLength) return limitLength;
  hasRequiredLimitLength = 1;
  Object.defineProperty(limitLength, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const ucs2length_1 = /* @__PURE__ */ requireUcs2length();
  const error2 = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode, it } = cxt;
      const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  limitLength.default = def;
  return limitLength;
}
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  Object.defineProperty(pattern, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      if ($data) {
        const { regExp } = it.opts.code;
        const regExpCode = regExp.code === "new RegExp" ? (0, codegen_1._)`new RegExp` : (0, util_1.useFunc)(gen, regExp);
        const valid2 = gen.let("valid");
        gen.try(() => gen.assign(valid2, (0, codegen_1._)`${regExpCode}(${schemaCode}, ${u}).test(${data})`), () => gen.assign(valid2, false));
        cxt.fail$data((0, codegen_1._)`!${valid2}`);
      } else {
        const regExp = (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    }
  };
  pattern.default = def;
  return pattern;
}
var limitProperties = {};
var hasRequiredLimitProperties;
function requireLimitProperties() {
  if (hasRequiredLimitProperties) return limitProperties;
  hasRequiredLimitProperties = 1;
  Object.defineProperty(limitProperties, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error2 = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  limitProperties.default = def;
  return limitProperties;
}
var required$1 = {};
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required$1;
  hasRequiredRequired = 1;
  Object.defineProperty(required$1, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid2 = gen.let("valid", true);
          cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
          cxt.ok(valid2);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid2) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid2, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid2), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  required$1.default = def;
  return required$1;
}
var limitItems = {};
var hasRequiredLimitItems;
function requireLimitItems() {
  if (hasRequiredLimitItems) return limitItems;
  hasRequiredLimitItems = 1;
  Object.defineProperty(limitItems, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error2 = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  limitItems.default = def;
  return limitItems;
}
var uniqueItems = {};
var equal = {};
var hasRequiredEqual;
function requireEqual() {
  if (hasRequiredEqual) return equal;
  hasRequiredEqual = 1;
  Object.defineProperty(equal, "__esModule", { value: true });
  const equal$1 = requireFastDeepEqual();
  equal$1.code = 'require("ajv/dist/runtime/equal").default';
  equal.default = equal$1;
  return equal;
}
var hasRequiredUniqueItems;
function requireUniqueItems() {
  if (hasRequiredUniqueItems) return uniqueItems;
  hasRequiredUniqueItems = 1;
  Object.defineProperty(uniqueItems, "__esModule", { value: true });
  const dataType_1 = /* @__PURE__ */ requireDataType();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error2 = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid2 = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid2, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid2);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j = gen.let("j");
        cxt.setParams({ i, j });
        gen.assign(valid2, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid2, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
          cxt.error();
          gen.assign(valid2, false).break(outer);
        })));
      }
    }
  };
  uniqueItems.default = def;
  return uniqueItems;
}
var _const = {};
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1;
  Object.defineProperty(_const, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error2 = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  const def = {
    keyword: "const",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  _const.default = def;
  return _const;
}
var _enum$2 = {};
var hasRequired_enum$1;
function require_enum$1() {
  if (hasRequired_enum$1) return _enum$2;
  hasRequired_enum$1 = 1;
  Object.defineProperty(_enum$2, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error2 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid2;
      if (useLoop || $data) {
        valid2 = gen.let("valid");
        cxt.block$data(valid2, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid2 = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid2);
      function loopEnum() {
        gen.assign(valid2, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  _enum$2.default = def;
  return _enum$2;
}
var hasRequiredValidation;
function requireValidation() {
  if (hasRequiredValidation) return validation;
  hasRequiredValidation = 1;
  Object.defineProperty(validation, "__esModule", { value: true });
  const limitNumber_1 = /* @__PURE__ */ requireLimitNumber();
  const multipleOf_1 = /* @__PURE__ */ requireMultipleOf();
  const limitLength_1 = /* @__PURE__ */ requireLimitLength();
  const pattern_1 = /* @__PURE__ */ requirePattern();
  const limitProperties_1 = /* @__PURE__ */ requireLimitProperties();
  const required_1 = /* @__PURE__ */ requireRequired();
  const limitItems_1 = /* @__PURE__ */ requireLimitItems();
  const uniqueItems_1 = /* @__PURE__ */ requireUniqueItems();
  const const_1 = /* @__PURE__ */ require_const();
  const enum_1 = /* @__PURE__ */ require_enum$1();
  const validation$12 = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  validation.default = validation$12;
  return validation;
}
var applicator = {};
var additionalItems = {};
var hasRequiredAdditionalItems;
function requireAdditionalItems() {
  if (hasRequiredAdditionalItems) return additionalItems;
  hasRequiredAdditionalItems = 1;
  Object.defineProperty(additionalItems, "__esModule", { value: true });
  additionalItems.validateAdditionalItems = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error2,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items: items2 } = parentSchema;
      if (!Array.isArray(items2)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items2);
    }
  };
  function validateAdditionalItems(cxt, items2) {
    const { gen, schema, data, keyword: keyword2, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items2.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid2 = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
      gen.if((0, codegen_1.not)(valid2), () => validateItems(valid2));
      cxt.ok(valid2);
    }
    function validateItems(valid2) {
      gen.forRange("i", items2.length, len, (i) => {
        cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid2);
        if (!it.allErrors)
          gen.if((0, codegen_1.not)(valid2), () => gen.break());
      });
    }
  }
  additionalItems.validateAdditionalItems = validateAdditionalItems;
  additionalItems.default = def;
  return additionalItems;
}
var prefixItems = {};
var items = {};
var hasRequiredItems;
function requireItems() {
  if (hasRequiredItems) return items;
  hasRequiredItems = 1;
  Object.defineProperty(items, "__esModule", { value: true });
  items.validateTuple = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const code_1 = /* @__PURE__ */ requireCode();
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid2 = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        dataProp: i
      }, valid2));
      cxt.ok(valid2);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  }
  items.validateTuple = validateTuple;
  items.default = def;
  return items;
}
var hasRequiredPrefixItems;
function requirePrefixItems() {
  if (hasRequiredPrefixItems) return prefixItems;
  hasRequiredPrefixItems = 1;
  Object.defineProperty(prefixItems, "__esModule", { value: true });
  const items_1 = /* @__PURE__ */ requireItems();
  const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  prefixItems.default = def;
  return prefixItems;
}
var items2020 = {};
var hasRequiredItems2020;
function requireItems2020() {
  if (hasRequiredItems2020) return items2020;
  hasRequiredItems2020 = 1;
  Object.defineProperty(items2020, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const code_1 = /* @__PURE__ */ requireCode();
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems();
  const error2 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error2,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems: prefixItems2 } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems2)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  items2020.default = def;
  return items2020;
}
var contains = {};
var hasRequiredContains;
function requireContains() {
  if (hasRequiredContains) return contains;
  hasRequiredContains = 1;
  Object.defineProperty(contains, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === void 0 ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === void 0 && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== void 0 && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== void 0)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid2 = gen.name("valid");
      if (max === void 0 && min === 1) {
        validateItems(valid2, () => gen.if(valid2, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid2, true);
        if (max !== void 0)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid2, false);
        validateItemsWithCount();
      }
      cxt.result(valid2, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === void 0) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
          if (min === 1)
            gen.assign(valid2, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid2, true));
        }
      }
    }
  };
  contains.default = def;
  return contains;
}
var dependencies = {};
var hasRequiredDependencies;
function requireDependencies() {
  if (hasRequiredDependencies) return dependencies;
  hasRequiredDependencies = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const code_1 = /* @__PURE__ */ requireCode();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    const def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid2 = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
            cxt.mergeValidEvaluated(schCxt, valid2);
          },
          () => gen.var(valid2, true)
          // TODO var
        );
        cxt.ok(valid2);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  })(dependencies);
  return dependencies;
}
var propertyNames = {};
var hasRequiredPropertyNames;
function requirePropertyNames() {
  if (hasRequiredPropertyNames) return propertyNames;
  hasRequiredPropertyNames = 1;
  Object.defineProperty(propertyNames, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error2,
    code(cxt) {
      const { gen, schema, data, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid2 = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid2);
        gen.if((0, codegen_1.not)(valid2), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid2);
    }
  };
  propertyNames.default = def;
  return propertyNames;
}
var additionalProperties = {};
var hasRequiredAdditionalProperties;
function requireAdditionalProperties() {
  if (hasRequiredAdditionalProperties) return additionalProperties;
  hasRequiredAdditionalProperties = 1;
  Object.defineProperty(additionalProperties, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid2 = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid2, false);
            gen.if((0, codegen_1.not)(valid2), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid2);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid2), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid2, errors2) {
        const subschema2 = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors2 === false) {
          Object.assign(subschema2, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema2, valid2);
      }
    }
  };
  additionalProperties.default = def;
  return additionalProperties;
}
var properties$2 = {};
var hasRequiredProperties$1;
function requireProperties$1() {
  if (hasRequiredProperties$1) return properties$2;
  hasRequiredProperties$1 = 1;
  Object.defineProperty(properties$2, "__esModule", { value: true });
  const validate_1 = /* @__PURE__ */ requireValidate();
  const code_1 = /* @__PURE__ */ requireCode();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties();
  const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
      }
      const properties2 = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties2.length === 0)
        return;
      const valid2 = gen.name("valid");
      for (const prop of properties2) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen.else().var(valid2, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid2);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid2);
      }
    }
  };
  properties$2.default = def;
  return properties$2;
}
var patternProperties = {};
var hasRequiredPatternProperties;
function requirePatternProperties() {
  if (hasRequiredPatternProperties) return patternProperties;
  hasRequiredPatternProperties = 1;
  Object.defineProperty(patternProperties, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const util_2 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid2 = gen.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid2, true);
            validateProperties(pat);
            gen.if(valid2);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid2);
            }
            if (it.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen.if((0, codegen_1.not)(valid2), () => gen.break());
            }
          });
        });
      }
    }
  };
  patternProperties.default = def;
  return patternProperties;
}
var not = {};
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  Object.defineProperty(not, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid2 = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid2);
      cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  not.default = def;
  return not;
}
var anyOf = {};
var hasRequiredAnyOf;
function requireAnyOf() {
  if (hasRequiredAnyOf) return anyOf;
  hasRequiredAnyOf = 1;
  Object.defineProperty(anyOf, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  anyOf.default = def;
  return anyOf;
}
var oneOf = {};
var hasRequiredOneOf;
function requireOneOf() {
  if (hasRequiredOneOf) return oneOf;
  hasRequiredOneOf = 1;
  Object.defineProperty(oneOf, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid2 = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid2, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  oneOf.default = def;
  return oneOf;
}
var allOf = {};
var hasRequiredAllOf;
function requireAllOf() {
  if (hasRequiredAllOf) return allOf;
  hasRequiredAllOf = 1;
  Object.defineProperty(allOf, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid2 = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
        cxt.ok(valid2);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  allOf.default = def;
  return allOf;
}
var _if = {};
var hasRequired_if;
function require_if() {
  if (hasRequired_if) return _if;
  hasRequired_if = 1;
  Object.defineProperty(_if, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, parentSchema, it } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid2 = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid2, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword2, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
          gen.assign(valid2, schValid);
          cxt.mergeValidEvaluated(schCxt, valid2);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
          else
            cxt.setParams({ ifClause: keyword2 });
        };
      }
    }
  };
  function hasSchema(it, keyword2) {
    const schema = it.schema[keyword2];
    return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
  }
  _if.default = def;
  return _if;
}
var thenElse = {};
var hasRequiredThenElse;
function requireThenElse() {
  if (hasRequiredThenElse) return thenElse;
  hasRequiredThenElse = 1;
  Object.defineProperty(thenElse, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: keyword2, parentSchema, it }) {
      if (parentSchema.if === void 0)
        (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
    }
  };
  thenElse.default = def;
  return thenElse;
}
var hasRequiredApplicator;
function requireApplicator() {
  if (hasRequiredApplicator) return applicator;
  hasRequiredApplicator = 1;
  Object.defineProperty(applicator, "__esModule", { value: true });
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems();
  const prefixItems_1 = /* @__PURE__ */ requirePrefixItems();
  const items_1 = /* @__PURE__ */ requireItems();
  const items2020_1 = /* @__PURE__ */ requireItems2020();
  const contains_1 = /* @__PURE__ */ requireContains();
  const dependencies_1 = /* @__PURE__ */ requireDependencies();
  const propertyNames_1 = /* @__PURE__ */ requirePropertyNames();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties();
  const properties_1 = /* @__PURE__ */ requireProperties$1();
  const patternProperties_1 = /* @__PURE__ */ requirePatternProperties();
  const not_1 = /* @__PURE__ */ requireNot();
  const anyOf_1 = /* @__PURE__ */ requireAnyOf();
  const oneOf_1 = /* @__PURE__ */ requireOneOf();
  const allOf_1 = /* @__PURE__ */ requireAllOf();
  const if_1 = /* @__PURE__ */ require_if();
  const thenElse_1 = /* @__PURE__ */ requireThenElse();
  function getApplicator(draft2020 = false) {
    const applicator2 = [
      // any
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      // object
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator2.push(prefixItems_1.default, items2020_1.default);
    else
      applicator2.push(additionalItems_1.default, items_1.default);
    applicator2.push(contains_1.default);
    return applicator2;
  }
  applicator.default = getApplicator;
  return applicator;
}
var format$1 = {};
var format = {};
var hasRequiredFormat$1;
function requireFormat$1() {
  if (hasRequiredFormat$1) return format;
  hasRequiredFormat$1 = 1;
  Object.defineProperty(format, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format2 = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
          return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  format.default = def;
  return format;
}
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format$1;
  hasRequiredFormat = 1;
  Object.defineProperty(format$1, "__esModule", { value: true });
  const format_1 = /* @__PURE__ */ requireFormat$1();
  const format2 = [format_1.default];
  format$1.default = format2;
  return format$1;
}
var metadata$1 = {};
var hasRequiredMetadata$1;
function requireMetadata$1() {
  if (hasRequiredMetadata$1) return metadata$1;
  hasRequiredMetadata$1 = 1;
  Object.defineProperty(metadata$1, "__esModule", { value: true });
  metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
  metadata$1.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  metadata$1.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
  return metadata$1;
}
var hasRequiredDraft7;
function requireDraft7() {
  if (hasRequiredDraft7) return draft7;
  hasRequiredDraft7 = 1;
  Object.defineProperty(draft7, "__esModule", { value: true });
  const core_1 = /* @__PURE__ */ requireCore();
  const validation_1 = /* @__PURE__ */ requireValidation();
  const applicator_1 = /* @__PURE__ */ requireApplicator();
  const format_1 = /* @__PURE__ */ requireFormat();
  const metadata_1 = /* @__PURE__ */ requireMetadata$1();
  const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  draft7.default = draft7Vocabularies;
  return draft7;
}
var discriminator$1 = {};
var types$3 = {};
var hasRequiredTypes$3;
function requireTypes$3() {
  if (hasRequiredTypes$3) return types$3;
  hasRequiredTypes$3 = 1;
  Object.defineProperty(types$3, "__esModule", { value: true });
  types$3.DiscrError = void 0;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (types$3.DiscrError = DiscrError = {}));
  return types$3;
}
var hasRequiredDiscriminator$1;
function requireDiscriminator$1() {
  if (hasRequiredDiscriminator$1) return discriminator$1;
  hasRequiredDiscriminator$1 = 1;
  Object.defineProperty(discriminator$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const types_1 = /* @__PURE__ */ requireTypes$3();
  const compile_1 = /* @__PURE__ */ requireCompile();
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error2 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error2,
    code(cxt) {
      const { gen, data, schema, parentSchema, it } = cxt;
      const { oneOf: oneOf2 } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf2)
        throw new Error("discriminator: requires oneOf keyword");
      const valid2 = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid2);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid2, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0; i < oneOf2.length; i++) {
          let sch = oneOf2[i];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            const ref2 = sch.$ref;
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === void 0)
              throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
          }
          const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  discriminator$1.default = def;
  return discriminator$1;
}
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type$1 = ["object", "boolean"];
const properties$1 = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type: type$1,
  properties: properties$1,
  "default": true
};
var hasRequiredAjv;
function requireAjv() {
  if (hasRequiredAjv) return ajv.exports;
  hasRequiredAjv = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    const core_1 = /* @__PURE__ */ requireCore$1();
    const draft7_1 = /* @__PURE__ */ requireDraft7();
    const discriminator_1 = /* @__PURE__ */ requireDiscriminator$1();
    const draft7MetaSchema = require$$3;
    const META_SUPPORT_DATA = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    exports$1.Ajv = Ajv;
    module.exports = exports$1 = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv;
    var validate_1 = /* @__PURE__ */ requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = /* @__PURE__ */ requireValidation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = /* @__PURE__ */ requireRef_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(ajv, ajv.exports);
  return ajv.exports;
}
var jtd$1 = { exports: {} };
var jtd = {};
var ref = {};
var metadata = {};
var hasRequiredMetadata;
function requireMetadata() {
  if (hasRequiredMetadata) return metadata;
  hasRequiredMetadata = 1;
  Object.defineProperty(metadata, "__esModule", { value: true });
  metadata.checkMetadata = void 0;
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "metadata",
    schemaType: "object",
    code(cxt) {
      checkMetadata(cxt);
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid2 = gen.name("valid");
      cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid2);
      cxt.ok(valid2);
    }
  };
  function checkMetadata({ it, keyword: keyword2 }, metadata2) {
    if (it.jtdMetadata !== metadata2) {
      throw new Error(`JTD: "${keyword2}" cannot be used in this schema location`);
    }
  }
  metadata.checkMetadata = checkMetadata;
  metadata.default = def;
  return metadata;
}
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  Object.defineProperty(ref, "__esModule", { value: true });
  ref.hasRef = void 0;
  const compile_1 = /* @__PURE__ */ requireCompile();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const names_1 = /* @__PURE__ */ requireNames();
  const ref_1 = /* @__PURE__ */ requireRef$1();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const def = {
    keyword: "ref",
    schemaType: "string",
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema: ref2, parentSchema, it } = cxt;
      const { schemaEnv: { root } } = it;
      const valid2 = gen.name("valid");
      if (parentSchema.nullable) {
        gen.var(valid2, (0, codegen_1._)`${data} === null`);
        gen.if((0, codegen_1.not)(valid2), validateJtdRef);
      } else {
        gen.var(valid2, false);
        validateJtdRef();
      }
      cxt.ok(valid2);
      function validateJtdRef() {
        var _a2;
        const refSchema = (_a2 = root.schema.definitions) === null || _a2 === void 0 ? void 0 : _a2[ref2];
        if (!refSchema) {
          throw new ref_error_1.default(it.opts.uriResolver, "", ref2, `No definition ${ref2}`);
        }
        if (hasRef(refSchema) || !it.opts.inlineRefs)
          callValidate(refSchema);
        else
          inlineRefSchema(refSchema);
      }
      function callValidate(schema) {
        const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref2}` }));
        const v = (0, ref_1.getValidate)(cxt, sch);
        const errsCount = gen.const("_errs", names_1.default.errors);
        (0, ref_1.callRef)(cxt, v, sch, sch.$async);
        gen.assign(valid2, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function inlineRefSchema(schema) {
        const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
        cxt.subschema({
          schema,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: `/definitions/${ref2}`
        }, valid2);
      }
    }
  };
  function hasRef(schema) {
    for (const key in schema) {
      let sch;
      if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  ref.hasRef = hasRef;
  ref.default = def;
  return ref;
}
var type = {};
var timestamp = {};
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp;
  hasRequiredTimestamp = 1;
  Object.defineProperty(timestamp, "__esModule", { value: true });
  const DT_SEPARATOR = /t|\s/i;
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function validTimestamp(str, allowDate) {
    const dt = str.split(DT_SEPARATOR);
    return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
  }
  timestamp.default = validTimestamp;
  function validDate(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const y = +matches[1];
    const m = +matches[2];
    const d = +matches[3];
    return m >= 1 && m <= 12 && d >= 1 && (d <= DAYS[m] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
    m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
  }
  function validTime(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tzH = +(matches[4] || 0);
    const tzM = +(matches[5] || 0);
    return hr <= 23 && min <= 59 && sec <= 59 || // leap second
    hr - tzH === 23 && min - tzM === 59 && sec === 60;
  }
  validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
  return timestamp;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.typeErrorParams = error.typeErrorMessage = error.typeError = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  function typeError(t) {
    return {
      message: (cxt) => typeErrorMessage(cxt, t),
      params: (cxt) => typeErrorParams(cxt, t)
    };
  }
  error.typeError = typeError;
  function typeErrorMessage({ parentSchema }, t) {
    return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
  }
  error.typeErrorMessage = typeErrorMessage;
  function typeErrorParams({ parentSchema }, t) {
    return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
  }
  error.typeErrorParams = typeErrorParams;
  return error;
}
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.intRange = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const timestamp_1 = /* @__PURE__ */ requireTimestamp();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const metadata_1 = /* @__PURE__ */ requireMetadata();
    const error_1 = /* @__PURE__ */ requireError();
    exports$1.intRange = {
      int8: [-128, 127, 3],
      uint8: [0, 255, 3],
      int16: [-32768, 32767, 5],
      uint16: [0, 65535, 5],
      int32: [-2147483648, 2147483647, 10],
      uint32: [0, 4294967295, 10]
    };
    const error2 = {
      message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
      params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
    };
    function timestampCode(cxt) {
      const { gen, data, it } = cxt;
      const { timestamp: timestamp2, allowDate } = it.opts;
      if (timestamp2 === "date")
        return (0, codegen_1._)`${data} instanceof Date `;
      const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
      const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
      const validString = (0, codegen_1._)`typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
      return timestamp2 === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data} instanceof Date`, validString);
    }
    const def = {
      keyword: "type",
      schemaType: "string",
      error: error2,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { data, schema, parentSchema, it } = cxt;
        let cond;
        switch (schema) {
          case "boolean":
          case "string":
            cond = (0, codegen_1._)`typeof ${data} == ${schema}`;
            break;
          case "timestamp": {
            cond = timestampCode(cxt);
            break;
          }
          case "float32":
          case "float64":
            cond = (0, codegen_1._)`typeof ${data} == "number"`;
            break;
          default: {
            const sch = schema;
            cond = (0, codegen_1._)`typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
            if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
              if (sch === "uint32")
                cond = (0, codegen_1._)`${cond} && ${data} >= 0`;
            } else {
              const [min, max] = exports$1.intRange[sch];
              cond = (0, codegen_1._)`${cond} && ${data} >= ${min} && ${data} <= ${max}`;
            }
          }
        }
        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data} === null`, cond) : cond);
      }
    };
    exports$1.default = def;
  })(type);
  return type;
}
var _enum$1 = {};
var nullable$1 = {};
var hasRequiredNullable;
function requireNullable() {
  if (hasRequiredNullable) return nullable$1;
  hasRequiredNullable = 1;
  Object.defineProperty(nullable$1, "__esModule", { value: true });
  nullable$1.checkNullableObject = nullable$1.checkNullable = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
    const valid2 = gen.name("valid");
    if (parentSchema.nullable) {
      gen.let(valid2, (0, codegen_1._)`${data} === null`);
      cond = (0, codegen_1.not)(valid2);
    } else {
      gen.let(valid2, false);
    }
    return [valid2, cond];
  }
  nullable$1.checkNullable = checkNullable;
  function checkNullableObject(cxt, cond) {
    const [valid2, cond_] = checkNullable(cxt, cond);
    return [valid2, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
  }
  nullable$1.checkNullableObject = checkNullableObject;
  return nullable$1;
}
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum$1;
  hasRequired_enum = 1;
  Object.defineProperty(_enum$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const nullable_1 = /* @__PURE__ */ requireNullable();
  const error2 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  const def = {
    keyword: "enum",
    schemaType: "array",
    error: error2,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, schemaValue, parentSchema, it } = cxt;
      if (schema.length === 0)
        throw new Error("enum must have non-empty array");
      if (schema.length !== new Set(schema).size)
        throw new Error("enum items must be unique");
      let valid2;
      const isString2 = (0, codegen_1._)`typeof ${data} == "string"`;
      if (schema.length >= it.opts.loopEnum) {
        let cond;
        [valid2, cond] = (0, nullable_1.checkNullable)(cxt, isString2);
        gen.if(cond, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        valid2 = (0, codegen_1.and)(isString2, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data} === ${value}`)));
        if (parentSchema.nullable)
          valid2 = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid2);
      }
      cxt.pass(valid2);
      function loopEnum() {
        gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._)`${valid2} = ${data} === ${v}`, () => gen.break()));
      }
    }
  };
  _enum$1.default = def;
  return _enum$1;
}
var elements = {};
var hasRequiredElements;
function requireElements() {
  if (hasRequiredElements) return elements;
  hasRequiredElements = 1;
  Object.defineProperty(elements, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const nullable_1 = /* @__PURE__ */ requireNullable();
  const error_1 = /* @__PURE__ */ requireError();
  const def = {
    keyword: "elements",
    schemaType: "object",
    error: (0, error_1.typeError)("array"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const [valid2] = (0, nullable_1.checkNullable)(cxt);
      gen.if((0, codegen_1.not)(valid2), () => gen.if((0, codegen_1._)`Array.isArray(${data})`, () => gen.assign(valid2, (0, code_1.validateArray)(cxt)), () => cxt.error()));
      cxt.ok(valid2);
    }
  };
  elements.default = def;
  return elements;
}
var properties = {};
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties;
  hasRequiredProperties = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateProperties = exports$1.error = void 0;
    const code_1 = /* @__PURE__ */ requireCode();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const metadata_1 = /* @__PURE__ */ requireMetadata();
    const nullable_1 = /* @__PURE__ */ requireNullable();
    const error_1 = /* @__PURE__ */ requireError();
    var PropError;
    (function(PropError2) {
      PropError2["Additional"] = "additional";
      PropError2["Missing"] = "missing";
    })(PropError || (PropError = {}));
    exports$1.error = {
      message: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    const def = {
      keyword: "properties",
      schemaType: "object",
      error: exports$1.error,
      code: validateProperties
    };
    function validateProperties(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, parentSchema, it } = cxt;
      const { additionalProperties: additionalProperties2, nullable: nullable2 } = parentSchema;
      if (it.jtdDiscriminator && nullable2)
        throw new Error("JTD: nullable inside discriminator mapping");
      if (commonProperties()) {
        throw new Error("JTD: properties and optionalProperties have common members");
      }
      const [allProps, properties2] = schemaProperties("properties");
      const [allOptProps, optProperties] = schemaProperties("optionalProperties");
      if (properties2.length === 0 && optProperties.length === 0 && additionalProperties2) {
        return;
      }
      const [valid2, cond] = it.jtdDiscriminator === void 0 ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let("valid", false), true];
      gen.if(cond, () => gen.assign(valid2, true).block(() => {
        validateProps(properties2, "properties", true);
        validateProps(optProperties, "optionalProperties");
        if (!additionalProperties2)
          validateAdditional();
      }));
      cxt.pass(valid2);
      function commonProperties() {
        const props = parentSchema.properties;
        const optProps = parentSchema.optionalProperties;
        if (!(props && optProps))
          return false;
        for (const p in props) {
          if (Object.prototype.hasOwnProperty.call(optProps, p))
            return true;
        }
        return false;
      }
      function schemaProperties(keyword2) {
        const schema = parentSchema[keyword2];
        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
          throw new Error(`JTD: discriminator tag used in ${keyword2}`);
        }
        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        return [allPs, ps];
      }
      function validateProps(props, keyword2, required2) {
        const _valid = gen.var("valid");
        for (const prop of props) {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword2, _valid), () => missingProperty(prop));
          cxt.ok(_valid);
        }
        function missingProperty(prop) {
          if (required2) {
            gen.assign(_valid, false);
            cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
          } else {
            gen.assign(_valid, true);
          }
        }
      }
      function applyPropertySchema(prop, keyword2, _valid) {
        cxt.subschema({
          keyword: keyword2,
          schemaProp: prop,
          dataProp: prop
        }, _valid);
      }
      function validateAdditional() {
        gen.forIn("key", data, (key) => {
          const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
          const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
          const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
          gen.if(extra, () => {
            if (it.opts.removeAdditional) {
              gen.code((0, codegen_1._)`delete ${data}[${key}]`);
            } else {
              cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
              if (!it.opts.allErrors)
                gen.break();
            }
          });
        });
      }
      function isAdditional(key, props, keyword2, jtdDiscriminator) {
        let additional;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword2], keyword2);
          additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
          if (jtdDiscriminator !== void 0) {
            additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
          }
        } else if (props.length || jtdDiscriminator !== void 0) {
          const ps = jtdDiscriminator === void 0 ? props : [jtdDiscriminator].concat(props);
          additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`));
        } else {
          additional = true;
        }
        return additional;
      }
    }
    exports$1.validateProperties = validateProperties;
    exports$1.default = def;
  })(properties);
  return properties;
}
var optionalProperties = {};
var hasRequiredOptionalProperties;
function requireOptionalProperties() {
  if (hasRequiredOptionalProperties) return optionalProperties;
  hasRequiredOptionalProperties = 1;
  Object.defineProperty(optionalProperties, "__esModule", { value: true });
  const properties_1 = /* @__PURE__ */ requireProperties();
  const def = {
    keyword: "optionalProperties",
    schemaType: "object",
    error: properties_1.error,
    code(cxt) {
      if (cxt.parentSchema.properties)
        return;
      (0, properties_1.validateProperties)(cxt);
    }
  };
  optionalProperties.default = def;
  return optionalProperties;
}
var discriminator = {};
var hasRequiredDiscriminator;
function requireDiscriminator() {
  if (hasRequiredDiscriminator) return discriminator;
  hasRequiredDiscriminator = 1;
  Object.defineProperty(discriminator, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const nullable_1 = /* @__PURE__ */ requireNullable();
  const error_1 = /* @__PURE__ */ requireError();
  const types_1 = /* @__PURE__ */ requireTypes$3();
  const error2 = {
    message: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
    }
  };
  const def = {
    keyword: "discriminator",
    schemaType: "string",
    implements: ["mapping"],
    error: error2,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, parentSchema } = cxt;
      const [valid2, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
      gen.if(cond);
      validateDiscriminator();
      gen.elseIf((0, codegen_1.not)(valid2));
      cxt.error();
      gen.endIf();
      cxt.ok(valid2);
      function validateDiscriminator() {
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);
        gen.if((0, codegen_1._)`${tag} === undefined`);
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
        gen.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
        validateMapping(tag);
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
        gen.endIf();
      }
      function validateMapping(tag) {
        gen.if(false);
        for (const tagValue in parentSchema.mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid2, applyTagSchema(tagValue));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        cxt.subschema({
          keyword: "mapping",
          schemaProp,
          jtdDiscriminator: schema
        }, _valid);
        return _valid;
      }
    }
  };
  discriminator.default = def;
  return discriminator;
}
var values = {};
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values;
  hasRequiredValues = 1;
  Object.defineProperty(values, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const nullable_1 = /* @__PURE__ */ requireNullable();
  const error_1 = /* @__PURE__ */ requireError();
  const def = {
    keyword: "values",
    schemaType: "object",
    error: (0, error_1.typeError)("object"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, it } = cxt;
      const [valid2, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid2)), () => cxt.error());
      } else {
        gen.if(cond);
        gen.assign(valid2, validateMap());
        gen.elseIf((0, codegen_1.not)(valid2));
        cxt.error();
        gen.endIf();
      }
      cxt.ok(valid2);
      function validateMap() {
        const _valid = gen.name("valid");
        if (it.allErrors) {
          const validMap = gen.let("valid", true);
          validateValues(() => gen.assign(validMap, false));
          return validMap;
        }
        gen.var(_valid, true);
        validateValues(() => gen.break());
        return _valid;
        function validateValues(notValid) {
          gen.forIn("key", data, (key) => {
            cxt.subschema({
              keyword: "values",
              dataProp: key,
              dataPropType: util_1.Type.Str
            }, _valid);
            gen.if((0, codegen_1.not)(_valid), notValid);
          });
        }
      }
    }
  };
  values.default = def;
  return values;
}
var union$1 = {};
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion) return union$1;
  hasRequiredUnion = 1;
  Object.defineProperty(union$1, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const def = {
    keyword: "union",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in union" }
  };
  union$1.default = def;
  return union$1;
}
var hasRequiredJtd$1;
function requireJtd$1() {
  if (hasRequiredJtd$1) return jtd;
  hasRequiredJtd$1 = 1;
  Object.defineProperty(jtd, "__esModule", { value: true });
  const ref_1 = /* @__PURE__ */ requireRef();
  const type_1 = /* @__PURE__ */ requireType();
  const enum_1 = /* @__PURE__ */ require_enum();
  const elements_1 = /* @__PURE__ */ requireElements();
  const properties_1 = /* @__PURE__ */ requireProperties();
  const optionalProperties_1 = /* @__PURE__ */ requireOptionalProperties();
  const discriminator_1 = /* @__PURE__ */ requireDiscriminator();
  const values_1 = /* @__PURE__ */ requireValues();
  const union_1 = /* @__PURE__ */ requireUnion();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const jtdVocabulary = [
    "definitions",
    ref_1.default,
    type_1.default,
    enum_1.default,
    elements_1.default,
    properties_1.default,
    optionalProperties_1.default,
    discriminator_1.default,
    values_1.default,
    union_1.default,
    metadata_1.default,
    { keyword: "additionalProperties", schemaType: "boolean" },
    { keyword: "nullable", schemaType: "boolean" }
  ];
  jtd.default = jtdVocabulary;
  return jtd;
}
var jtdSchema = {};
var hasRequiredJtdSchema;
function requireJtdSchema() {
  if (hasRequiredJtdSchema) return jtdSchema;
  hasRequiredJtdSchema = 1;
  Object.defineProperty(jtdSchema, "__esModule", { value: true });
  const shared = (root) => {
    const sch = {
      nullable: { type: "boolean" },
      metadata: {
        optionalProperties: {
          union: { elements: { ref: "schema" } }
        },
        additionalProperties: true
      }
    };
    if (root)
      sch.definitions = { values: { ref: "schema" } };
    return sch;
  };
  const emptyForm = (root) => ({
    optionalProperties: shared(root)
  });
  const refForm = (root) => ({
    properties: {
      ref: { type: "string" }
    },
    optionalProperties: shared(root)
  });
  const typeForm = (root) => ({
    properties: {
      type: {
        enum: [
          "boolean",
          "timestamp",
          "string",
          "float32",
          "float64",
          "int8",
          "uint8",
          "int16",
          "uint16",
          "int32",
          "uint32"
        ]
      }
    },
    optionalProperties: shared(root)
  });
  const enumForm = (root) => ({
    properties: {
      enum: { elements: { type: "string" } }
    },
    optionalProperties: shared(root)
  });
  const elementsForm = (root) => ({
    properties: {
      elements: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  const propertiesForm = (root) => ({
    properties: {
      properties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      optionalProperties: { values: { ref: "schema" } },
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  const optionalPropertiesForm = (root) => ({
    properties: {
      optionalProperties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  const discriminatorForm = (root) => ({
    properties: {
      discriminator: { type: "string" },
      mapping: {
        values: {
          metadata: {
            union: [propertiesForm(false), optionalPropertiesForm(false)]
          }
        }
      }
    },
    optionalProperties: shared(root)
  });
  const valuesForm = (root) => ({
    properties: {
      values: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  const schema = (root) => ({
    metadata: {
      union: [
        emptyForm,
        refForm,
        typeForm,
        enumForm,
        elementsForm,
        propertiesForm,
        optionalPropertiesForm,
        discriminatorForm,
        valuesForm
      ].map((s) => s(root))
    }
  });
  const jtdMetaSchema = {
    definitions: {
      schema: schema(false)
    },
    ...schema(true)
  };
  jtdSchema.default = jtdMetaSchema;
  return jtdSchema;
}
var serialize = {};
var types$2 = {};
var hasRequiredTypes$2;
function requireTypes$2() {
  if (hasRequiredTypes$2) return types$2;
  hasRequiredTypes$2 = 1;
  Object.defineProperty(types$2, "__esModule", { value: true });
  types$2.jtdForms = void 0;
  types$2.jtdForms = [
    "elements",
    "values",
    "discriminator",
    "properties",
    "optionalProperties",
    "enum",
    "type",
    "ref"
  ];
  return types$2;
}
var quote = {};
var hasRequiredQuote;
function requireQuote() {
  if (hasRequiredQuote) return quote;
  hasRequiredQuote = 1;
  Object.defineProperty(quote, "__esModule", { value: true });
  const rxEscapable = (
    // eslint-disable-next-line no-control-regex, no-misleading-character-class
    /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
  );
  const escaped = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  };
  function quote$1(s) {
    rxEscapable.lastIndex = 0;
    return '"' + (rxEscapable.test(s) ? s.replace(rxEscapable, (a) => {
      const c = escaped[a];
      return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
    }) : s) + '"';
  }
  quote.default = quote$1;
  quote$1.code = 'require("ajv/dist/runtime/quote").default';
  return quote;
}
var hasRequiredSerialize;
function requireSerialize() {
  if (hasRequiredSerialize) return serialize;
  hasRequiredSerialize = 1;
  Object.defineProperty(serialize, "__esModule", { value: true });
  const types_1 = /* @__PURE__ */ requireTypes$2();
  const __1 = /* @__PURE__ */ requireCompile();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const names_1 = /* @__PURE__ */ requireNames();
  const code_1 = /* @__PURE__ */ requireCode();
  const ref_1 = /* @__PURE__ */ requireRef();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const quote_1 = /* @__PURE__ */ requireQuote();
  const genSerialize = {
    elements: serializeElements,
    values: serializeValues,
    discriminator: serializeDiscriminator,
    properties: serializeProperties,
    optionalProperties: serializeProperties,
    enum: serializeString,
    type: serializeType,
    ref: serializeRef
  };
  function compileSerializer(sch, definitions2) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const serializeName = gen.scopeName("serialize");
    const cxt = {
      self: this,
      gen,
      schema: sch.schema,
      schemaEnv: sch,
      definitions: definitions2,
      data: names_1.default.data
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.serializeName = serializeName;
      gen.func(serializeName, names_1.default.data, false, () => {
        gen.let(names_1.default.json, (0, codegen_1.str)``);
        serializeCode(cxt);
        gen.return(names_1.default.json);
      });
      gen.optimize(this.opts.code.optimize);
      const serializeFuncCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
      const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
      const serialize2 = makeSerialize(this.scope.get());
      this.scope.value(serializeName, { ref: serialize2 });
      sch.serialize = serialize2;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling serializer, function code:", sourceCode);
      delete sch.serialize;
      delete sch.serializeName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  }
  serialize.default = compileSerializer;
  function serializeCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
  }
  function serializeNullable(cxt, serializeForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
      return serializeForm(cxt);
    gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
  }
  function serializeElements(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`[`);
    const first = gen.let("first", true);
    gen.forOf("el", data, (el) => {
      addComma(cxt, first);
      serializeCode({ ...cxt, schema: schema.elements, data: el });
    });
    gen.add(names_1.default.json, (0, codegen_1.str)`]`);
  }
  function serializeValues(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`{`);
    const first = gen.let("first", true);
    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeKeyValue(cxt, key, schema, first) {
    const { gen, data } = cxt;
    addComma(cxt, first);
    serializeString({ ...cxt, data: key });
    gen.add(names_1.default.json, (0, codegen_1.str)`:`);
    const value = gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
    serializeCode({ ...cxt, schema, data: value });
  }
  function serializeDiscriminator(cxt) {
    const { gen, schema, data } = cxt;
    const { discriminator: discriminator2 } = schema;
    gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator2)}:`);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator2)}`);
    serializeString({ ...cxt, data: tag });
    gen.if(false);
    for (const tagValue in schema.mapping) {
      gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      const sch = schema.mapping[tagValue];
      serializeSchemaProperties({ ...cxt, schema: sch }, discriminator2);
    }
    gen.endIf();
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeProperties(cxt) {
    const { gen } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`{`);
    serializeSchemaProperties(cxt);
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeSchemaProperties(cxt, discriminator2) {
    const { gen, schema, data } = cxt;
    const { properties: properties2, optionalProperties: optionalProperties2 } = schema;
    const props = keys(properties2);
    const optProps = keys(optionalProperties2);
    const allProps = allProperties(props.concat(optProps));
    let first = !discriminator2;
    let firstProp;
    for (const key of props) {
      if (first)
        first = false;
      else
        gen.add(names_1.default.json, (0, codegen_1.str)`,`);
      serializeProperty(key, properties2[key], keyValue(key));
    }
    if (first)
      firstProp = gen.let("first", true);
    for (const key of optProps) {
      const value = keyValue(key);
      gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
        addComma(cxt, firstProp);
        serializeProperty(key, optionalProperties2[key], value);
      });
    }
    if (schema.additionalProperties) {
      gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
    }
    function keys(ps) {
      return ps ? Object.keys(ps) : [];
    }
    function allProperties(ps) {
      if (discriminator2)
        ps.push(discriminator2);
      if (new Set(ps).size !== ps.length) {
        throw new Error("JTD: properties/optionalProperties/disciminator overlap");
      }
      return ps;
    }
    function keyValue(key) {
      return gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
    }
    function serializeProperty(key, propSchema, value) {
      gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
      serializeCode({ ...cxt, schema: propSchema, data: value });
    }
    function isAdditional(key, ps) {
      return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`)) : true;
    }
  }
  function serializeType(cxt) {
    const { gen, schema, data } = cxt;
    switch (schema.type) {
      case "boolean":
        gen.add(names_1.default.json, (0, codegen_1._)`${data} ? "true" : "false"`);
        break;
      case "string":
        serializeString(cxt);
        break;
      case "timestamp":
        gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
        break;
      default:
        serializeNumber(cxt);
    }
  }
  function serializeString({ gen, data }) {
    gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
  }
  function serializeNumber({ gen, data, self: self2 }) {
    const condition = (0, codegen_1._)`${data} === Infinity || ${data} === -Infinity || ${data} !== ${data}`;
    if (self2.opts.specialNumbers === void 0 || self2.opts.specialNumbers === "fast") {
      gen.add(names_1.default.json, (0, codegen_1._)`"" + ${data}`);
    } else {
      gen.if(condition, () => gen.add(names_1.default.json, (0, codegen_1._)`null`), () => gen.add(names_1.default.json, (0, codegen_1._)`"" + ${data}`));
    }
  }
  function serializeRef(cxt) {
    const { gen, self: self2, data, definitions: definitions2, schema, schemaEnv } = cxt;
    const { ref: ref2 } = schema;
    const refSchema = definitions2[ref2];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref2, `No definition ${ref2}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return serializeCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions2);
    gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);
  }
  function getSerialize(gen, sch) {
    return sch.serialize ? gen.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
  }
  function serializeEmpty({ gen, data }) {
    gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);
  }
  function addComma({ gen }, first) {
    if (first) {
      gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));
    } else {
      gen.add(names_1.default.json, (0, codegen_1.str)`,`);
    }
  }
  return serialize;
}
var parse$1 = {};
var parseJson = {};
var hasRequiredParseJson;
function requireParseJson() {
  if (hasRequiredParseJson) return parseJson;
  hasRequiredParseJson = 1;
  Object.defineProperty(parseJson, "__esModule", { value: true });
  parseJson.parseJsonString = parseJson.parseJsonNumber = parseJson.parseJson = void 0;
  const rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
  function parseJson$1(s, pos) {
    let endPos;
    parseJson$1.message = void 0;
    let matches;
    if (pos)
      s = s.slice(pos);
    try {
      parseJson$1.position = pos + s.length;
      return JSON.parse(s);
    } catch (e) {
      matches = rxParseJson.exec(e.message);
      if (!matches) {
        parseJson$1.message = "unexpected end";
        return void 0;
      }
      endPos = +matches[1];
      const c = s[endPos];
      s = s.slice(0, endPos);
      parseJson$1.position = pos + endPos;
      try {
        return JSON.parse(s);
      } catch (e1) {
        parseJson$1.message = `unexpected token ${c}`;
        return void 0;
      }
    }
  }
  parseJson.parseJson = parseJson$1;
  parseJson$1.message = void 0;
  parseJson$1.position = 0;
  parseJson$1.code = 'require("ajv/dist/runtime/parseJson").parseJson';
  function parseJsonNumber(s, pos, maxDigits) {
    let numStr = "";
    let c;
    parseJsonNumber.message = void 0;
    if (s[pos] === "-") {
      numStr += "-";
      pos++;
    }
    if (s[pos] === "0") {
      numStr += "0";
      pos++;
    } else {
      if (!parseDigits(maxDigits)) {
        errorMessage();
        return void 0;
      }
    }
    if (maxDigits) {
      parseJsonNumber.position = pos;
      return +numStr;
    }
    if (s[pos] === ".") {
      numStr += ".";
      pos++;
      if (!parseDigits()) {
        errorMessage();
        return void 0;
      }
    }
    if (c = s[pos], c === "e" || c === "E") {
      numStr += "e";
      pos++;
      if (c = s[pos], c === "+" || c === "-") {
        numStr += c;
        pos++;
      }
      if (!parseDigits()) {
        errorMessage();
        return void 0;
      }
    }
    parseJsonNumber.position = pos;
    return +numStr;
    function parseDigits(maxLen) {
      let digit = false;
      while (c = s[pos], c >= "0" && c <= "9" && (maxLen === void 0 || maxLen-- > 0)) {
        digit = true;
        numStr += c;
        pos++;
      }
      return digit;
    }
    function errorMessage() {
      parseJsonNumber.position = pos;
      parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
    }
  }
  parseJson.parseJsonNumber = parseJsonNumber;
  parseJsonNumber.message = void 0;
  parseJsonNumber.position = 0;
  parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
  const escapedChars = {
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    '"': '"',
    "/": "/",
    "\\": "\\"
  };
  const CODE_A = "a".charCodeAt(0);
  const CODE_0 = "0".charCodeAt(0);
  function parseJsonString(s, pos) {
    let str = "";
    let c;
    parseJsonString.message = void 0;
    while (true) {
      c = s[pos++];
      if (c === '"')
        break;
      if (c === "\\") {
        c = s[pos];
        if (c in escapedChars) {
          str += escapedChars[c];
          pos++;
        } else if (c === "u") {
          pos++;
          let count = 4;
          let code2 = 0;
          while (count--) {
            code2 <<= 4;
            c = s[pos];
            if (c === void 0) {
              errorMessage("unexpected end");
              return void 0;
            }
            c = c.toLowerCase();
            if (c >= "a" && c <= "f") {
              code2 += c.charCodeAt(0) - CODE_A + 10;
            } else if (c >= "0" && c <= "9") {
              code2 += c.charCodeAt(0) - CODE_0;
            } else {
              errorMessage(`unexpected token ${c}`);
              return void 0;
            }
            pos++;
          }
          str += String.fromCharCode(code2);
        } else {
          errorMessage(`unexpected token ${c}`);
          return void 0;
        }
      } else if (c === void 0) {
        errorMessage("unexpected end");
        return void 0;
      } else {
        if (c.charCodeAt(0) >= 32) {
          str += c;
        } else {
          errorMessage(`unexpected token ${c}`);
          return void 0;
        }
      }
    }
    parseJsonString.position = pos;
    return str;
    function errorMessage(msg) {
      parseJsonString.position = pos;
      parseJsonString.message = msg;
    }
  }
  parseJson.parseJsonString = parseJsonString;
  parseJsonString.message = void 0;
  parseJsonString.position = 0;
  parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
  return parseJson;
}
var hasRequiredParse$2;
function requireParse$2() {
  if (hasRequiredParse$2) return parse$1;
  hasRequiredParse$2 = 1;
  Object.defineProperty(parse$1, "__esModule", { value: true });
  const types_1 = /* @__PURE__ */ requireTypes$2();
  const __1 = /* @__PURE__ */ requireCompile();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const names_1 = /* @__PURE__ */ requireNames();
  const code_1 = /* @__PURE__ */ requireCode();
  const ref_1 = /* @__PURE__ */ requireRef();
  const type_1 = /* @__PURE__ */ requireType();
  const parseJson_1 = /* @__PURE__ */ requireParseJson();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const timestamp_1 = /* @__PURE__ */ requireTimestamp();
  const genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef
  };
  function compileParser(sch, definitions2) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const parseName = gen.scopeName("parse");
    const cxt = {
      self: this,
      gen,
      schema: sch.schema,
      schemaEnv: sch,
      definitions: definitions2,
      data: names_1.default.data,
      parseName,
      char: gen.name("c")
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.parseName = parseName;
      parserFunction(cxt);
      gen.optimize(this.opts.code.optimize);
      const parseFuncCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
      const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
      const parse2 = makeParse(this.scope.get());
      this.scope.value(parseName, { ref: parse2 });
      sch.parse = parse2;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling parser, function code:", sourceCode);
      delete sch.parse;
      delete sch.parseName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  }
  parse$1.default = compileParser;
  const undef = (0, codegen_1._)`undefined`;
  function parserFunction(cxt) {
    const { gen, parseName, char } = cxt;
    gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
      gen.let(names_1.default.data);
      gen.let(char);
      gen.assign((0, codegen_1._)`${parseName}.message`, undef);
      gen.assign((0, codegen_1._)`${parseName}.position`, undef);
      gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
      gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
      parseCode(cxt);
      skipWhitespace(cxt);
      gen.if(names_1.default.jsonPart, () => {
        gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
        gen.return(names_1.default.data);
      });
      gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
      jsonSyntaxError(cxt);
    });
  }
  function parseCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    if (form)
      parseNullable(cxt, genParse[form]);
    else
      parseEmpty(cxt);
  }
  const parseBoolean2 = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
  function parseNullable(cxt, parseForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
      return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
  }
  function parseElements(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "[");
    const ix = gen.let("i", 0);
    gen.assign(data, (0, codegen_1._)`[]`);
    parseItems(cxt, "]", () => {
      const el = gen.let("el");
      parseCode({ ...cxt, schema: schema.elements, data: el });
      gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);
    });
  }
  function parseValues(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
  }
  function parseItems(cxt, endToken, block) {
    tryParseItems(cxt, endToken, block);
    parseToken(cxt, endToken);
  }
  function tryParseItems(cxt, endToken, block) {
    const { gen } = cxt;
    gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
      block();
      tryParseToken(cxt, ",", () => gen.break(), hasItem);
    });
    function hasItem() {
      tryParseToken(cxt, endToken, () => {
      }, jsonSyntaxError);
    }
  }
  function parseKeyValue(cxt, schema) {
    const { gen } = cxt;
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
  }
  function parseDiscriminator(cxt) {
    const { gen, data, schema } = cxt;
    const { discriminator: discriminator2, mapping } = schema;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    const startPos = gen.const("pos", names_1.default.jsonPos);
    const value = gen.let("value");
    const tag = gen.let("tag");
    tryParseItems(cxt, "}", () => {
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen.if(
        (0, codegen_1._)`${key} === ${discriminator2}`,
        () => {
          parseString({ ...cxt, data: tag });
          gen.assign((0, codegen_1._)`${data}[${key}]`, tag);
          gen.break();
        },
        () => parseEmpty({ ...cxt, data: value })
        // can be discarded/skipped
      );
    });
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((0, codegen_1._)`${tag} === undefined`);
    parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
    for (const tagValue in mapping) {
      gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator2);
    }
    gen.else();
    parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
    gen.endIf();
  }
  function parseProperties(cxt) {
    const { gen, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    parseSchemaProperties(cxt);
  }
  function parseSchemaProperties(cxt, discriminator2) {
    const { gen, schema, data } = cxt;
    const { properties: properties2, optionalProperties: optionalProperties2, additionalProperties: additionalProperties2 } = schema;
    parseItems(cxt, "}", () => {
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen.if(false);
      parseDefinedProperty(cxt, key, properties2);
      parseDefinedProperty(cxt, key, optionalProperties2);
      if (discriminator2) {
        gen.elseIf((0, codegen_1._)`${key} === ${discriminator2}`);
        const tag = gen.let("tag");
        parseString({ ...cxt, data: tag });
      }
      gen.else();
      if (additionalProperties2) {
        parseEmpty({ ...cxt, data: (0, codegen_1._)`${data}[${key}]` });
      } else {
        parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
      }
      gen.endIf();
    });
    if (properties2) {
      const hasProp = (0, code_1.hasPropFunc)(gen);
      const allProps = (0, codegen_1.and)(...Object.keys(properties2).map((p) => (0, codegen_1._)`${hasProp}.call(${data}, ${p})`));
      gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
    }
  }
  function parseDefinedProperty(cxt, key, schemas2 = {}) {
    const { gen } = cxt;
    for (const prop in schemas2) {
      gen.elseIf((0, codegen_1._)`${key} === ${prop}`);
      parsePropertyValue(cxt, key, schemas2[prop]);
    }
  }
  function parsePropertyValue(cxt, key, schema) {
    parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
  }
  function parseType(cxt) {
    const { gen, schema, data, self: self2 } = cxt;
    switch (schema.type) {
      case "boolean":
        parseBoolean2(cxt);
        break;
      case "string":
        parseString(cxt);
        break;
      case "timestamp": {
        parseString(cxt);
        const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
        const { allowDate, parseDate } = self2.opts;
        const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;
        const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;
        gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
        break;
      }
      case "float32":
      case "float64":
        parseNumber(cxt);
        break;
      default: {
        const t = schema.type;
        if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
          parseNumber(cxt, 16);
          if (t === "uint32") {
            gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        } else {
          const [min, max, maxDigits] = type_1.intRange[t];
          parseNumber(cxt, maxDigits);
          gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
        }
      }
    }
  }
  function parseString(cxt) {
    parseToken(cxt, '"');
    parseWith(cxt, parseJson_1.parseJsonString);
  }
  function parseEnum(cxt) {
    const { gen, data, schema } = cxt;
    const enumSch = schema.enum;
    parseToken(cxt, '"');
    gen.if(false);
    for (const value of enumSch) {
      const valueStr = JSON.stringify(value).slice(1);
      gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
      gen.assign(data, (0, codegen_1.str)`${value}`);
      gen.add(names_1.default.jsonPos, valueStr.length);
    }
    gen.else();
    jsonSyntaxError(cxt);
    gen.endIf();
  }
  function parseNumber(cxt, maxDigits) {
    const { gen } = cxt;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
  }
  function parseBooleanToken(bool, fail) {
    return (cxt) => {
      const { gen, data } = cxt;
      tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
    };
  }
  function parseRef(cxt) {
    const { gen, self: self2, definitions: definitions2, schema, schemaEnv } = cxt;
    const { ref: ref2 } = schema;
    const refSchema = definitions2[ref2];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref2, `No definition ${ref2}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return parseCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions2);
    partialParse(cxt, getParser(gen, sch), true);
  }
  function getParser(gen, sch) {
    return sch.parse ? gen.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.parse`;
  }
  function parseEmpty(cxt) {
    parseWith(cxt, parseJson_1.parseJson);
  }
  function parseWith(cxt, parseFunc, args) {
    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
  }
  function partialParse(cxt, parseFunc, args) {
    const { gen, data } = cxt;
    gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
    gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
    gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
  }
  function parseToken(cxt, tok) {
    tryParseToken(cxt, tok, jsonSyntaxError);
  }
  function tryParseToken(cxt, tok, fail, success) {
    const { gen } = cxt;
    const n = tok.length;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
      gen.add(names_1.default.jsonPos, n);
      success === null || success === void 0 ? void 0 : success(cxt);
    }, () => fail(cxt));
  }
  function skipWhitespace({ gen, char: c }) {
    gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
  }
  function jsonSlice(len) {
    return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
  }
  function jsonSyntaxError(cxt) {
    parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
  }
  function parsingError({ gen, parseName }, msg) {
    gen.assign((0, codegen_1._)`${parseName}.message`, msg);
    gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
    gen.return(undef);
  }
  return parse$1;
}
var hasRequiredJtd;
function requireJtd() {
  if (hasRequiredJtd) return jtd$1.exports;
  hasRequiredJtd = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    const core_1 = /* @__PURE__ */ requireCore$1();
    const jtd_1 = /* @__PURE__ */ requireJtd$1();
    const jtd_schema_1 = /* @__PURE__ */ requireJtdSchema();
    const serialize_1 = /* @__PURE__ */ requireSerialize();
    const parse_12 = /* @__PURE__ */ requireParse$2();
    const META_SCHEMA_ID = "JTD-meta-schema";
    class Ajv extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          jtd: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        this.addVocabulary(jtd_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
      compileSerializer(schema) {
        const sch = this._addSchema(schema);
        return sch.serialize || this._compileSerializer(sch);
      }
      compileParser(schema) {
        const sch = this._addSchema(schema);
        return sch.parse || this._compileParser(sch);
      }
      _compileSerializer(sch) {
        serialize_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.serialize)
          throw new Error("ajv implementation error");
        return sch.serialize;
      }
      _compileParser(sch) {
        parse_12.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.parse)
          throw new Error("ajv implementation error");
        return sch.parse;
      }
    }
    exports$1.Ajv = Ajv;
    module.exports = exports$1 = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv;
    var validate_1 = /* @__PURE__ */ requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = /* @__PURE__ */ requireValidation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = /* @__PURE__ */ requireRef_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(jtd$1, jtd$1.exports);
  return jtd$1.exports;
}
var defaultAjvOptions;
var hasRequiredDefaultAjvOptions;
function requireDefaultAjvOptions() {
  if (hasRequiredDefaultAjvOptions) return defaultAjvOptions;
  hasRequiredDefaultAjvOptions = 1;
  const fastUri2 = requireFastUri();
  defaultAjvOptions = Object.freeze({
    coerceTypes: "array",
    useDefaults: true,
    removeAdditional: true,
    uriResolver: fastUri2,
    addUsedSchema: false,
    // Explicitly set allErrors to `false`.
    // When set to `true`, a DoS attack is possible.
    allErrors: false
  });
  return defaultAjvOptions;
}
var dist$4 = { exports: {} };
var formats = {};
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatNames = exports$1.fastFormats = exports$1.fullFormats = void 0;
    function fmtDef(validate2, compare) {
      return { validate: validate2, compare };
    }
    exports$1.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date2, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: uri2,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports$1.fastFormats = {
      ...exports$1.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports$1.formatNames = Object.keys(exports$1.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date2(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time2(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    const DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time2 = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date2(dateTime[0]) && time2(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res2 = compareDate(d1, d2);
      if (res2 === void 0)
        return void 0;
      return res2 || compareTime(t1, t2);
    }
    const NOT_URI_FRAGMENT = /\/|:/;
    const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri2(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    const MIN_INT32 = -2147483648;
    const MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    const Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  })(formats);
  return formats;
}
var limit = {};
var hasRequiredLimit;
function requireLimit() {
  if (hasRequiredLimit) return limit;
  hasRequiredLimit = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatLimitDefinition = void 0;
    const ajv_1 = /* @__PURE__ */ requireAjv();
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const ops = codegen_1.operators;
    const KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error2 = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    exports$1.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self2.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const formatLimitPlugin = (ajv2) => {
      ajv2.addKeyword(exports$1.formatLimitDefinition);
      return ajv2;
    };
    exports$1.default = formatLimitPlugin;
  })(limit);
  return limit;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3) return dist$4.exports;
  hasRequiredDist$3 = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    const formats_1 = requireFormats();
    const limit_1 = requireLimit();
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const fullName = new codegen_1.Name("fullFormats");
    const fastName = new codegen_1.Name("fastFormats");
    const formatsPlugin = (ajv2, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv2, opts, formats_1.fullFormats, fullName);
        return ajv2;
      }
      const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv2, list, formats2, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv2);
      return ajv2;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats2[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv2, list, fs2, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv2.addFormat(f, fs2[f]);
    }
    module.exports = exports$1 = formatsPlugin;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = formatsPlugin;
  })(dist$4, dist$4.exports);
  return dist$4.exports;
}
var validatorCompiler$1;
var hasRequiredValidatorCompiler;
function requireValidatorCompiler() {
  if (hasRequiredValidatorCompiler) return validatorCompiler$1;
  hasRequiredValidatorCompiler = 1;
  const Ajv = requireAjv().default;
  const AjvJTD = /* @__PURE__ */ requireJtd();
  const defaultAjvOptions2 = requireDefaultAjvOptions();
  class ValidatorCompiler {
    constructor(externalSchemas, options) {
      if (options.mode === "JTD") {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions2, options.customOptions));
      } else {
        this.ajv = new Ajv(Object.assign({}, defaultAjvOptions2, options.customOptions));
      }
      let addFormatPlugin = true;
      if (options.plugins && options.plugins.length > 0) {
        for (const plugin2 of options.plugins) {
          if (Array.isArray(plugin2)) {
            addFormatPlugin = addFormatPlugin && plugin2[0].name !== "formatsPlugin";
            plugin2[0](this.ajv, plugin2[1]);
          } else {
            addFormatPlugin = addFormatPlugin && plugin2.name !== "formatsPlugin";
            plugin2(this.ajv);
          }
        }
      }
      if (addFormatPlugin) {
        requireDist$3()(this.ajv);
      }
      options.onCreate?.(this.ajv);
      const sourceSchemas = Object.values(externalSchemas);
      for (const extSchema of sourceSchemas) {
        this.ajv.addSchema(extSchema);
      }
    }
    buildValidatorFunction({
      schema
      /*, method, url, httpPart */
    }) {
      if (schema.$id) {
        const stored = this.ajv.getSchema(schema.$id);
        if (stored) {
          return stored;
        }
      }
      return this.ajv.compile(schema);
    }
  }
  validatorCompiler$1 = ValidatorCompiler;
  return validatorCompiler$1;
}
var serializerCompiler$1;
var hasRequiredSerializerCompiler;
function requireSerializerCompiler() {
  if (hasRequiredSerializerCompiler) return serializerCompiler$1;
  hasRequiredSerializerCompiler = 1;
  const AjvJTD = /* @__PURE__ */ requireJtd();
  const defaultAjvOptions2 = requireDefaultAjvOptions();
  class SerializerCompiler {
    constructor(_externalSchemas, options) {
      this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions2, options));
    }
    buildSerializerFunction({
      schema
      /*, method, url, httpStatus */
    }) {
      return this.ajv.compileSerializer(schema);
    }
  }
  serializerCompiler$1 = SerializerCompiler;
  return serializerCompiler$1;
}
var standalone$3 = { exports: {} };
var hasRequiredStandalone$3;
function requireStandalone$3() {
  if (hasRequiredStandalone$3) return standalone$3.exports;
  hasRequiredStandalone$3 = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    const scope_1 = /* @__PURE__ */ requireScope();
    const code_1 = /* @__PURE__ */ requireCode$1();
    function standaloneCode(ajv2, refsOrFunc) {
      if (!ajv2.opts.code.source) {
        throw new Error("moduleCode: ajv instance must have code.source option");
      }
      const { _n } = ajv2.scope.opts;
      return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv2.schemas, (sch) => sch.meta ? void 0 : ajv2.compile(sch.schema));
      function getValidate(id2) {
        const v = ajv2.getSchema(id2);
        if (!v)
          throw new Error(`moduleCode: no schema with id ${id2}`);
        return v;
      }
      function funcExportCode(source) {
        const usedValues = {};
        const n = source === null || source === void 0 ? void 0 : source.validateName;
        const vCode = validateCode(usedValues, source);
        if (ajv2.opts.code.esm) {
          return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
        }
        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
      }
      function multiExportsCode(schemas2, getValidateFunc) {
        var _a2;
        const usedValues = {};
        let code2 = (0, code_1._)`"use strict";`;
        for (const name in schemas2) {
          const v = getValidateFunc(schemas2[name]);
          if (v) {
            const vCode = validateCode(usedValues, v.source);
            const exportSyntax = ajv2.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
            code2 = (0, code_1._)`${code2}${_n}${exportSyntax} = ${(_a2 = v.source) === null || _a2 === void 0 ? void 0 : _a2.validateName};${_n}${vCode}`;
          }
        }
        return `${code2}`;
      }
      function validateCode(usedValues, s) {
        if (!s)
          throw new Error('moduleCode: function does not have "source" property');
        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
          return code_1.nil;
        setUsedState(s.validateName, scope_1.UsedValueState.Started);
        const scopeCode = ajv2.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
        const code2 = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
        return s.evaluated ? (0, code_1._)`${code2}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code2;
        function refValidateCode(n) {
          var _a2;
          const vRef = (_a2 = n.value) === null || _a2 === void 0 ? void 0 : _a2.ref;
          if (n.prefix === "validate" && typeof vRef == "function") {
            const v = vRef;
            return validateCode(usedValues, v.source);
          } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
            const { validate: validate2, validateName } = vRef;
            if (!validateName)
              throw new Error("ajv internal error");
            const def = ajv2.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
            const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;
            if (usedState(validateName) === scope_1.UsedValueState.Started)
              return wrapper;
            const vCode = validateCode(usedValues, validate2 === null || validate2 === void 0 ? void 0 : validate2.source);
            return (0, code_1._)`${wrapper}${_n}${vCode}`;
          }
          return void 0;
        }
        function usedState(name) {
          var _a2;
          return (_a2 = usedValues[name.prefix]) === null || _a2 === void 0 ? void 0 : _a2.get(name);
        }
        function setUsedState(name, state) {
          const { prefix } = name;
          const names2 = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          names2.set(name, state);
        }
      }
    }
    module.exports = exports$1 = standaloneCode;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = standaloneCode;
  })(standalone$3, standalone$3.exports);
  return standalone$3.exports;
}
var standalone$2;
var hasRequiredStandalone$2;
function requireStandalone$2() {
  if (hasRequiredStandalone$2) return standalone$2;
  hasRequiredStandalone$2 = 1;
  const ValidatorSelector = requireAjvCompiler();
  const standaloneCode = requireStandalone$3().default;
  function StandaloneValidator(options = { readMode: true }) {
    if (options.readMode === true && !options.restoreFunction) {
      throw new Error("You must provide a restoreFunction options when readMode ON");
    }
    if (options.readMode !== true && !options.storeFunction) {
      throw new Error("You must provide a storeFunction options when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = ValidatorSelector();
    return function wrapper(externalSchemas, ajvOptions = {}) {
      if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
        ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
      }
      const compiler = factory(externalSchemas, ajvOptions);
      return function(opts) {
        const validationFunc = compiler(opts);
        const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
        options.storeFunction(opts, schemaValidationCode);
        return validationFunc;
      };
    };
  }
  standalone$2 = StandaloneValidator;
  return standalone$2;
}
var hasRequiredAjvCompiler;
function requireAjvCompiler() {
  if (hasRequiredAjvCompiler) return ajvCompiler.exports;
  hasRequiredAjvCompiler = 1;
  const AjvReference = /* @__PURE__ */ Symbol.for("fastify.ajv-compiler.reference");
  const ValidatorCompiler = requireValidatorCompiler();
  const SerializerCompiler = requireSerializerCompiler();
  function AjvCompiler(opts) {
    const validatorPool = /* @__PURE__ */ new Map();
    const serializerPool = /* @__PURE__ */ new Map();
    if (opts && opts.jtdSerializer === true) {
      return function buildSerializerFromPool(externalSchemas, serializerOpts) {
        const uniqueAjvKey = getPoolKey({}, serializerOpts);
        if (serializerPool.has(uniqueAjvKey)) {
          return serializerPool.get(uniqueAjvKey);
        }
        const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
        const ret = compiler.buildSerializerFunction.bind(compiler);
        serializerPool.set(uniqueAjvKey, ret);
        return ret;
      };
    }
    return function buildCompilerFromPool(externalSchemas, options) {
      const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
      if (validatorPool.has(uniqueAjvKey)) {
        return validatorPool.get(uniqueAjvKey);
      }
      const compiler = new ValidatorCompiler(externalSchemas, options);
      const ret = compiler.buildValidatorFunction.bind(compiler);
      validatorPool.set(uniqueAjvKey, ret);
      if (options.customOptions.code !== void 0) {
        ret[AjvReference] = compiler;
      }
      return ret;
    };
  }
  function getPoolKey(externalSchemas, options) {
    const externals = JSON.stringify(externalSchemas);
    const ajvConfig = JSON.stringify(options);
    return `${externals}${ajvConfig}`;
  }
  ajvCompiler.exports = AjvCompiler;
  ajvCompiler.exports.default = AjvCompiler;
  ajvCompiler.exports.AjvCompiler = AjvCompiler;
  ajvCompiler.exports.AjvReference = AjvReference;
  ajvCompiler.exports.StandaloneValidator = requireStandalone$2();
  return ajvCompiler.exports;
}
var fastJsonStringifyCompiler = { exports: {} };
var standalone$1 = {};
var fastJsonStringify = { exports: {} };
var dist$3 = {};
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2) return dist$3;
  hasRequiredDist$2 = 1;
  var has = Object.prototype.hasOwnProperty;
  function find(iter, tar, key) {
    for (key of iter.keys()) {
      if (dequal(key, tar)) return key;
    }
  }
  function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length) {
          while (len-- && dequal(foo[len], bar[len])) ;
        }
        return len === -1;
      }
      if (ctor === Set) {
        if (foo.size !== bar.size) {
          return false;
        }
        for (len of foo) {
          tmp = len;
          if (tmp && typeof tmp === "object") {
            tmp = find(bar, tmp);
            if (!tmp) return false;
          }
          if (!bar.has(tmp)) return false;
        }
        return true;
      }
      if (ctor === Map) {
        if (foo.size !== bar.size) {
          return false;
        }
        for (len of foo) {
          tmp = len[0];
          if (tmp && typeof tmp === "object") {
            tmp = find(bar, tmp);
            if (!tmp) return false;
          }
          if (!dequal(len[1], bar.get(tmp))) {
            return false;
          }
        }
        return true;
      }
      if (ctor === ArrayBuffer) {
        foo = new Uint8Array(foo);
        bar = new Uint8Array(bar);
      } else if (ctor === DataView) {
        if ((len = foo.byteLength) === bar.byteLength) {
          while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
        }
        return len === -1;
      }
      if (ArrayBuffer.isView(foo)) {
        if ((len = foo.byteLength) === bar.byteLength) {
          while (len-- && foo[len] === bar[len]) ;
        }
        return len === -1;
      }
      if (!ctor || typeof foo === "object") {
        len = 0;
        for (ctor in foo) {
          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
        }
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  dist$3.dequal = dequal;
  return dist$3;
}
var jsonSchemaRefResolver;
var hasRequiredJsonSchemaRefResolver;
function requireJsonSchemaRefResolver() {
  if (hasRequiredJsonSchemaRefResolver) return jsonSchemaRefResolver;
  hasRequiredJsonSchemaRefResolver = 1;
  const { dequal: deepEqual } = requireDist$2();
  const jsonSchemaRefSymbol = /* @__PURE__ */ Symbol.for("json-schema-ref");
  class RefResolver {
    #schemas;
    #derefSchemas;
    #insertRefSymbol;
    #allowEqualDuplicates;
    #cloneSchemaWithoutRefs;
    constructor(opts = {}) {
      this.#schemas = {};
      this.#derefSchemas = {};
      this.#insertRefSymbol = opts.insertRefSymbol ?? false;
      this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
      this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
    }
    addSchema(schema, rootSchemaId, isRootSchema = true) {
      if (isRootSchema) {
        if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
          rootSchemaId = schema.$id;
        } else {
          this.#insertSchemaBySchemaId(schema, rootSchemaId);
        }
      }
      const schemaId = schema.$id;
      if (schemaId !== void 0 && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
        } else {
          this.#insertSchemaBySchemaId(schema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      const ref2 = schema.$ref;
      if (ref2 !== void 0 && typeof ref2 === "string") {
        const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref2, rootSchemaId);
        this.#schemas[rootSchemaId].refs.push({
          schemaId: refSchemaId,
          jsonPointer: refJsonPointer
        });
      }
      for (const key in schema) {
        if (typeof schema[key] === "object" && schema[key] !== null) {
          this.addSchema(schema[key], rootSchemaId, false);
        }
      }
    }
    getSchema(schemaId, jsonPointer = "#") {
      const schema = this.#schemas[schemaId];
      if (schema === void 0) {
        throw new Error(
          `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
        );
      }
      if (schema.anchors[jsonPointer] !== void 0) {
        return schema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(schema.schema, jsonPointer);
    }
    hasSchema(schemaId) {
      return this.#schemas[schemaId] !== void 0;
    }
    getSchemaRefs(schemaId) {
      const schema = this.#schemas[schemaId];
      if (schema === void 0) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      return schema.refs;
    }
    getSchemaDependencies(schemaId, dependencies2 = {}) {
      const schema = this.#schemas[schemaId];
      for (const ref2 of schema.refs) {
        const dependencySchemaId = ref2.schemaId;
        if (dependencySchemaId === schemaId || dependencies2[dependencySchemaId] !== void 0) continue;
        dependencies2[dependencySchemaId] = this.getSchema(dependencySchemaId);
        this.getSchemaDependencies(dependencySchemaId, dependencies2);
      }
      return dependencies2;
    }
    derefSchema(schemaId) {
      if (this.#derefSchemas[schemaId] !== void 0) return;
      const schema = this.#schemas[schemaId];
      if (schema === void 0) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
        this.#derefSchemas[schemaId] = {
          schema: schema.schema,
          anchors: schema.anchors
        };
      }
      const refs = [];
      this.#addDerefSchema(schema.schema, schemaId, true, refs);
      const dependencies2 = this.getSchemaDependencies(schemaId);
      for (const schemaId2 in dependencies2) {
        const schema2 = dependencies2[schemaId2];
        this.#addDerefSchema(schema2, schemaId2, true, refs);
      }
      for (const ref2 of refs) {
        const {
          refSchemaId,
          refJsonPointer
        } = this.#parseSchemaRef(ref2.ref, ref2.sourceSchemaId);
        const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
        if (targetSchema === null) {
          throw new Error(
            `Cannot resolve ref "${ref2.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
          );
        }
        ref2.targetSchema = targetSchema;
        ref2.targetSchemaId = refSchemaId;
      }
      for (const ref2 of refs) {
        this.#resolveRef(ref2, refs);
      }
    }
    getDerefSchema(schemaId, jsonPointer = "#") {
      let derefSchema = this.#derefSchemas[schemaId];
      if (derefSchema === void 0) {
        this.derefSchema(schemaId);
        derefSchema = this.#derefSchemas[schemaId];
      }
      if (derefSchema.anchors[jsonPointer] !== void 0) {
        return derefSchema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(derefSchema.schema, jsonPointer);
    }
    #parseSchemaRef(ref2, schemaId) {
      const sharpIndex = ref2.indexOf("#");
      if (sharpIndex === -1) {
        return { refSchemaId: ref2, refJsonPointer: "#" };
      }
      if (sharpIndex === 0) {
        return { refSchemaId: schemaId, refJsonPointer: ref2 };
      }
      return {
        refSchemaId: ref2.slice(0, sharpIndex),
        refJsonPointer: ref2.slice(sharpIndex)
      };
    }
    #addDerefSchema(schema, rootSchemaId, isRootSchema, refs = []) {
      const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
      if (isRootSchema) {
        if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
          rootSchemaId = schema.$id;
        } else {
          this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
        }
      }
      const schemaId = derefSchema.$id;
      if (schemaId !== void 0 && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
        } else {
          this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      if (derefSchema.$ref !== void 0) {
        refs.push({
          ref: derefSchema.$ref,
          sourceSchemaId: rootSchemaId,
          sourceSchema: derefSchema
        });
      }
      for (const key in derefSchema) {
        const value = derefSchema[key];
        if (typeof value === "object" && value !== null) {
          derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
        }
      }
      return derefSchema;
    }
    #resolveRef(ref2, refs) {
      const { sourceSchema, targetSchema } = ref2;
      if (!sourceSchema.$ref) return;
      if (this.#insertRefSymbol) {
        sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
      }
      delete sourceSchema.$ref;
      if (targetSchema.$ref) {
        const targetSchemaRef = refs.find((ref3) => ref3.sourceSchema === targetSchema);
        this.#resolveRef(targetSchemaRef, refs);
      }
      for (const key in targetSchema) {
        if (key === "$id") continue;
        if (sourceSchema[key] !== void 0) {
          if (deepEqual(sourceSchema[key], targetSchema[key])) continue;
          throw new Error(
            `Cannot resolve ref "${ref2.ref}". Property "${key}" already exists in schema "${ref2.sourceSchemaId}".`
          );
        }
        sourceSchema[key] = targetSchema[key];
      }
      ref2.isResolved = true;
    }
    #insertSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#schemas[schemaId];
      if (foundSchema !== void 0) {
        if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return;
        throw new Error(`There is already another schema with id "${schemaId}".`);
      }
      this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
    }
    #insertSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#schemas[schemaId];
      if (anchors[anchor] !== void 0) {
        throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`);
      }
      anchors[anchor] = schema;
    }
    #insertDerefSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#derefSchemas[schemaId];
      if (foundSchema !== void 0) return;
      this.#derefSchemas[schemaId] = { schema, anchors: {} };
    }
    #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#derefSchemas[schemaId];
      anchors[anchor] = schema;
    }
  }
  function getDataByJSONPointer(data, jsonPointer) {
    const parts = jsonPointer.split("/");
    let current = data;
    for (const part of parts) {
      if (part === "" || part === "#") continue;
      if (typeof current !== "object" || current === null) {
        return null;
      }
      current = current[part];
    }
    return current ?? null;
  }
  jsonSchemaRefResolver = { RefResolver };
  return jsonSchemaRefResolver;
}
var validator;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator;
  hasRequiredValidator = 1;
  const Ajv = /* @__PURE__ */ requireAjv();
  const fastUri2 = requireFastUri();
  const ajvFormats = requireDist$3();
  const clone2 = requireRfdc()({ proto: true });
  class Validator {
    constructor(ajvOptions) {
      this.ajv = new Ajv({
        ...ajvOptions,
        strictSchema: false,
        validateSchema: false,
        allowUnionTypes: true,
        uriResolver: fastUri2
      });
      ajvFormats(this.ajv);
      this.ajv.addKeyword({
        keyword: "fjs_type",
        type: "object",
        errors: false,
        validate: (_type, data) => {
          return data && typeof data.toJSON === "function";
        }
      });
      this._ajvSchemas = {};
      this._ajvOptions = ajvOptions || {};
    }
    addSchema(schema, schemaName) {
      let schemaKey = schema.$id || schemaName;
      if (schema.$id !== void 0 && schema.$id[0] === "#") {
        schemaKey = schemaName + schema.$id;
      }
      if (this.ajv.refs[schemaKey] === void 0 && this.ajv.schemas[schemaKey] === void 0) {
        const ajvSchema = clone2(schema);
        this.convertSchemaToAjvFormat(ajvSchema);
        this.ajv.addSchema(ajvSchema, schemaKey);
        this._ajvSchemas[schemaKey] = schema;
      }
    }
    validate(schemaRef, data) {
      return this.ajv.validate(schemaRef, data);
    }
    // Ajv does not natively support JavaScript objects like Date or other types
    // that rely on a custom .toJSON() representation. To properly validate schemas
    // that may contain such objects (e.g. Date, ObjectId, etc.), we replace all
    // occurrences of the string type with a custom keyword fjs_type
    // (see https://github.com/fastify/fast-json-stringify/pull/441)
    convertSchemaToAjvFormat(schema) {
      if (schema === null) return;
      if (schema.type === "string") {
        schema.fjs_type = "string";
        schema.type = ["string", "object"];
      } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
        schema.fjs_type = "string";
        schema.type.push("object");
      }
      for (const property in schema) {
        if (typeof schema[property] === "object") {
          this.convertSchemaToAjvFormat(schema[property]);
        }
      }
    }
    getState() {
      return {
        ajvOptions: this._ajvOptions,
        ajvSchemas: this._ajvSchemas
      };
    }
    static restoreFromState(state) {
      const validator2 = new Validator(state.ajvOptions);
      for (const [id2, ajvSchema] of Object.entries(state.ajvSchemas)) {
        validator2.ajv.addSchema(ajvSchema, id2);
      }
      return validator2;
    }
  }
  validator = Validator;
  return validator;
}
var location;
var hasRequiredLocation;
function requireLocation() {
  if (hasRequiredLocation) return location;
  hasRequiredLocation = 1;
  class Location {
    constructor(schema, schemaId, jsonPointer = "#") {
      this.schema = schema;
      this.schemaId = schemaId;
      this.jsonPointer = jsonPointer;
    }
    getPropertyLocation(propertyName) {
      const propertyLocation = new Location(
        this.schema[propertyName],
        this.schemaId,
        this.jsonPointer + "/" + propertyName
      );
      return propertyLocation;
    }
    getSchemaRef() {
      return this.schemaId + this.jsonPointer;
    }
  }
  location = Location;
  return location;
}
var schemaValidator = { exports: {} };
var hasRequiredSchemaValidator;
function requireSchemaValidator() {
  if (hasRequiredSchemaValidator) return schemaValidator.exports;
  hasRequiredSchemaValidator = 1;
  schemaValidator.exports = validate10;
  schemaValidator.exports.default = validate10;
  const schema11 = { "type": ["object", "boolean"] };
  const schema20 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
  const formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  const formats2 = requireFormats().fullFormats.uri;
  const formats6 = requireFormats().fullFormats.regex;
  function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
      validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
      return false;
    }
    {
      if (typeof data == "number" && isFinite(data)) {
        if (data < 0 || isNaN(data)) {
          validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
          return false;
        }
      }
    }
    validate11.errors = vErrors;
    return errors2 === 0;
  }
  const root1 = { validate: validate10 };
  function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    if (errors2 === 0) {
      if (Array.isArray(data)) {
        if (data.length < 1) {
          validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
          return false;
        } else {
          var valid0 = true;
          const len0 = data.length;
          for (let i0 = 0; i0 < len0; i0++) {
            const _errs1 = errors2;
            if (!root1.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
              vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
              errors2 = vErrors.length;
            }
            var valid0 = _errs1 === errors2;
            if (!valid0) {
              break;
            }
          }
        }
      } else {
        validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
        return false;
      }
    }
    validate13.errors = vErrors;
    return errors2 === 0;
  }
  const func0 = requireEqual().default;
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
      return false;
    }
    if (errors2 === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.$id !== void 0) {
          let data0 = data.$id;
          const _errs1 = errors2;
          if (errors2 === _errs1) {
            if (errors2 === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0.test(data0)) {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                  return false;
                }
              } else {
                validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors2;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.$schema !== void 0) {
            let data1 = data.$schema;
            const _errs3 = errors2;
            if (errors2 === _errs3) {
              if (errors2 === _errs3) {
                if (typeof data1 === "string") {
                  if (!formats2(data1)) {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors2;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$ref !== void 0) {
              let data2 = data.$ref;
              const _errs5 = errors2;
              if (errors2 === _errs5) {
                if (errors2 === _errs5) {
                  if (typeof data2 === "string") {
                    if (!formats0.test(data2)) {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs5 === errors2;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.$comment !== void 0) {
                const _errs7 = errors2;
                if (typeof data.$comment !== "string") {
                  validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs7 === errors2;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.title !== void 0) {
                  const _errs9 = errors2;
                  if (typeof data.title !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs9 === errors2;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.description !== void 0) {
                    const _errs11 = errors2;
                    if (typeof data.description !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs11 === errors2;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.readOnly !== void 0) {
                      const _errs13 = errors2;
                      if (typeof data.readOnly !== "boolean") {
                        validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                        return false;
                      }
                      var valid0 = _errs13 === errors2;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.examples !== void 0) {
                        const _errs15 = errors2;
                        if (errors2 === _errs15) {
                          if (!Array.isArray(data.examples)) {
                            validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                            return false;
                          }
                        }
                        var valid0 = _errs15 === errors2;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.multipleOf !== void 0) {
                          let data8 = data.multipleOf;
                          const _errs17 = errors2;
                          if (errors2 === _errs17) {
                            if (typeof data8 == "number" && isFinite(data8)) {
                              if (data8 <= 0 || isNaN(data8)) {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                return false;
                              }
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                          }
                          var valid0 = _errs17 === errors2;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.maximum !== void 0) {
                            let data9 = data.maximum;
                            const _errs19 = errors2;
                            if (!(typeof data9 == "number" && isFinite(data9))) {
                              validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                            var valid0 = _errs19 === errors2;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.exclusiveMaximum !== void 0) {
                              let data10 = data.exclusiveMaximum;
                              const _errs21 = errors2;
                              if (!(typeof data10 == "number" && isFinite(data10))) {
                                validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs21 === errors2;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.minimum !== void 0) {
                                let data11 = data.minimum;
                                const _errs23 = errors2;
                                if (!(typeof data11 == "number" && isFinite(data11))) {
                                  validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs23 === errors2;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.exclusiveMinimum !== void 0) {
                                  let data12 = data.exclusiveMinimum;
                                  const _errs25 = errors2;
                                  if (!(typeof data12 == "number" && isFinite(data12))) {
                                    validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs25 === errors2;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.maxLength !== void 0) {
                                    let data13 = data.maxLength;
                                    const _errs27 = errors2;
                                    const _errs28 = errors2;
                                    if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                      validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                      return false;
                                    }
                                    if (errors2 === _errs28) {
                                      if (typeof data13 == "number" && isFinite(data13)) {
                                        if (data13 < 0 || isNaN(data13)) {
                                          validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid0 = _errs27 === errors2;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.minLength !== void 0) {
                                      const _errs30 = errors2;
                                      if (!validate11(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                        vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                        errors2 = vErrors.length;
                                      }
                                      var valid0 = _errs30 === errors2;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.pattern !== void 0) {
                                        let data15 = data.pattern;
                                        const _errs31 = errors2;
                                        if (errors2 === _errs31) {
                                          if (errors2 === _errs31) {
                                            if (typeof data15 === "string") {
                                              if (!formats6(data15)) {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }];
                                                return false;
                                              }
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                        }
                                        var valid0 = _errs31 === errors2;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.additionalItems !== void 0) {
                                          const _errs33 = errors2;
                                          if (!validate10(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                            errors2 = vErrors.length;
                                          }
                                          var valid0 = _errs33 === errors2;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.items !== void 0) {
                                            let data17 = data.items;
                                            const _errs34 = errors2;
                                            const _errs35 = errors2;
                                            let valid2 = false;
                                            const _errs36 = errors2;
                                            if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors2 = vErrors.length;
                                            }
                                            var _valid0 = _errs36 === errors2;
                                            valid2 = valid2 || _valid0;
                                            if (!valid2) {
                                              const _errs37 = errors2;
                                              if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                errors2 = vErrors.length;
                                              }
                                              var _valid0 = _errs37 === errors2;
                                              valid2 = valid2 || _valid0;
                                            }
                                            if (!valid2) {
                                              const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                              if (vErrors === null) {
                                                vErrors = [err0];
                                              } else {
                                                vErrors.push(err0);
                                              }
                                              errors2++;
                                              validate10.errors = vErrors;
                                              return false;
                                            } else {
                                              errors2 = _errs35;
                                              if (vErrors !== null) {
                                                if (_errs35) {
                                                  vErrors.length = _errs35;
                                                } else {
                                                  vErrors = null;
                                                }
                                              }
                                            }
                                            var valid0 = _errs34 === errors2;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.maxItems !== void 0) {
                                              let data18 = data.maxItems;
                                              const _errs38 = errors2;
                                              const _errs39 = errors2;
                                              if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                return false;
                                              }
                                              if (errors2 === _errs39) {
                                                if (typeof data18 == "number" && isFinite(data18)) {
                                                  if (data18 < 0 || isNaN(data18)) {
                                                    validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                    return false;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs38 === errors2;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.minItems !== void 0) {
                                                const _errs41 = errors2;
                                                if (!validate11(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                  vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                  errors2 = vErrors.length;
                                                }
                                                var valid0 = _errs41 === errors2;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.uniqueItems !== void 0) {
                                                  const _errs42 = errors2;
                                                  if (typeof data.uniqueItems !== "boolean") {
                                                    validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                    return false;
                                                  }
                                                  var valid0 = _errs42 === errors2;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.contains !== void 0) {
                                                    const _errs44 = errors2;
                                                    if (!validate10(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                      errors2 = vErrors.length;
                                                    }
                                                    var valid0 = _errs44 === errors2;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.maxProperties !== void 0) {
                                                      let data22 = data.maxProperties;
                                                      const _errs45 = errors2;
                                                      const _errs46 = errors2;
                                                      if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                        validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                      if (errors2 === _errs46) {
                                                        if (typeof data22 == "number" && isFinite(data22)) {
                                                          if (data22 < 0 || isNaN(data22)) {
                                                            validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                            return false;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs45 === errors2;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.minProperties !== void 0) {
                                                        const _errs48 = errors2;
                                                        if (!validate11(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                          errors2 = vErrors.length;
                                                        }
                                                        var valid0 = _errs48 === errors2;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.required !== void 0) {
                                                          let data24 = data.required;
                                                          const _errs49 = errors2;
                                                          const _errs50 = errors2;
                                                          if (errors2 === _errs50) {
                                                            if (Array.isArray(data24)) {
                                                              var valid6 = true;
                                                              const len0 = data24.length;
                                                              for (let i0 = 0; i0 < len0; i0++) {
                                                                const _errs52 = errors2;
                                                                if (typeof data24[i0] !== "string") {
                                                                  validate10.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                  return false;
                                                                }
                                                                var valid6 = _errs52 === errors2;
                                                                if (!valid6) {
                                                                  break;
                                                                }
                                                              }
                                                              if (valid6) {
                                                                let i1 = data24.length;
                                                                let j0;
                                                                if (i1 > 1) {
                                                                  const indices0 = {};
                                                                  for (; i1--; ) {
                                                                    let item0 = data24[i1];
                                                                    if (typeof item0 !== "string") {
                                                                      continue;
                                                                    }
                                                                    if (typeof indices0[item0] == "number") {
                                                                      j0 = indices0[item0];
                                                                      validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                      return false;
                                                                    }
                                                                    indices0[item0] = i1;
                                                                  }
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs49 === errors2;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.additionalProperties !== void 0) {
                                                            const _errs54 = errors2;
                                                            if (!validate10(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                              errors2 = vErrors.length;
                                                            }
                                                            var valid0 = _errs54 === errors2;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.definitions !== void 0) {
                                                              let data27 = data.definitions;
                                                              const _errs55 = errors2;
                                                              if (errors2 === _errs55) {
                                                                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                  for (const key0 in data27) {
                                                                    const _errs58 = errors2;
                                                                    if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                      errors2 = vErrors.length;
                                                                    }
                                                                    var valid8 = _errs58 === errors2;
                                                                    if (!valid8) {
                                                                      break;
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid0 = _errs55 === errors2;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.properties !== void 0) {
                                                                let data29 = data.properties;
                                                                const _errs59 = errors2;
                                                                if (errors2 === _errs59) {
                                                                  if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                    for (const key1 in data29) {
                                                                      const _errs62 = errors2;
                                                                      if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors2 = vErrors.length;
                                                                      }
                                                                      var valid9 = _errs62 === errors2;
                                                                      if (!valid9) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs59 === errors2;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.patternProperties !== void 0) {
                                                                  let data31 = data.patternProperties;
                                                                  const _errs63 = errors2;
                                                                  if (errors2 === _errs63) {
                                                                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                      for (const key2 in data31) {
                                                                        const _errs65 = errors2;
                                                                        if (errors2 === _errs65) {
                                                                          if (typeof key2 === "string") {
                                                                            if (!formats6(key2)) {
                                                                              const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: key2 };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err1];
                                                                              } else {
                                                                                vErrors.push(err1);
                                                                              }
                                                                              errors2++;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid10 = _errs65 === errors2;
                                                                        if (!valid10) {
                                                                          const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err2];
                                                                          } else {
                                                                            vErrors.push(err2);
                                                                          }
                                                                          errors2++;
                                                                          validate10.errors = vErrors;
                                                                          return false;
                                                                        }
                                                                      }
                                                                      if (valid10) {
                                                                        for (const key3 in data31) {
                                                                          const _errs67 = errors2;
                                                                          if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors2 = vErrors.length;
                                                                          }
                                                                          var valid11 = _errs67 === errors2;
                                                                          if (!valid11) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs63 === errors2;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.dependencies !== void 0) {
                                                                    let data33 = data.dependencies;
                                                                    const _errs68 = errors2;
                                                                    if (errors2 === _errs68) {
                                                                      if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                        for (const key4 in data33) {
                                                                          let data34 = data33[key4];
                                                                          const _errs71 = errors2;
                                                                          const _errs72 = errors2;
                                                                          let valid13 = false;
                                                                          const _errs73 = errors2;
                                                                          if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors2 = vErrors.length;
                                                                          }
                                                                          var _valid1 = _errs73 === errors2;
                                                                          valid13 = valid13 || _valid1;
                                                                          if (!valid13) {
                                                                            const _errs74 = errors2;
                                                                            const _errs75 = errors2;
                                                                            if (errors2 === _errs75) {
                                                                              if (Array.isArray(data34)) {
                                                                                var valid15 = true;
                                                                                const len1 = data34.length;
                                                                                for (let i2 = 0; i2 < len1; i2++) {
                                                                                  const _errs77 = errors2;
                                                                                  if (typeof data34[i2] !== "string") {
                                                                                    const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err3];
                                                                                    } else {
                                                                                      vErrors.push(err3);
                                                                                    }
                                                                                    errors2++;
                                                                                  }
                                                                                  var valid15 = _errs77 === errors2;
                                                                                  if (!valid15) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                if (valid15) {
                                                                                  let i3 = data34.length;
                                                                                  let j1;
                                                                                  if (i3 > 1) {
                                                                                    const indices1 = {};
                                                                                    for (; i3--; ) {
                                                                                      let item1 = data34[i3];
                                                                                      if (typeof item1 !== "string") {
                                                                                        continue;
                                                                                      }
                                                                                      if (typeof indices1[item1] == "number") {
                                                                                        j1 = indices1[item1];
                                                                                        const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err4];
                                                                                        } else {
                                                                                          vErrors.push(err4);
                                                                                        }
                                                                                        errors2++;
                                                                                        break;
                                                                                      }
                                                                                      indices1[item1] = i3;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err5];
                                                                                } else {
                                                                                  vErrors.push(err5);
                                                                                }
                                                                                errors2++;
                                                                              }
                                                                            }
                                                                            var _valid1 = _errs74 === errors2;
                                                                            valid13 = valid13 || _valid1;
                                                                          }
                                                                          if (!valid13) {
                                                                            const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err6];
                                                                            } else {
                                                                              vErrors.push(err6);
                                                                            }
                                                                            errors2++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors2 = _errs72;
                                                                            if (vErrors !== null) {
                                                                              if (_errs72) {
                                                                                vErrors.length = _errs72;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid12 = _errs71 === errors2;
                                                                          if (!valid12) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs68 === errors2;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.propertyNames !== void 0) {
                                                                      const _errs79 = errors2;
                                                                      if (!validate10(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors2 = vErrors.length;
                                                                      }
                                                                      var valid0 = _errs79 === errors2;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.enum !== void 0) {
                                                                        let data37 = data.enum;
                                                                        const _errs80 = errors2;
                                                                        if (errors2 === _errs80) {
                                                                          if (Array.isArray(data37)) {
                                                                            if (data37.length < 1) {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                              return false;
                                                                            } else {
                                                                              let i4 = data37.length;
                                                                              let j2;
                                                                              if (i4 > 1) {
                                                                                for (; i4--; ) {
                                                                                  for (j2 = i4; j2--; ) {
                                                                                    if (func0(data37[i4], data37[j2])) {
                                                                                      validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                      return false;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        var valid0 = _errs80 === errors2;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.type !== void 0) {
                                                                          let data38 = data.type;
                                                                          const _errs82 = errors2;
                                                                          const _errs83 = errors2;
                                                                          let valid18 = false;
                                                                          const _errs84 = errors2;
                                                                          if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                            const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err7];
                                                                            } else {
                                                                              vErrors.push(err7);
                                                                            }
                                                                            errors2++;
                                                                          }
                                                                          var _valid2 = _errs84 === errors2;
                                                                          valid18 = valid18 || _valid2;
                                                                          if (!valid18) {
                                                                            const _errs86 = errors2;
                                                                            if (errors2 === _errs86) {
                                                                              if (Array.isArray(data38)) {
                                                                                if (data38.length < 1) {
                                                                                  const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err8];
                                                                                  } else {
                                                                                    vErrors.push(err8);
                                                                                  }
                                                                                  errors2++;
                                                                                } else {
                                                                                  var valid20 = true;
                                                                                  const len2 = data38.length;
                                                                                  for (let i5 = 0; i5 < len2; i5++) {
                                                                                    let data39 = data38[i5];
                                                                                    const _errs88 = errors2;
                                                                                    if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                      const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err9];
                                                                                      } else {
                                                                                        vErrors.push(err9);
                                                                                      }
                                                                                      errors2++;
                                                                                    }
                                                                                    var valid20 = _errs88 === errors2;
                                                                                    if (!valid20) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid20) {
                                                                                    let i6 = data38.length;
                                                                                    let j3;
                                                                                    if (i6 > 1) {
                                                                                      outer1:
                                                                                        for (; i6--; ) {
                                                                                          for (j3 = i6; j3--; ) {
                                                                                            if (func0(data38[i6], data38[j3])) {
                                                                                              const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                              if (vErrors === null) {
                                                                                                vErrors = [err10];
                                                                                              } else {
                                                                                                vErrors.push(err10);
                                                                                              }
                                                                                              errors2++;
                                                                                              break outer1;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err11];
                                                                                } else {
                                                                                  vErrors.push(err11);
                                                                                }
                                                                                errors2++;
                                                                              }
                                                                            }
                                                                            var _valid2 = _errs86 === errors2;
                                                                            valid18 = valid18 || _valid2;
                                                                          }
                                                                          if (!valid18) {
                                                                            const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err12];
                                                                            } else {
                                                                              vErrors.push(err12);
                                                                            }
                                                                            errors2++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors2 = _errs83;
                                                                            if (vErrors !== null) {
                                                                              if (_errs83) {
                                                                                vErrors.length = _errs83;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid0 = _errs82 === errors2;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.format !== void 0) {
                                                                            const _errs90 = errors2;
                                                                            if (typeof data.format !== "string") {
                                                                              validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                            var valid0 = _errs90 === errors2;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.contentMediaType !== void 0) {
                                                                              const _errs92 = errors2;
                                                                              if (typeof data.contentMediaType !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs92 === errors2;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.contentEncoding !== void 0) {
                                                                                const _errs94 = errors2;
                                                                                if (typeof data.contentEncoding !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs94 === errors2;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.if !== void 0) {
                                                                                  const _errs96 = errors2;
                                                                                  if (!validate10(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                    vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                    errors2 = vErrors.length;
                                                                                  }
                                                                                  var valid0 = _errs96 === errors2;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.then !== void 0) {
                                                                                    const _errs97 = errors2;
                                                                                    if (!validate10(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors2 = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs97 === errors2;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.else !== void 0) {
                                                                                      const _errs98 = errors2;
                                                                                      if (!validate10(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors2 = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs98 === errors2;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.allOf !== void 0) {
                                                                                        const _errs99 = errors2;
                                                                                        if (!validate13(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                          vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                          errors2 = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs99 === errors2;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.anyOf !== void 0) {
                                                                                          const _errs100 = errors2;
                                                                                          if (!validate13(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors2 = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs100 === errors2;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.oneOf !== void 0) {
                                                                                            const _errs101 = errors2;
                                                                                            if (!validate13(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors2 = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs101 === errors2;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data.not !== void 0) {
                                                                                              const _errs102 = errors2;
                                                                                              if (!validate10(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                errors2 = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs102 === errors2;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    validate10.errors = vErrors;
    return errors2 === 0;
  }
  return schemaValidator.exports;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  class MergeError extends Error {
    constructor(keyword2, schemas2) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Failed to merge "${keyword2}" keyword schemas.`;
      this.schemas = schemas2;
    }
  }
  class ResolverNotFoundError extends Error {
    constructor(keyword2, schemas2) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Resolver for "${keyword2}" keyword not found.`;
      this.schemas = schemas2;
    }
  }
  class InvalidOnConflictOptionError extends Error {
    constructor(onConflict) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Invalid "onConflict" option: "${onConflict}".`;
    }
  }
  errors = {
    MergeError,
    ResolverNotFoundError,
    InvalidOnConflictOptionError
  };
  return errors;
}
var resolvers;
var hasRequiredResolvers;
function requireResolvers() {
  if (hasRequiredResolvers) return resolvers;
  hasRequiredResolvers = 1;
  const { dequal: deepEqual } = requireDist$2();
  const { MergeError } = requireErrors();
  function _arraysIntersection(arrays) {
    let intersection2 = arrays[0];
    for (let i = 1; i < arrays.length; i++) {
      intersection2 = intersection2.filter(
        (value) => arrays[i].includes(value)
      );
    }
    return intersection2;
  }
  function arraysIntersection(keyword2, values2, mergedSchema) {
    const intersection2 = _arraysIntersection(values2);
    if (intersection2.length === 0) {
      throw new MergeError(keyword2, values2);
    }
    mergedSchema[keyword2] = intersection2;
  }
  function hybridArraysIntersection(keyword2, values2, mergedSchema) {
    for (let i = 0; i < values2.length; i++) {
      if (!Array.isArray(values2[i])) {
        values2[i] = [values2[i]];
      }
    }
    const intersection2 = _arraysIntersection(values2);
    if (intersection2.length === 0) {
      throw new MergeError(keyword2, values2);
    }
    if (intersection2.length === 1) {
      mergedSchema[keyword2] = intersection2[0];
    } else {
      mergedSchema[keyword2] = intersection2;
    }
  }
  function arraysUnion(keyword2, values2, mergedSchema) {
    const union2 = [];
    for (const array2 of values2) {
      for (const value of array2) {
        if (!union2.includes(value)) {
          union2.push(value);
        }
      }
    }
    mergedSchema[keyword2] = union2;
  }
  function minNumber(keyword2, values2, mergedSchema) {
    mergedSchema[keyword2] = Math.min(...values2);
  }
  function maxNumber(keyword2, values2, mergedSchema) {
    mergedSchema[keyword2] = Math.max(...values2);
  }
  function commonMultiple(keyword2, values2, mergedSchema) {
    const gcd = (a, b) => !b ? a : gcd(b, a % b);
    const lcm = (a, b) => a * b / gcd(a, b);
    let scale = 1;
    for (const value of values2) {
      while (value * scale % 1 !== 0) {
        scale *= 10;
      }
    }
    let multiple = values2[0] * scale;
    for (const value of values2) {
      multiple = lcm(multiple, value * scale);
    }
    mergedSchema[keyword2] = multiple / scale;
  }
  function allEqual(keyword2, values2, mergedSchema) {
    const firstValue = values2[0];
    for (let i = 1; i < values2.length; i++) {
      if (!deepEqual(values2[i], firstValue)) {
        throw new MergeError(keyword2, values2);
      }
    }
    mergedSchema[keyword2] = firstValue;
  }
  function skip() {
  }
  function booleanAnd(keyword2, values2, mergedSchema) {
    for (const value of values2) {
      if (value === false) {
        mergedSchema[keyword2] = false;
        return;
      }
    }
    mergedSchema[keyword2] = true;
  }
  function booleanOr(keyword2, values2, mergedSchema) {
    for (const value of values2) {
      if (value === true) {
        mergedSchema[keyword2] = true;
        return;
      }
    }
    mergedSchema[keyword2] = false;
  }
  resolvers = {
    arraysIntersection,
    hybridArraysIntersection,
    arraysUnion,
    minNumber,
    maxNumber,
    commonMultiple,
    allEqual,
    booleanAnd,
    booleanOr,
    skip
  };
  return resolvers;
}
var mergeJsonSchemas;
var hasRequiredMergeJsonSchemas;
function requireMergeJsonSchemas() {
  if (hasRequiredMergeJsonSchemas) return mergeJsonSchemas;
  hasRequiredMergeJsonSchemas = 1;
  const { dequal: deepEqual } = requireDist$2();
  const resolvers2 = requireResolvers();
  const errors2 = requireErrors();
  const keywordsResolvers = {
    $id: resolvers2.skip,
    type: resolvers2.hybridArraysIntersection,
    enum: resolvers2.arraysIntersection,
    minLength: resolvers2.maxNumber,
    maxLength: resolvers2.minNumber,
    minimum: resolvers2.maxNumber,
    maximum: resolvers2.minNumber,
    multipleOf: resolvers2.commonMultiple,
    exclusiveMinimum: resolvers2.maxNumber,
    exclusiveMaximum: resolvers2.minNumber,
    minItems: resolvers2.maxNumber,
    maxItems: resolvers2.minNumber,
    maxProperties: resolvers2.minNumber,
    minProperties: resolvers2.maxNumber,
    const: resolvers2.allEqual,
    default: resolvers2.allEqual,
    format: resolvers2.allEqual,
    required: resolvers2.arraysUnion,
    properties: mergeProperties,
    patternProperties: mergeObjects,
    additionalProperties: mergeSchemasResolver,
    items: mergeItems,
    additionalItems: mergeAdditionalItems,
    definitions: mergeObjects,
    $defs: mergeObjects,
    nullable: resolvers2.booleanAnd,
    oneOf: mergeOneOf,
    anyOf: mergeOneOf,
    allOf: resolvers2.arraysUnion,
    not: mergeSchemasResolver,
    if: mergeIfThenElseSchemas,
    then: resolvers2.skip,
    else: resolvers2.skip,
    dependencies: mergeDependencies,
    dependentRequired: mergeDependencies,
    dependentSchemas: mergeObjects,
    propertyNames: mergeSchemasResolver,
    uniqueItems: resolvers2.booleanOr,
    contains: mergeSchemasResolver
  };
  function mergeSchemasResolver(keyword2, values2, mergedSchema, _schemas, options) {
    mergedSchema[keyword2] = _mergeSchemas(values2, options);
  }
  function cartesianProduct(arrays) {
    let result = [[]];
    for (const array2 of arrays) {
      const temp = [];
      for (const x of result) {
        for (const y of array2) {
          temp.push([...x, y]);
        }
      }
      result = temp;
    }
    return result;
  }
  function mergeOneOf(keyword2, values2, mergedSchema, _schemas, options) {
    if (values2.length === 1) {
      mergedSchema[keyword2] = values2[0];
      return;
    }
    const product = cartesianProduct(values2);
    const mergedOneOf = [];
    for (const combination of product) {
      try {
        const mergedSchema2 = _mergeSchemas(combination, options);
        if (mergedSchema2 !== void 0) {
          mergedOneOf.push(mergedSchema2);
        }
      } catch (error2) {
        if (error2 instanceof errors2.MergeError) continue;
        throw error2;
      }
    }
    mergedSchema[keyword2] = mergedOneOf;
  }
  function getSchemaForItem(schema, index) {
    const { items: items2, additionalItems: additionalItems2 } = schema;
    if (Array.isArray(items2)) {
      if (index < items2.length) {
        return items2[index];
      }
      return additionalItems2;
    }
    if (items2 !== void 0) {
      return items2;
    }
    return additionalItems2;
  }
  function mergeItems(keyword2, values2, mergedSchema, schemas2, options) {
    let maxArrayItemsLength = 0;
    for (const itemsSchema of values2) {
      if (Array.isArray(itemsSchema)) {
        maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
      }
    }
    if (maxArrayItemsLength === 0) {
      mergedSchema[keyword2] = _mergeSchemas(values2, options);
      return;
    }
    const mergedItemsSchemas = [];
    for (let i = 0; i < maxArrayItemsLength; i++) {
      const indexItemSchemas = [];
      for (const schema of schemas2) {
        const itemSchema = getSchemaForItem(schema, i);
        if (itemSchema !== void 0) {
          indexItemSchemas.push(itemSchema);
        }
      }
      mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
    }
    mergedSchema[keyword2] = mergedItemsSchemas;
  }
  function mergeAdditionalItems(keyword2, values2, mergedSchema, schemas2, options) {
    let hasArrayItems = false;
    for (const schema of schemas2) {
      if (Array.isArray(schema.items)) {
        hasArrayItems = true;
        break;
      }
    }
    if (!hasArrayItems) {
      mergedSchema[keyword2] = _mergeSchemas(values2, options);
      return;
    }
    const mergedAdditionalItemsSchemas = [];
    for (const schema of schemas2) {
      let additionalItemsSchema = schema.additionalItems;
      if (additionalItemsSchema === void 0 && !Array.isArray(schema.items)) {
        additionalItemsSchema = schema.items;
      }
      if (additionalItemsSchema !== void 0) {
        mergedAdditionalItemsSchemas.push(additionalItemsSchema);
      }
    }
    mergedSchema[keyword2] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
  }
  function getSchemaForProperty(schema, propertyName) {
    const { properties: properties2, patternProperties: patternProperties2, additionalProperties: additionalProperties2 } = schema;
    if (properties2?.[propertyName] !== void 0) {
      return properties2[propertyName];
    }
    for (const pattern2 of Object.keys(patternProperties2 ?? {})) {
      const regexp = new RegExp(pattern2);
      if (regexp.test(propertyName)) {
        return patternProperties2[pattern2];
      }
    }
    return additionalProperties2;
  }
  function mergeProperties(keyword2, _values, mergedSchema, schemas2, options) {
    const foundProperties = {};
    for (const currentSchema of schemas2) {
      const properties2 = currentSchema.properties ?? {};
      for (const propertyName of Object.keys(properties2)) {
        if (foundProperties[propertyName] !== void 0) continue;
        const propertySchema = properties2[propertyName];
        foundProperties[propertyName] = [propertySchema];
        for (const anotherSchema of schemas2) {
          if (currentSchema === anotherSchema) continue;
          const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
          if (propertySchema2 !== void 0) {
            foundProperties[propertyName].push(propertySchema2);
          }
        }
      }
    }
    const mergedProperties = {};
    for (const property of Object.keys(foundProperties)) {
      const propertySchemas = foundProperties[property];
      mergedProperties[property] = _mergeSchemas(propertySchemas, options);
    }
    mergedSchema[keyword2] = mergedProperties;
  }
  function mergeObjects(keyword2, values2, mergedSchema, _schemas, options) {
    const objectsProperties = {};
    for (const properties2 of values2) {
      for (const propertyName of Object.keys(properties2)) {
        if (objectsProperties[propertyName] === void 0) {
          objectsProperties[propertyName] = [];
        }
        objectsProperties[propertyName].push(properties2[propertyName]);
      }
    }
    const mergedProperties = {};
    for (const propertyName of Object.keys(objectsProperties)) {
      const propertySchemas = objectsProperties[propertyName];
      const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
      mergedProperties[propertyName] = mergedPropertySchema;
    }
    mergedSchema[keyword2] = mergedProperties;
  }
  function mergeIfThenElseSchemas(_keyword, _values, mergedSchema, schemas2, options) {
    for (let i = 0; i < schemas2.length; i++) {
      const subSchema = {
        if: schemas2[i].if,
        then: schemas2[i].then,
        else: schemas2[i].else
      };
      if (subSchema.if === void 0) continue;
      if (mergedSchema.if === void 0) {
        mergedSchema.if = subSchema.if;
        if (subSchema.then !== void 0) {
          mergedSchema.then = subSchema.then;
        }
        if (subSchema.else !== void 0) {
          mergedSchema.else = subSchema.else;
        }
        continue;
      }
      if (mergedSchema.then !== void 0) {
        mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
      }
      if (mergedSchema.else !== void 0) {
        mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
      }
    }
  }
  function mergeDependencies(keyword2, values2, mergedSchema) {
    const mergedDependencies = {};
    for (const dependencies2 of values2) {
      for (const propertyName of Object.keys(dependencies2)) {
        if (mergedDependencies[propertyName] === void 0) {
          mergedDependencies[propertyName] = [];
        }
        const mergedPropertyDependencies = mergedDependencies[propertyName];
        for (const propertyDependency of dependencies2[propertyName]) {
          if (!mergedPropertyDependencies.includes(propertyDependency)) {
            mergedPropertyDependencies.push(propertyDependency);
          }
        }
      }
    }
    mergedSchema[keyword2] = mergedDependencies;
  }
  function _mergeSchemas(schemas2, options) {
    if (schemas2.length === 0) return {};
    if (schemas2.length === 1) return schemas2[0];
    const mergedSchema = {};
    const keywords = {};
    let allSchemasAreTrue = true;
    for (const schema of schemas2) {
      if (schema === false) return false;
      if (schema === true) continue;
      allSchemasAreTrue = false;
      for (const keyword2 of Object.keys(schema)) {
        if (keywords[keyword2] === void 0) {
          keywords[keyword2] = [];
        }
        keywords[keyword2].push(schema[keyword2]);
      }
    }
    if (allSchemasAreTrue) return true;
    for (const keyword2 of Object.keys(keywords)) {
      const keywordValues = keywords[keyword2];
      const resolver = options.resolvers[keyword2] ?? options.defaultResolver;
      resolver(keyword2, keywordValues, mergedSchema, schemas2, options);
    }
    return mergedSchema;
  }
  function defaultResolver(keyword2, values2, mergedSchema, _schemas, options) {
    const onConflict = options.onConflict ?? "throw";
    if (values2.length === 1 || onConflict === "first") {
      mergedSchema[keyword2] = values2[0];
      return;
    }
    let allValuesEqual = true;
    for (let i = 1; i < values2.length; i++) {
      if (!deepEqual(values2[i], values2[0])) {
        allValuesEqual = false;
        break;
      }
    }
    if (allValuesEqual) {
      mergedSchema[keyword2] = values2[0];
      return;
    }
    if (onConflict === "throw") {
      throw new errors2.ResolverNotFoundError(keyword2, values2);
    }
    if (onConflict === "skip") {
      return;
    }
    throw new errors2.InvalidOnConflictOptionError(onConflict);
  }
  function mergeSchemas(schemas2, options = {}) {
    if (options.defaultResolver === void 0) {
      options.defaultResolver = defaultResolver;
    }
    options.resolvers = { ...keywordsResolvers, ...options.resolvers };
    const mergedSchema = _mergeSchemas(schemas2, options);
    return mergedSchema;
  }
  mergeJsonSchemas = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors2 };
  return mergeJsonSchemas;
}
var mergeSchemas_1;
var hasRequiredMergeSchemas;
function requireMergeSchemas() {
  if (hasRequiredMergeSchemas) return mergeSchemas_1;
  hasRequiredMergeSchemas = 1;
  const { mergeSchemas: _mergeSchemas } = requireMergeJsonSchemas();
  function mergeSchemas(schemas2) {
    return _mergeSchemas(schemas2, { onConflict: "skip" });
  }
  mergeSchemas_1 = mergeSchemas;
  return mergeSchemas_1;
}
var standalone = { exports: {} };
var hasRequiredStandalone$1;
function requireStandalone$1() {
  if (hasRequiredStandalone$1) return standalone.exports;
  hasRequiredStandalone$1 = 1;
  function buildStandaloneCode(contextFunc, context2, serializer2, validator2) {
    let ajvDependencyCode = "";
    if (context2.validatorSchemasIds.size > 0) {
      ajvDependencyCode += "const Validator = require('fast-json-stringify/lib/validator')\n";
      ajvDependencyCode += `const validatorState = ${JSON.stringify(validator2.getState())}
`;
      ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
    } else {
      ajvDependencyCode += "const validator = null\n";
    }
    const { schema, ...serializerState } = serializer2.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
  }
  standalone.exports = buildStandaloneCode;
  standalone.exports.dependencies = {
    Serializer: requireSerializer(),
    Validator: requireValidator()
  };
  return standalone.exports;
}
var hasRequiredFastJsonStringify;
function requireFastJsonStringify() {
  if (hasRequiredFastJsonStringify) return fastJsonStringify.exports;
  hasRequiredFastJsonStringify = 1;
  const { RefResolver } = requireJsonSchemaRefResolver();
  const Serializer = requireSerializer();
  const Validator = requireValidator();
  const Location = requireLocation();
  const validate2 = requireSchemaValidator();
  const mergeSchemas = requireMergeSchemas();
  const SINGLE_TICK = /'/g;
  let largeArraySize = 2e4;
  let largeArrayMechanism = "default";
  const serializerFns = `
const {
  asString,
  asNumber,
  asBoolean,
  asDateTime,
  asDate,
  asTime,
  asUnsafeString
} = serializer

const asInteger = serializer.asInteger.bind(serializer)

`;
  const validRoundingMethods = /* @__PURE__ */ new Set([
    "floor",
    "ceil",
    "round",
    "trunc"
  ]);
  const validLargeArrayMechanisms = /* @__PURE__ */ new Set([
    "default",
    "json-stringify"
  ]);
  let schemaIdCounter = 0;
  function isValidSchema(schema, name) {
    if (!validate2(schema)) {
      if (name) {
        name = `"${name}" `;
      } else {
        name = "";
      }
      const first = validate2.errors[0];
      const err2 = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
      err2.errors = isValidSchema.errors;
      throw err2;
    }
  }
  function resolveRef(context2, location2) {
    const ref2 = location2.schema.$ref;
    let hashIndex = ref2.indexOf("#");
    if (hashIndex === -1) {
      hashIndex = ref2.length;
    }
    const schemaId = ref2.slice(0, hashIndex) || location2.schemaId;
    const jsonPointer = ref2.slice(hashIndex) || "#";
    const schema = context2.refResolver.getSchema(schemaId, jsonPointer);
    if (schema === null) {
      throw new Error(`Cannot find reference "${ref2}"`);
    }
    const newLocation = new Location(schema, schemaId, jsonPointer);
    if (schema.$ref !== void 0) {
      return resolveRef(context2, newLocation);
    }
    return newLocation;
  }
  function getMergedLocation(context2, mergedSchemaId) {
    const mergedSchema = context2.refResolver.getSchema(mergedSchemaId, "#");
    return new Location(mergedSchema, mergedSchemaId, "#");
  }
  function getSchemaId(schema, rootSchemaId) {
    if (schema.$id && schema.$id.charAt(0) !== "#") {
      return schema.$id;
    }
    return rootSchemaId;
  }
  function getSafeSchemaRef(context2, location2) {
    let schemaRef = location2.getSchemaRef() || "";
    if (schemaRef.startsWith(context2.rootSchemaId)) {
      schemaRef = schemaRef.replace(context2.rootSchemaId, "") || "#";
    }
    return schemaRef;
  }
  function build(schema, options) {
    isValidSchema(schema);
    options = options || {};
    const context2 = {
      functions: [],
      functionsCounter: 0,
      functionsNamesBySchema: /* @__PURE__ */ new Map(),
      options,
      refResolver: new RefResolver(),
      rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
      validatorSchemasIds: /* @__PURE__ */ new Set(),
      mergedSchemasIds: /* @__PURE__ */ new Map(),
      recursiveSchemas: /* @__PURE__ */ new Set(),
      recursivePaths: /* @__PURE__ */ new Set(),
      buildingSet: /* @__PURE__ */ new Set(),
      uid: 0
    };
    const schemaId = getSchemaId(schema, context2.rootSchemaId);
    if (!context2.refResolver.hasSchema(schemaId)) {
      context2.refResolver.addSchema(schema, context2.rootSchemaId);
    }
    if (options.schema) {
      for (const key in options.schema) {
        const schema2 = options.schema[key];
        const schemaId2 = getSchemaId(schema2, key);
        if (!context2.refResolver.hasSchema(schemaId2)) {
          isValidSchema(schema2, key);
          context2.refResolver.addSchema(schema2, key);
        }
      }
    }
    if (options.rounding) {
      if (!validRoundingMethods.has(options.rounding)) {
        throw new Error(`Unsupported integer rounding method ${options.rounding}`);
      }
    }
    if (options.largeArrayMechanism) {
      if (validLargeArrayMechanisms.has(options.largeArrayMechanism)) {
        largeArrayMechanism = options.largeArrayMechanism;
      } else {
        throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
      }
    }
    if (options.largeArraySize) {
      const largeArraySizeType = typeof options.largeArraySize;
      let parsedNumber;
      if (largeArraySizeType === "string" && Number.isFinite(parsedNumber = Number.parseInt(options.largeArraySize, 10))) {
        largeArraySize = parsedNumber;
      } else if (largeArraySizeType === "number" && Number.isInteger(options.largeArraySize)) {
        largeArraySize = options.largeArraySize;
      } else if (largeArraySizeType === "bigint") {
        largeArraySize = Number(options.largeArraySize);
      } else {
        throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
      }
    }
    const location2 = new Location(schema, context2.rootSchemaId);
    detectRecursiveSchemas(context2, location2);
    const code2 = buildValue(context2, location2, "input");
    let contextFunctionCode = `
    ${serializerFns}
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
    if (code2 === "json += anonymous0(input)") {
      contextFunctionCode += `
    ${context2.functions.join("\n")}
    const main = anonymous0
    return main
    `;
    } else {
      contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code2}
      return json
    }
    ${context2.functions.join("\n")}
    return main
    `;
    }
    const serializer2 = new Serializer(options);
    const validator2 = new Validator(options.ajv);
    for (const schemaId2 of context2.validatorSchemasIds) {
      const schema2 = context2.refResolver.getSchema(schemaId2);
      validator2.addSchema(schema2, schemaId2);
      const dependencies2 = context2.refResolver.getSchemaDependencies(schemaId2);
      for (const [schemaId3, schema3] of Object.entries(dependencies2)) {
        validator2.addSchema(schema3, schemaId3);
      }
    }
    if (options.debugMode) {
      options.mode = "debug";
    }
    if (options.mode === "debug") {
      return {
        validator: validator2,
        serializer: serializer2,
        code: `validator
serializer
${contextFunctionCode}`,
        ajv: validator2.ajv
      };
    }
    const contextFunc = new Function("validator", "serializer", contextFunctionCode);
    if (options.mode === "standalone") {
      const buildStandaloneCode = requireStandalone$1();
      return buildStandaloneCode(contextFunc, context2, serializer2, validator2);
    }
    return contextFunc(validator2, serializer2);
  }
  const objectKeywords = [
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "maxProperties",
    "minProperties",
    "dependencies"
  ];
  const arrayKeywords = [
    "items",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "contains"
  ];
  const stringKeywords = [
    "maxLength",
    "minLength",
    "pattern"
  ];
  const numberKeywords = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum"
  ];
  function inferTypeByKeyword(schema) {
    for (const keyword2 of objectKeywords) {
      if (keyword2 in schema) return "object";
    }
    for (const keyword2 of arrayKeywords) {
      if (keyword2 in schema) return "array";
    }
    for (const keyword2 of stringKeywords) {
      if (keyword2 in schema) return "string";
    }
    for (const keyword2 of numberKeywords) {
      if (keyword2 in schema) return "number";
    }
    return schema.type;
  }
  function buildExtraObjectPropertiesSerializer(context2, location2, addComma, objVar) {
    const schema = location2.schema;
    const propertiesKeys = Object.keys(schema.properties || {});
    let code2 = `
    for (const key of Object.keys(${objVar})) {
      if (
        ${propertiesKeys.length > 0 ? propertiesKeys.map((k) => `key === ${JSON.stringify(k)}`).join(" || ") + " ||" : ""}
        ${objVar}[key] === undefined ||
        typeof ${objVar}[key] === 'function' ||
        typeof ${objVar}[key] === 'symbol'
      ) continue
      const value = ${objVar}[key]
  `;
    const patternPropertiesLocation = location2.getPropertyLocation("patternProperties");
    const patternPropertiesSchema = patternPropertiesLocation.schema;
    if (patternPropertiesSchema !== void 0) {
      for (const propertyKey in patternPropertiesSchema) {
        const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
        code2 += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += asString(key) + JSON_STR_COLONS
          ${buildValue(context2, propertyLocation, "value")}
          continue
        }
      `;
      }
    }
    const additionalPropertiesLocation = location2.getPropertyLocation("additionalProperties");
    const additionalPropertiesSchema = additionalPropertiesLocation.schema;
    if (additionalPropertiesSchema !== void 0) {
      if (additionalPropertiesSchema === true) {
        code2 += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
      } else {
        const propertyLocation = location2.getPropertyLocation("additionalProperties");
        code2 += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS
        ${buildValue(context2, propertyLocation, "value")}
      `;
      }
    }
    code2 += `
    }
  `;
    return code2;
  }
  function buildInnerObject(context2, location2, objVar) {
    const schema = location2.schema;
    const propertiesLocation = location2.getPropertyLocation("properties");
    const requiredProperties = schema.required || [];
    const propertiesKeys = Object.keys(schema.properties || {}).sort(
      (key1, key2) => {
        const required1 = requiredProperties.includes(key1);
        const required2 = requiredProperties.includes(key2);
        return required1 === required2 ? 0 : required1 ? -1 : 1;
      }
    );
    let code2 = "";
    for (const key of requiredProperties) {
      if (!propertiesKeys.includes(key)) {
        const sanitizedKey = JSON.stringify(key);
        code2 += `if (${objVar}[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
      }
    }
    code2 += "json += JSON_STR_BEGIN_OBJECT\n";
    const localUid = context2.uid++;
    let addComma = "";
    if (requiredProperties.length > 0) {
      for (let i = 0; i < propertiesKeys.length; i++) {
        const key = propertiesKeys[i];
        const propertyLocation = propertiesLocation.getPropertyLocation(key);
        let resolvedLocation = propertyLocation;
        if (propertyLocation.schema.$ref) {
          resolvedLocation = resolveRef(context2, propertyLocation);
        }
        const sanitizedKey = JSON.stringify(key);
        const value = `value_${key.replace(/[^a-zA-Z0-9]/g, "_")}_${context2.uid++}`;
        const defaultValue = resolvedLocation.schema.default;
        const isRequired = requiredProperties.includes(key);
        const currentAddComma = i === 0 ? "" : "json += JSON_STR_COMMA";
        code2 += `
      const ${value} = ${objVar}[${sanitizedKey}]
      if (${value} !== undefined) {
        ${currentAddComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context2, resolvedLocation, `${value}`)}
      }`;
        if (defaultValue !== void 0) {
          code2 += ` else {
        ${currentAddComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
        } else if (isRequired) {
          code2 += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
        } else {
          code2 += "\n";
        }
      }
      addComma = "json += JSON_STR_COMMA";
    } else {
      const needsRuntimeComma = propertiesKeys.length > 1 || schema.patternProperties || schema.additionalProperties !== void 0 && schema.additionalProperties !== false;
      if (needsRuntimeComma) {
        code2 += `let addComma_${localUid} = false
`;
        addComma = `!addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)`;
      }
      for (const key of propertiesKeys) {
        let propertyLocation = propertiesLocation.getPropertyLocation(key);
        if (propertyLocation.schema.$ref) {
          propertyLocation = resolveRef(context2, propertyLocation);
        }
        const sanitizedKey = JSON.stringify(key);
        const value = `value_${key.replace(/[^a-zA-Z0-9]/g, "_")}_${context2.uid++}`;
        const defaultValue = propertyLocation.schema.default;
        const isRequired = requiredProperties.includes(key);
        code2 += `
          const ${value} = ${objVar}[${sanitizedKey}]
          if (${value} !== undefined) {
            ${addComma}
            json += ${JSON.stringify(sanitizedKey + ":")}
            ${buildValue(context2, propertyLocation, `${value}`)}
          }`;
        if (defaultValue !== void 0) {
          code2 += ` else {
            ${addComma}
            json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
          }
          `;
        } else if (isRequired) {
          code2 += ` else {
            throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
          }
          `;
        } else {
          code2 += "\n";
        }
      }
    }
    if (schema.patternProperties || schema.additionalProperties) {
      code2 += buildExtraObjectPropertiesSerializer(context2, location2, addComma, objVar);
    }
    code2 += `
    json += JSON_STR_END_OBJECT
  `;
    return code2;
  }
  function mergeLocations(context2, mergedSchemaId, mergedLocations) {
    for (let i = 0, mergedLocationsLength = mergedLocations.length; i < mergedLocationsLength; i++) {
      const location2 = mergedLocations[i];
      const schema = location2.schema;
      if (schema.$ref) {
        mergedLocations[i] = resolveRef(context2, location2);
      }
    }
    const mergedSchemas = [];
    for (const location2 of mergedLocations) {
      const schema = cloneOriginSchema(context2, location2.schema, location2.schemaId);
      delete schema.$id;
      mergedSchemas.push(schema);
    }
    const mergedSchema = mergeSchemas(mergedSchemas);
    const mergedLocation = new Location(mergedSchema, mergedSchemaId);
    context2.refResolver.addSchema(mergedSchema, mergedSchemaId);
    return mergedLocation;
  }
  function cloneOriginSchema(context2, schema, schemaId) {
    const clonedSchema = Array.isArray(schema) ? [] : {};
    if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
      schemaId = schema.$id;
    }
    const mergedSchemaRef = context2.mergedSchemasIds.get(schema);
    if (mergedSchemaRef) {
      context2.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
    }
    for (const key in schema) {
      let value = schema[key];
      if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
        value = schemaId + value;
      }
      if (typeof value === "object" && value !== null) {
        value = cloneOriginSchema(context2, value, schemaId);
      }
      clonedSchema[key] = value;
    }
    return clonedSchema;
  }
  function toJSON(variableName) {
    return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
  }
  function buildObject(context2, location2, input) {
    const schema = location2.schema;
    if (context2.functionsNamesBySchema.has(schema)) {
      const funcName = context2.functionsNamesBySchema.get(schema);
      return `json += ${funcName}(${input})`;
    }
    const nullable2 = schema.nullable === true;
    const schemaId = location2.schemaId || "";
    const jsonPointer = location2.jsonPointer || "";
    const fullPath = `${schemaId}#${jsonPointer}`;
    if (context2.recursivePaths.has(fullPath) || context2.buildingSet.has(schema)) {
      const functionName = generateFuncName(context2);
      context2.functionsNamesBySchema.set(schema, functionName);
      const schemaRef = getSafeSchemaRef(context2, location2);
      const functionCode = `
      // ${schemaRef}
      function ${functionName} (input) {
        const obj = ${toJSON("input")}
        if (obj === null) return ${nullable2 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_OBJECT"}
        let json = ''

        ${buildInnerObject(context2, location2, "obj")}
        return json
      }
    `;
      context2.functions.push(functionCode);
      return `json += ${functionName}(${input})`;
    }
    context2.buildingSet.add(schema);
    const objVar = `obj_${context2.uid++}`;
    const code2 = `
    const ${objVar} = ${toJSON(input)}
    if (${objVar} === null) {
      json += ${nullable2 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_OBJECT"}
    } else {
      ${buildInnerObject(context2, location2, objVar)}
    }
  `;
    context2.buildingSet.delete(schema);
    return code2;
  }
  function buildArray(context2, location2, input) {
    const schema = location2.schema;
    let itemsLocation = location2.getPropertyLocation("items");
    itemsLocation.schema = itemsLocation.schema || {};
    if (itemsLocation.schema.$ref) {
      itemsLocation = resolveRef(context2, itemsLocation);
    }
    const itemsSchema = itemsLocation.schema;
    if (context2.functionsNamesBySchema.has(schema)) {
      const funcName = context2.functionsNamesBySchema.get(schema);
      return `json += ${funcName}(${input})`;
    }
    const nullable2 = schema.nullable === true;
    const schemaId = location2.schemaId || "";
    const jsonPointer = location2.jsonPointer || "";
    const fullPath = `${schemaId}#${jsonPointer}`;
    if (context2.recursivePaths.has(fullPath) || context2.buildingSet.has(schema)) {
      const functionName = generateFuncName(context2);
      context2.functionsNamesBySchema.set(schema, functionName);
      const schemaRef = getSafeSchemaRef(context2, location2);
      let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
      let json = ''
  `;
      functionCode += `
    if (obj === null) return ${nullable2 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
      if (!schema.additionalItems && Array.isArray(itemsSchema)) {
        functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
      }
      if (largeArrayMechanism === "json-stringify") {
        functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
      }
      functionCode += `
    json += JSON_STR_BEGIN_ARRAY
  `;
      if (Array.isArray(itemsSchema)) {
        for (let i = 0, itemsSchemaLength = itemsSchema.length; i < itemsSchemaLength; i++) {
          let item = itemsSchema[i];
          let itemLocation = itemsLocation.getPropertyLocation(i);
          if (itemLocation.schema.$ref) {
            itemLocation = resolveRef(context2, itemLocation);
            item = itemLocation.schema;
          }
          const value = `value_${i}`;
          functionCode += `const ${value} = obj[${i}]`;
          const tmpRes = buildValue(context2, itemLocation, value);
          functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, value)}) {
            if (${i}) {
              json += JSON_STR_COMMA
            }
            ${tmpRes}
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
        }
        if (schema.additionalItems) {
          functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          if (i) {
            json += JSON_STR_COMMA
          }
          json += JSON.stringify(obj[i])
        }`;
        }
      } else {
        const code2 = buildValue(context2, itemsLocation, "value");
        functionCode += `
      if (arrayLength > 0) {
        const value = obj[0]
        ${code2}
        for (let i = 1; i < arrayLength; i++) {
          json += JSON_STR_COMMA
          const value = obj[i]
          ${code2}
        }
      }`;
      }
      functionCode += `
      return json + JSON_STR_END_ARRAY
    }`;
      context2.functions.push(functionCode);
      return `json += ${functionName}(${input})`;
    }
    context2.buildingSet.add(schema);
    const safeSchemaRef = getSafeSchemaRef(context2, location2);
    const objVar = `obj_${context2.uid++}`;
    let inlinedCode = `
    const ${objVar} = ${input}
    if (${objVar} === null) {
      json += ${nullable2 ? "JSON_STR_NULL" : "JSON_STR_EMPTY_ARRAY"}
    } else if (!Array.isArray(${objVar})) {
      throw new TypeError(\`The value of '${safeSchemaRef}' does not match schema definition.\`)
    } else {
      const arrayLength_${objVar} = ${objVar}.length
  `;
    if (!schema.additionalItems && Array.isArray(itemsSchema)) {
      inlinedCode += `
      if (arrayLength_${objVar} > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
    }
    if (largeArrayMechanism === "json-stringify") {
      inlinedCode += `if (arrayLength_${objVar} >= ${largeArraySize}) json += JSON.stringify(${objVar})
 else {`;
    }
    inlinedCode += `
    json += JSON_STR_BEGIN_ARRAY
  `;
    if (Array.isArray(itemsSchema)) {
      const localUid = context2.uid++;
      inlinedCode += `let addComma_${localUid} = false
`;
      for (let i = 0, itemsSchemaLength = itemsSchema.length; i < itemsSchemaLength; i++) {
        let item = itemsSchema[i];
        let itemLocation = itemsLocation.getPropertyLocation(i);
        if (itemLocation.schema.$ref) {
          itemLocation = resolveRef(context2, itemLocation);
          item = itemLocation.schema;
        }
        const value = `value_${i}_${context2.uid++}`;
        inlinedCode += `const ${value} = ${objVar}[${i}]`;
        const tmpRes = buildValue(context2, itemLocation, value);
        inlinedCode += `
        if (${i} < arrayLength_${objVar}) {
          if (${buildArrayTypeCondition(item.type, value)}) {
            !addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)
            ${tmpRes}
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
      }
      if (schema.additionalItems) {
        inlinedCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength_${objVar}; i++) {
          !addComma_${localUid} && (addComma_${localUid} = true) || (json += JSON_STR_COMMA)
          json += JSON.stringify(${objVar}[i])
        }`;
      }
    } else {
      const code2 = buildValue(context2, itemsLocation, "value");
      inlinedCode += `
      if (arrayLength_${objVar} > 0) {
        const value = ${objVar}[0]
        ${code2}
        for (let i = 1; i < arrayLength_${objVar}; i++) {
          json += JSON_STR_COMMA
          const value = ${objVar}[i]
          ${code2}
        }
      }`;
    }
    inlinedCode += `
    json += JSON_STR_END_ARRAY
  `;
    if (largeArrayMechanism === "json-stringify") {
      inlinedCode += "}";
    }
    inlinedCode += "}";
    context2.buildingSet.delete(schema);
    return inlinedCode;
  }
  function buildArrayTypeCondition(type2, accessor) {
    let condition;
    switch (type2) {
      case "null":
        condition = `${accessor} === null`;
        break;
      case "string":
        condition = `typeof ${accessor} === 'string' ||
      ${accessor} === null ||
      ${accessor} instanceof Date ||
      ${accessor} instanceof RegExp ||
      (
        typeof ${accessor} === "object" &&
        typeof ${accessor}.toString === "function" &&
        ${accessor}.toString !== Object.prototype.toString
      )`;
        break;
      case "integer":
        condition = `Number.isInteger(${accessor})`;
        break;
      case "number":
        condition = `Number.isFinite(${accessor})`;
        break;
      case "boolean":
        condition = `typeof ${accessor} === 'boolean'`;
        break;
      case "object":
        condition = `${accessor} && typeof ${accessor} === 'object' && ${accessor}.constructor === Object`;
        break;
      case "array":
        condition = `Array.isArray(${accessor})`;
        break;
      default:
        if (Array.isArray(type2)) {
          const conditions = type2.map((subType) => {
            return buildArrayTypeCondition(subType, accessor);
          });
          condition = `(${conditions.join(" || ")})`;
        }
    }
    return condition;
  }
  function generateFuncName(context2) {
    return "anonymous" + context2.functionsCounter++;
  }
  function buildMultiTypeSerializer(context2, location2, input) {
    const schema = location2.schema;
    const types2 = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
    let code2 = "";
    types2.forEach((type2, index) => {
      location2.schema = { ...location2.schema, type: type2 };
      const nestedResult = buildSingleTypeSerializer(context2, location2, input);
      const statement = index === 0 ? "if" : "else if";
      switch (type2) {
        case "null":
          code2 += `
          ${statement} (${input} === null) {
            ${nestedResult}
          }
          `;
          break;
        case "string": {
          code2 += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          ) {
            ${nestedResult}
          }
        `;
          break;
        }
        case "array": {
          code2 += `
          ${statement}(Array.isArray(${input})) {
            ${nestedResult}
          }
        `;
          break;
        }
        case "integer": {
          code2 += `
          ${statement}(Number.isInteger(${input}) || ${input} === null) {
            ${nestedResult}
          }
        `;
          break;
        }
        default: {
          code2 += `
          ${statement}(typeof ${input} === "${type2}" || ${input} === null) {
            ${nestedResult}
          }
        `;
          break;
        }
      }
    });
    code2 += `
    else throw new TypeError(\`The value of '${getSafeSchemaRef(context2, location2)}' does not match schema definition.\`)
  `;
    return code2;
  }
  function buildSingleTypeSerializer(context2, location2, input) {
    const schema = location2.schema;
    switch (schema.type) {
      case "null":
        return "json += JSON_STR_NULL";
      case "string": {
        if (schema.format === "date-time") {
          return `json += asDateTime(${input})`;
        } else if (schema.format === "date") {
          return `json += asDate(${input})`;
        } else if (schema.format === "time") {
          return `json += asTime(${input})`;
        } else if (schema.format === "unsafe") {
          return `json += asUnsafeString(${input})`;
        } else {
          return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += asString(${input}.source)
          } else {
            json += asString(${input}.toString())
          }
        } else {
          json += asString(${input})
        }
        `;
        }
      }
      case "integer":
        return `json += asInteger(${input})`;
      case "number":
        return `json += asNumber(${input})`;
      case "boolean":
        return `json += asBoolean(${input})`;
      case "object": {
        return buildObject(context2, location2, input);
      }
      case "array": {
        return buildArray(context2, location2, input);
      }
      case void 0:
        return `json += JSON.stringify(${input})`;
      default:
        throw new Error(`${schema.type} unsupported`);
    }
  }
  function detectRecursiveSchemas(context2, location2) {
    const pathStack = /* @__PURE__ */ new Set();
    function traverse(location3) {
      const schema = location3.schema;
      if (typeof schema !== "object" || schema === null) return;
      const schemaId = location3.schemaId || "";
      const jsonPointer = location3.jsonPointer || "";
      const fullPath = `${schemaId}#${jsonPointer}`;
      if (pathStack.has(fullPath)) {
        let inCycle = false;
        for (const p of pathStack) {
          if (p === fullPath) inCycle = true;
          if (inCycle) context2.recursivePaths.add(p);
        }
        context2.recursivePaths.add(fullPath);
        return;
      }
      pathStack.add(fullPath);
      if (schema.$ref) {
        try {
          const res2 = resolveRef(context2, location3);
          traverse(res2);
        } catch (err2) {
        }
      }
      if (schema.properties) {
        const propertiesLocation = location3.getPropertyLocation("properties");
        for (const key in schema.properties) {
          traverse(propertiesLocation.getPropertyLocation(key));
        }
      }
      if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
        traverse(location3.getPropertyLocation("additionalProperties"));
      }
      if (schema.patternProperties) {
        const patternPropertiesLocation = location3.getPropertyLocation("patternProperties");
        for (const key in schema.patternProperties) {
          traverse(patternPropertiesLocation.getPropertyLocation(key));
        }
      }
      if (schema.items) {
        const itemsLocation = location3.getPropertyLocation("items");
        if (Array.isArray(schema.items)) {
          for (let i = 0; i < schema.items.length; i++) {
            traverse(itemsLocation.getPropertyLocation(i));
          }
        } else {
          traverse(itemsLocation);
        }
      }
      if (schema.additionalItems && typeof schema.additionalItems === "object") {
        traverse(location3.getPropertyLocation("additionalItems"));
      }
      if (schema.oneOf) {
        const oneOfLocation = location3.getPropertyLocation("oneOf");
        for (let i = 0; i < schema.oneOf.length; i++) {
          traverse(oneOfLocation.getPropertyLocation(i));
        }
      }
      if (schema.anyOf) {
        const anyOfLocation = location3.getPropertyLocation("anyOf");
        for (let i = 0; i < schema.anyOf.length; i++) {
          traverse(anyOfLocation.getPropertyLocation(i));
        }
      }
      if (schema.allOf) {
        const allOfLocation = location3.getPropertyLocation("allOf");
        for (let i = 0; i < schema.allOf.length; i++) {
          traverse(allOfLocation.getPropertyLocation(i));
        }
      }
      if (schema.then) traverse(location3.getPropertyLocation("then"));
      if (schema.else) traverse(location3.getPropertyLocation("else"));
      pathStack.delete(fullPath);
    }
    traverse(location2);
  }
  function buildConstSerializer(location2, input) {
    const schema = location2.schema;
    const type2 = schema.type;
    const hasNullType = Array.isArray(type2) && type2.includes("null");
    let code2 = "";
    if (hasNullType) {
      code2 += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
    }
    code2 += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
    if (hasNullType) {
      code2 += `
      }
    `;
    }
    return code2;
  }
  function buildAllOf(context2, location2, input) {
    const schema = location2.schema;
    let mergedSchemaId = context2.mergedSchemasIds.get(schema);
    if (mergedSchemaId) {
      const mergedLocation2 = getMergedLocation(context2, mergedSchemaId);
      return buildValue(context2, mergedLocation2, input);
    }
    mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
    context2.mergedSchemasIds.set(schema, mergedSchemaId);
    const { allOf: allOf2, ...schemaWithoutAllOf } = location2.schema;
    const locations = [
      new Location(
        schemaWithoutAllOf,
        location2.schemaId,
        location2.jsonPointer
      )
    ];
    const allOfsLocation = location2.getPropertyLocation("allOf");
    for (let i = 0, allOfLength = allOf2.length; i < allOfLength; i++) {
      locations.push(allOfsLocation.getPropertyLocation(i));
    }
    const mergedLocation = mergeLocations(context2, mergedSchemaId, locations);
    return buildValue(context2, mergedLocation, input);
  }
  function buildOneOf(context2, location2, input) {
    context2.validatorSchemasIds.add(location2.schemaId);
    const schema = location2.schema;
    const type2 = schema.anyOf ? "anyOf" : "oneOf";
    const { [type2]: oneOfs, ...schemaWithoutAnyOf } = location2.schema;
    const locationWithoutOneOf = new Location(
      schemaWithoutAnyOf,
      location2.schemaId,
      location2.jsonPointer
    );
    const oneOfsLocation = location2.getPropertyLocation(type2);
    let code2 = "";
    for (let index = 0, oneOfsLength = oneOfs.length; index < oneOfsLength; index++) {
      const optionLocation = oneOfsLocation.getPropertyLocation(index);
      const optionSchema = optionLocation.schema;
      let mergedSchemaId = context2.mergedSchemasIds.get(optionSchema);
      let mergedLocation = null;
      if (mergedSchemaId) {
        mergedLocation = getMergedLocation(context2, mergedSchemaId);
      } else {
        mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context2.mergedSchemasIds.set(optionSchema, mergedSchemaId);
        mergedLocation = mergeLocations(context2, mergedSchemaId, [
          locationWithoutOneOf,
          optionLocation
        ]);
      }
      const nestedResult = buildValue(context2, mergedLocation, input);
      const schemaRef = optionLocation.getSchemaRef();
      code2 += `
      ${index === 0 ? "if" : "else if"}(validator.validate("${schemaRef}", ${input})) {
        ${nestedResult}
      }
    `;
    }
    code2 += `
    else throw new TypeError(\`The value of '${getSafeSchemaRef(context2, location2)}' does not match schema definition.\`)
  `;
    return code2;
  }
  function buildIfThenElse(context2, location2, input) {
    context2.validatorSchemasIds.add(location2.schemaId);
    const {
      if: ifSchema,
      then: thenSchema,
      else: elseSchema,
      ...schemaWithoutIfThenElse
    } = location2.schema;
    const rootLocation = new Location(
      schemaWithoutIfThenElse,
      location2.schemaId,
      location2.jsonPointer
    );
    const ifLocation = location2.getPropertyLocation("if");
    const ifSchemaRef = ifLocation.getSchemaRef();
    const thenLocation = location2.getPropertyLocation("then");
    let thenMergedSchemaId = context2.mergedSchemasIds.get(thenSchema);
    let thenMergedLocation = null;
    if (thenMergedSchemaId) {
      thenMergedLocation = getMergedLocation(context2, thenMergedSchemaId);
    } else {
      thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context2.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
      thenMergedLocation = mergeLocations(context2, thenMergedSchemaId, [
        rootLocation,
        thenLocation
      ]);
    }
    if (!elseSchema) {
      return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context2, thenMergedLocation, input)}
      } else {
        ${buildValue(context2, rootLocation, input)}
      }
    `;
    }
    const elseLocation = location2.getPropertyLocation("else");
    let elseMergedSchemaId = context2.mergedSchemasIds.get(elseSchema);
    let elseMergedLocation = null;
    if (elseMergedSchemaId) {
      elseMergedLocation = getMergedLocation(context2, elseMergedSchemaId);
    } else {
      elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context2.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
      elseMergedLocation = mergeLocations(context2, elseMergedSchemaId, [
        rootLocation,
        elseLocation
      ]);
    }
    return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context2, thenMergedLocation, input)}
    } else {
      ${buildValue(context2, elseMergedLocation, input)}
    }
  `;
  }
  function buildValue(context2, location2, input) {
    let schema = location2.schema;
    if (typeof schema === "boolean") {
      return `json += JSON.stringify(${input})`;
    }
    if (schema.$ref) {
      location2 = resolveRef(context2, location2);
      schema = location2.schema;
    }
    if (schema.allOf) {
      return buildAllOf(context2, location2, input);
    }
    if (schema.anyOf || schema.oneOf) {
      return buildOneOf(context2, location2, input);
    }
    if (schema.if && schema.then) {
      return buildIfThenElse(context2, location2, input);
    }
    if (schema.type === void 0) {
      const inferredType = inferTypeByKeyword(schema);
      if (inferredType) {
        schema.type = inferredType;
      }
    }
    let code2 = "";
    const type2 = schema.type;
    const nullable2 = schema.nullable === true;
    if (nullable2) {
      code2 += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
    }
    if (schema.const !== void 0) {
      code2 += buildConstSerializer(location2, input);
    } else if (Array.isArray(type2)) {
      code2 += buildMultiTypeSerializer(context2, location2, input);
    } else {
      code2 += buildSingleTypeSerializer(context2, location2, input);
    }
    if (nullable2) {
      code2 += `
      }
    `;
    }
    return code2;
  }
  fastJsonStringify.exports = build;
  fastJsonStringify.exports.default = build;
  fastJsonStringify.exports.build = build;
  fastJsonStringify.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
  fastJsonStringify.exports.restore = function({ code: code2, validator: validator2, serializer: serializer2 }) {
    return Function.apply(null, ["validator", "serializer", code2]).apply(null, [validator2, serializer2]);
  };
  return fastJsonStringify.exports;
}
var hasRequiredStandalone;
function requireStandalone() {
  if (hasRequiredStandalone) return standalone$1;
  hasRequiredStandalone = 1;
  const fastJsonStringify2 = requireFastJsonStringify();
  function SerializerSelector() {
    return function buildSerializerFactory(externalSchemas, serializerOpts) {
      const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
      return responseSchemaCompiler.bind(null, fjsOpts);
    };
  }
  function responseSchemaCompiler(fjsOpts, {
    schema
    /* method, url, httpStatus */
  }) {
    if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
      fjsOpts.schema = { ...fjsOpts.schema };
      delete fjsOpts.schema[schema.$id];
    }
    return fastJsonStringify2(schema, fjsOpts);
  }
  function StandaloneSerializer(options = { readMode: true }) {
    if (options.readMode === true && typeof options.restoreFunction !== "function") {
      throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
    }
    if (options.readMode !== true && typeof options.storeFunction !== "function") {
      throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = SerializerSelector();
    return function wrapper(externalSchemas, serializerOpts = {}) {
      serializerOpts.mode = "standalone";
      const compiler = factory(externalSchemas, serializerOpts);
      return function(opts) {
        const serializeFuncCode = compiler(opts);
        options.storeFunction(opts, serializeFuncCode);
        return new Function(serializeFuncCode);
      };
    };
  }
  standalone$1.SerializerSelector = SerializerSelector;
  standalone$1.StandaloneSerializer = StandaloneSerializer;
  standalone$1.default = StandaloneSerializer;
  return standalone$1;
}
var hasRequiredFastJsonStringifyCompiler;
function requireFastJsonStringifyCompiler() {
  if (hasRequiredFastJsonStringifyCompiler) return fastJsonStringifyCompiler.exports;
  hasRequiredFastJsonStringifyCompiler = 1;
  const { SerializerSelector, StandaloneSerializer } = requireStandalone();
  fastJsonStringifyCompiler.exports = SerializerSelector;
  fastJsonStringifyCompiler.exports.default = SerializerSelector;
  fastJsonStringifyCompiler.exports.SerializerSelector = SerializerSelector;
  fastJsonStringifyCompiler.exports.StandaloneSerializer = StandaloneSerializer;
  return fastJsonStringifyCompiler.exports;
}
var schemaController;
var hasRequiredSchemaController;
function requireSchemaController() {
  if (hasRequiredSchemaController) return schemaController;
  hasRequiredSchemaController = 1;
  const { buildSchemas } = requireSchemas();
  function buildSchemaController(parentSchemaCtrl, opts) {
    if (parentSchemaCtrl) {
      return new SchemaController(parentSchemaCtrl, opts);
    }
    const compilersFactory = Object.assign({
      buildValidator: null,
      buildSerializer: null
    }, opts?.compilersFactory);
    if (!compilersFactory.buildValidator) {
      const ValidatorSelector = requireAjvCompiler();
      compilersFactory.buildValidator = ValidatorSelector();
    }
    if (!compilersFactory.buildSerializer) {
      const SerializerSelector = requireFastJsonStringifyCompiler();
      compilersFactory.buildSerializer = SerializerSelector();
    }
    const option = {
      bucket: opts && opts.bucket || buildSchemas,
      compilersFactory,
      isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
      isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
    };
    return new SchemaController(void 0, option);
  }
  class SchemaController {
    constructor(parent, options) {
      this.opts = options || parent?.opts;
      this.addedSchemas = false;
      this.compilersFactory = this.opts.compilersFactory;
      if (parent) {
        this.schemaBucket = this.opts.bucket(parent.getSchemas());
        this.validatorCompiler = parent.getValidatorCompiler();
        this.serializerCompiler = parent.getSerializerCompiler();
        this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
        this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
        this.parent = parent;
      } else {
        this.schemaBucket = this.opts.bucket();
        this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
        this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
      }
    }
    // Bucket interface
    add(schema) {
      this.addedSchemas = true;
      return this.schemaBucket.add(schema);
    }
    getSchema(schemaId) {
      return this.schemaBucket.getSchema(schemaId);
    }
    getSchemas() {
      return this.schemaBucket.getSchemas();
    }
    setValidatorCompiler(validatorCompiler2) {
      this.compilersFactory = Object.assign(
        {},
        this.compilersFactory,
        { buildValidator: () => validatorCompiler2 }
      );
      this.validatorCompiler = validatorCompiler2;
      this.isCustomValidatorCompiler = true;
    }
    setSerializerCompiler(serializerCompiler2) {
      this.compilersFactory = Object.assign(
        {},
        this.compilersFactory,
        { buildSerializer: () => serializerCompiler2 }
      );
      this.serializerCompiler = serializerCompiler2;
      this.isCustomSerializerCompiler = true;
    }
    getValidatorCompiler() {
      return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
    }
    getSerializerCompiler() {
      return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
    }
    getSerializerBuilder() {
      return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
    }
    getValidatorBuilder() {
      return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
    }
    /**
     * This method will be called when a validator must be setup.
     * Do not setup the compiler more than once
     * @param {object} serverOptions the fastify server options
     */
    setupValidator(serverOptions) {
      const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
    }
    /**
     * This method will be called when a serializer must be setup.
     * Do not setup the compiler more than once
     * @param {object} serverOptions the fastify server options
     */
    setupSerializer(serverOptions) {
      const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
    }
  }
  SchemaController.buildSchemaController = buildSchemaController;
  schemaController = SchemaController;
  return schemaController;
}
var pluginUtils = { exports: {} };
var re = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug;
  return debug_1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports$1) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug = requireDebug();
    exports$1 = module.exports = {};
    const re2 = exports$1.re = [];
    const safeRe = exports$1.safeRe = [];
    const src = exports$1.src = [];
    const safeSrc = exports$1.safeSrc = [];
    const t = exports$1.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports$1.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports$1.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports$1.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver$1;
var hasRequiredSemver$1;
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$1;
  hasRequiredSemver$1 = 1;
  const debug = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id2) => {
          if (/^[0-9]+$/.test(id2)) {
            const num = +id2;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id2;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver$1 = SemVer;
  return semver$1;
}
var parse_1$1;
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse_1$1;
  hasRequiredParse$1 = 1;
  const SemVer = requireSemver$1();
  const parse2 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1$1 = parse2;
  return parse_1$1;
}
var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse2 = requireParse$1();
  const valid2 = (version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
var clean_1;
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse2 = requireParse$1();
  const clean = (version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  clean_1 = clean;
  return clean_1;
}
var inc_1;
var hasRequiredInc;
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer = requireSemver$1();
  const inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(
        version2 instanceof SemVer ? version2.version : version2,
        options
      ).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  inc_1 = inc;
  return inc_1;
}
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse2 = requireParse$1();
  const diff = (version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  diff_1 = diff;
  return diff_1;
}
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver$1();
  const major = (a, loose) => new SemVer(a, loose).major;
  major_1 = major;
  return major_1;
}
var minor_1;
var hasRequiredMinor;
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer = requireSemver$1();
  const minor = (a, loose) => new SemVer(a, loose).minor;
  minor_1 = minor;
  return minor_1;
}
var patch_1;
var hasRequiredPatch;
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer = requireSemver$1();
  const patch = (a, loose) => new SemVer(a, loose).patch;
  patch_1 = patch;
  return patch_1;
}
var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse2 = requireParse$1();
  const prerelease = (version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  prerelease_1 = prerelease;
  return prerelease_1;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver$1();
  const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  compare_1 = compare;
  return compare_1;
}
var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare = requireCompare();
  const rcompare = (a, b, loose) => compare(b, a, loose);
  rcompare_1 = rcompare;
  return rcompare_1;
}
var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare = requireCompare();
  const compareLoose = (a, b) => compare(a, b, true);
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer = requireSemver$1();
  const compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  sort_1 = sort;
  return sort_1;
}
var rsort_1;
var hasRequiredRsort;
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  rsort_1 = rsort;
  return rsort_1;
}
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = (a, b, loose) => compare(a, b, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = (a, b, loose) => compare(a, b, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = (a, b, loose) => compare(a, b, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = (a, b, loose) => compare(a, b, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = (a, b, loose) => compare(a, b, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = (a, b, loose) => compare(a, b, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver$1();
  const parse2 = requireParse$1();
  const { safeRe: re2, t } = requireRe();
  const coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  coerce_1 = coerce;
  return coerce_1;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range2, options) {
      options = parseOptions(options);
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached2 = cache.get(memoKey);
      if (cached2) {
        return cached2;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range2);
      range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2);
      range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range2);
      range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = requireLrucache();
  const cache = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t.BUILD], "");
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = /* @__PURE__ */ Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t } = requireRe();
  const cmp = requireCmp();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const Range = requireRange();
  return comparator;
}
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies = (version2, range2, options) => {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  };
  satisfies_1 = satisfies;
  return satisfies_1;
}
var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range = requireRange();
  const toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  toComparators_1 = toComparators;
  return toComparators_1;
}
var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const maxSatisfying = (versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const minSatisfying = (versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const gt = requireGt();
  const minVersion = (range2, loose) => {
    range2 = new Range(range2, loose);
    let minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  minVersion_1 = minVersion;
  return minVersion_1;
}
var valid;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range = requireRange();
  const validRange = (range2, options) => {
    try {
      return new Range(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  valid = validRange;
  return valid;
}
var outside_1;
var hasRequiredOutside;
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer = requireSemver$1();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const gt = requireGt();
  const lt = requireLt();
  const lte = requireLte();
  const gte = requireGte();
  const outside = (version2, range2, hilo, options) => {
    version2 = new SemVer(version2, options);
    range2 = new Range(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  outside_1 = outside;
  return outside_1;
}
var gtr_1;
var hasRequiredGtr;
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = (version2, range2, options) => outside(version2, range2, ">", options);
  gtr_1 = gtr;
  return gtr_1;
}
var ltr_1;
var hasRequiredLtr;
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = (version2, range2, options) => outside(version2, range2, "<", options);
  ltr_1 = ltr;
  return ltr_1;
}
var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range = requireRange();
  const intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  intersects_1 = intersects;
  return intersects_1;
}
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  simplify = (versions, range2, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range2, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
  return simplify;
}
var subset_1;
var hasRequiredSubset;
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range = requireRange();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  subset_1 = subset;
  return subset_1;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse2 = requireParse$1();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch = requirePatch();
  const prerelease = requirePrerelease();
  const compare = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort = requireSort();
  const rsort = requireRsort();
  const gt = requireGt();
  const lt = requireLt();
  const eq = requireEq();
  const neq = requireNeq();
  const gte = requireGte();
  const lte = requireLte();
  const cmp = requireCmp();
  const coerce = requireCoerce();
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver = {
    parse: parse2,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver;
}
var hasRequiredPluginUtils;
function requirePluginUtils() {
  if (hasRequiredPluginUtils) return pluginUtils.exports;
  hasRequiredPluginUtils = 1;
  (function(module) {
    const semver2 = requireSemver();
    const assert = require$$0$8;
    const kRegisteredPlugins = /* @__PURE__ */ Symbol.for("registered-plugin");
    const {
      kTestInternals
    } = requireSymbols$1();
    const { exist, existReply, existRequest } = requireDecorate();
    const {
      FST_ERR_PLUGIN_VERSION_MISMATCH,
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
    } = requireErrors$2();
    const rcRegex = /-(?:rc|pre|alpha).+$/u;
    function getMeta(fn) {
      return fn[/* @__PURE__ */ Symbol.for("plugin-meta")];
    }
    function getPluginName2(func) {
      const display = getDisplayName(func);
      if (display) {
        return display;
      }
      const cache = require.cache;
      if (cache) {
        const keys = Object.keys(cache);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (cache[key].exports === func) {
            return key;
          }
        }
      }
      if (func.name) {
        return func.name;
      }
      return null;
    }
    function getFuncPreview(func) {
      return func.toString().split("\n", 2).map((s) => s.trim()).join(" -- ");
    }
    function getDisplayName(fn) {
      return fn[/* @__PURE__ */ Symbol.for("fastify.display-name")];
    }
    function shouldSkipOverride(fn) {
      return !!fn[/* @__PURE__ */ Symbol.for("skip-override")];
    }
    function checkDependencies(fn) {
      const meta2 = getMeta(fn);
      if (!meta2) return;
      const dependencies2 = meta2.dependencies;
      if (!dependencies2) return;
      assert(Array.isArray(dependencies2), "The dependencies should be an array of strings");
      dependencies2.forEach((dependency) => {
        assert(
          this[kRegisteredPlugins].indexOf(dependency) > -1,
          `The dependency '${dependency}' of plugin '${meta2.name}' is not registered`
        );
      });
    }
    function checkDecorators(fn) {
      const meta2 = getMeta(fn);
      if (!meta2) return;
      const { decorators, name } = meta2;
      if (!decorators) return;
      if (decorators.fastify) _checkDecorators(this, "Fastify", decorators.fastify, name);
      if (decorators.reply) _checkDecorators(this, "Reply", decorators.reply, name);
      if (decorators.request) _checkDecorators(this, "Request", decorators.request, name);
    }
    const checks = {
      Fastify: exist,
      Request: existRequest,
      Reply: existReply
    };
    function _checkDecorators(that, instance, decorators, name) {
      assert(Array.isArray(decorators), "The decorators should be an array of strings");
      decorators.forEach((decorator) => {
        const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
        if (!checks[instance].call(that, decorator)) {
          throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
        }
      });
    }
    function checkVersion(fn) {
      const meta2 = getMeta(fn);
      if (meta2?.fastify == null) return;
      const requiredVersion = meta2.fastify;
      const fastifyRc = rcRegex.test(this.version);
      if (fastifyRc === true && semver2.gt(this.version, semver2.coerce(requiredVersion)) === true) {
        return;
      }
      if (requiredVersion && semver2.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
        throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta2.name, requiredVersion, this.version);
      }
    }
    function registerPluginName(fn) {
      const meta2 = getMeta(fn);
      if (!meta2) return;
      const name = meta2.name;
      if (!name) return;
      this[kRegisteredPlugins].push(name);
      return name;
    }
    function checkPluginHealthiness(fn, pluginName) {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
        throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
      }
    }
    function registerPlugin(fn) {
      const pluginName = registerPluginName.call(this, fn) || getPluginName2(fn);
      checkPluginHealthiness.call(this, fn, pluginName);
      checkVersion.call(this, fn);
      checkDecorators.call(this, fn);
      checkDependencies.call(this, fn);
      return shouldSkipOverride(fn);
    }
    module.exports = {
      getPluginName: getPluginName2,
      getFuncPreview,
      kRegisteredPlugins,
      getDisplayName,
      registerPlugin
    };
    module.exports[kTestInternals] = {
      shouldSkipOverride,
      getMeta,
      checkDecorators,
      checkDependencies
    };
  })(pluginUtils);
  return pluginUtils.exports;
}
var reqIdGenFactory_1;
var hasRequiredReqIdGenFactory;
function requireReqIdGenFactory() {
  if (hasRequiredReqIdGenFactory) return reqIdGenFactory_1;
  hasRequiredReqIdGenFactory = 1;
  function reqIdGenFactory(requestIdHeader, optGenReqId) {
    const genReqId = optGenReqId || buildDefaultGenReqId();
    if (requestIdHeader) {
      return buildOptionalHeaderReqId(requestIdHeader, genReqId);
    }
    return genReqId;
  }
  function getGenReqId(contextServer, req2) {
    return contextServer.genReqId(req2);
  }
  function buildDefaultGenReqId() {
    const maxInt = 2147483647;
    let nextReqId = 0;
    return function defaultGenReqId() {
      nextReqId = nextReqId + 1 & maxInt;
      return `req-${nextReqId.toString(36)}`;
    };
  }
  function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
    return function(req2) {
      return req2.headers[requestIdHeader] || genReqId(req2);
    };
  }
  reqIdGenFactory_1 = {
    getGenReqId,
    reqIdGenFactory
  };
  return reqIdGenFactory_1;
}
var lib = { exports: {} };
var fastDecodeUriComponent;
var hasRequiredFastDecodeUriComponent;
function requireFastDecodeUriComponent() {
  if (hasRequiredFastDecodeUriComponent) return fastDecodeUriComponent;
  hasRequiredFastDecodeUriComponent = 1;
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri2) {
    var percentPosition = uri2.indexOf("%");
    if (percentPosition === -1) return uri2;
    var length = uri2.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri2[percentPosition + 1], 4);
      var low = hexCodeToInt(uri2[percentPosition + 2], 0);
      var byte = high | low;
      var type2 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type2];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
      if (state === UTF8_ACCEPT) {
        decoded += uri2.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
          55232 + (codepoint >> 10),
          56320 + (codepoint & 1023)
        );
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri2.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri2.charCodeAt(percentPosition) === 37) continue;
        return null;
      }
    }
    return decoded + uri2.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    "a": 10,
    "A": 10,
    "b": 11,
    "B": 11,
    "c": 12,
    "C": 12,
    "d": 13,
    "D": 13,
    "e": 14,
    "E": 14,
    "f": 15,
    "F": 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === void 0 ? 255 : i << shift;
  }
  fastDecodeUriComponent = decodeURIComponent2;
  return fastDecodeUriComponent;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const fastDecode = requireFastDecodeUriComponent();
  const plusRegex = /\+/g;
  const Empty = function() {
  };
  Empty.prototype = /* @__PURE__ */ Object.create(null);
  function parse2(input) {
    const result = new Empty();
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0; i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === void 0) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  }
  parse_1 = parse2;
  return parse_1;
}
var querystring;
var hasRequiredQuerystring;
function requireQuerystring() {
  if (hasRequiredQuerystring) return querystring;
  hasRequiredQuerystring = 1;
  const hexTable = Array.from(
    { length: 256 },
    (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
  );
  const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 0 - 15
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 16 - 31
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    // 32 - 47
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    // 48 - 63
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 64 - 79
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    // 80 - 95
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 96 - 111
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
    // 112 - 127
  ]);
  function encodeString(str) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer: for (; i < len; i++) {
      let c = str.charCodeAt(i);
      while (c < 128) {
        if (noEscape[c] !== 1) {
          if (lastPos < i) out += str.slice(lastPos, i);
          lastPos = i + 1;
          out += hexTable[c];
        }
        if (++i === len) break outer;
        c = str.charCodeAt(i);
      }
      if (lastPos < i) out += str.slice(lastPos, i);
      if (c < 2048) {
        lastPos = i + 1;
        out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        lastPos = i + 1;
        out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        continue;
      }
      ++i;
      if (i >= len) {
        throw new Error("URI malformed");
      }
      const c2 = str.charCodeAt(i) & 1023;
      lastPos = i + 1;
      c = 65536 + ((c & 1023) << 10 | c2);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
  }
  querystring = { encodeString };
  return querystring;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  const { encodeString } = requireQuerystring();
  function getAsPrimitive(value) {
    const type2 = typeof value;
    if (type2 === "string") {
      return encodeString(value);
    } else if (type2 === "bigint") {
      return value.toString();
    } else if (type2 === "boolean") {
      return value ? "true" : "false";
    } else if (type2 === "number" && Number.isFinite(value)) {
      return value < 1e21 ? "" + value : encodeString("" + value);
    }
    return "";
  }
  function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0; i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0; j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  }
  stringify_1 = stringify;
  return stringify_1;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib.exports;
  hasRequiredLib = 1;
  const parse2 = requireParse();
  const stringify = requireStringify();
  const fastQuerystring = {
    parse: parse2,
    stringify
  };
  lib.exports = fastQuerystring;
  lib.exports.default = fastQuerystring;
  lib.exports.parse = parse2;
  lib.exports.stringify = stringify;
  return lib.exports;
}
var safeRegex2 = { exports: {} };
var dist$2 = { exports: {} };
var types$1 = {};
var tokens = {};
var hasRequiredTokens;
function requireTokens() {
  if (hasRequiredTokens) return tokens;
  hasRequiredTokens = 1;
  Object.defineProperty(tokens, "__esModule", { value: true });
  return tokens;
}
var types = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types;
  hasRequiredTypes$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.types = void 0;
    (function(types2) {
      types2[types2["ROOT"] = 0] = "ROOT";
      types2[types2["GROUP"] = 1] = "GROUP";
      types2[types2["POSITION"] = 2] = "POSITION";
      types2[types2["SET"] = 3] = "SET";
      types2[types2["RANGE"] = 4] = "RANGE";
      types2[types2["REPETITION"] = 5] = "REPETITION";
      types2[types2["REFERENCE"] = 6] = "REFERENCE";
      types2[types2["CHAR"] = 7] = "CHAR";
    })(exports$1.types || (exports$1.types = {}));
  })(types);
  return types;
}
var setLookup = {};
var hasRequiredSetLookup;
function requireSetLookup() {
  if (hasRequiredSetLookup) return setLookup;
  hasRequiredSetLookup = 1;
  Object.defineProperty(setLookup, "__esModule", { value: true });
  return setLookup;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types$1;
  hasRequiredTypes = 1;
  (function(exports$1) {
    var __createBinding = types$1 && types$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = types$1 && types$1.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    __exportStar(requireTokens(), exports$1);
    __exportStar(requireTypes$1(), exports$1);
    __exportStar(requireSetLookup(), exports$1);
  })(types$1);
  return types$1;
}
var tokenizer = {};
var util = {};
var sets = {};
var hasRequiredSets;
function requireSets() {
  if (hasRequiredSets) return sets;
  hasRequiredSets = 1;
  Object.defineProperty(sets, "__esModule", { value: true });
  sets.anyChar = sets.notWhitespace = sets.whitespace = sets.notInts = sets.ints = sets.notWords = sets.words = void 0;
  const types_1 = requireTypes();
  const INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
  const WORDS = () => [
    { type: types_1.types.CHAR, value: 95 },
    { type: types_1.types.RANGE, from: 97, to: 122 },
    { type: types_1.types.RANGE, from: 65, to: 90 },
    { type: types_1.types.RANGE, from: 48, to: 57 }
  ];
  const WHITESPACE = () => [
    { type: types_1.types.CHAR, value: 9 },
    { type: types_1.types.CHAR, value: 10 },
    { type: types_1.types.CHAR, value: 11 },
    { type: types_1.types.CHAR, value: 12 },
    { type: types_1.types.CHAR, value: 13 },
    { type: types_1.types.CHAR, value: 32 },
    { type: types_1.types.CHAR, value: 160 },
    { type: types_1.types.CHAR, value: 5760 },
    { type: types_1.types.RANGE, from: 8192, to: 8202 },
    { type: types_1.types.CHAR, value: 8232 },
    { type: types_1.types.CHAR, value: 8233 },
    { type: types_1.types.CHAR, value: 8239 },
    { type: types_1.types.CHAR, value: 8287 },
    { type: types_1.types.CHAR, value: 12288 },
    { type: types_1.types.CHAR, value: 65279 }
  ];
  const NOTANYCHAR = () => [
    { type: types_1.types.CHAR, value: 10 },
    { type: types_1.types.CHAR, value: 13 },
    { type: types_1.types.CHAR, value: 8232 },
    { type: types_1.types.CHAR, value: 8233 }
  ];
  sets.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
  sets.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
  sets.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
  sets.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
  sets.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
  sets.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
  sets.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
  return sets;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  var __createBinding = util && util.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = util && util.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = util && util.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(util, "__esModule", { value: true });
  util.tokenizeClass = util.strToChars = void 0;
  const types_1 = requireTypes();
  const sets2 = __importStar(requireSets());
  const CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  util.strToChars = (str) => {
    const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
    return str.replace(charsRegex, (s, b, lbs, a16, b16, dctrl, eslsh) => {
      if (lbs) {
        return s;
      }
      let code2 = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
        0: 0,
        t: 9,
        n: 10,
        v: 11,
        f: 12,
        r: 13
      }[eslsh];
      let c = String.fromCharCode(code2);
      return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
    });
  };
  util.tokenizeClass = (str, regexpStr) => {
    var _a2, _b, _c, _d, _e, _f, _g;
    let tokens2 = [], rs, c;
    const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
    while ((rs = regexp.exec(str)) !== null) {
      const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a2 = rs[1] && sets2.words()) !== null && _a2 !== void 0 ? _a2 : rs[2] && sets2.ints()) !== null && _b !== void 0 ? _b : rs[3] && sets2.whitespace()) !== null && _c !== void 0 ? _c : rs[4] && sets2.notWords()) !== null && _d !== void 0 ? _d : rs[5] && sets2.notInts()) !== null && _e !== void 0 ? _e : rs[6] && sets2.notWhitespace()) !== null && _f !== void 0 ? _f : rs[7] && {
        type: types_1.types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
        to: (c = rs[10]).charCodeAt(c.length - 1)
      }) !== null && _g !== void 0 ? _g : (c = rs[16]) && { type: types_1.types.CHAR, value: c.charCodeAt(0) };
      if (p) {
        tokens2.push(p);
      } else {
        return [tokens2, regexp.lastIndex];
      }
    }
    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
  };
  return util;
}
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer) return tokenizer;
  hasRequiredTokenizer = 1;
  var __createBinding = tokenizer && tokenizer.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = tokenizer && tokenizer.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = tokenizer && tokenizer.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(tokenizer, "__esModule", { value: true });
  tokenizer.tokenizer = void 0;
  const util2 = __importStar(requireUtil());
  const types_1 = requireTypes();
  const sets2 = __importStar(requireSets());
  const captureGroupFirstChar = /^[a-zA-Z_$]$/i;
  const captureGroupChars = /^[a-zA-Z0-9_$]$/i;
  const digit = /\d/;
  tokenizer.tokenizer = (regexpStr) => {
    let i = 0, c;
    let start = { type: types_1.types.ROOT, stack: [] };
    let lastGroup = start;
    let last = start.stack;
    let groupStack = [];
    let referenceQueue = [];
    let groupCount = 0;
    const repeatErr = (col) => {
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
    };
    let str = util2.strToChars(regexpStr);
    while (i < str.length) {
      switch (c = str[i++]) {
        // Handle escaped characters, inclues a few sets.
        case "\\":
          if (i === str.length) {
            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
          }
          switch (c = str[i++]) {
            case "b":
              last.push({ type: types_1.types.POSITION, value: "b" });
              break;
            case "B":
              last.push({ type: types_1.types.POSITION, value: "B" });
              break;
            case "w":
              last.push(sets2.words());
              break;
            case "W":
              last.push(sets2.notWords());
              break;
            case "d":
              last.push(sets2.ints());
              break;
            case "D":
              last.push(sets2.notInts());
              break;
            case "s":
              last.push(sets2.whitespace());
              break;
            case "S":
              last.push(sets2.notWhitespace());
              break;
            default:
              if (digit.test(c)) {
                let digits = c;
                while (i < str.length && digit.test(str[i])) {
                  digits += str[i++];
                }
                let value = parseInt(digits, 10);
                const reference = { type: types_1.types.REFERENCE, value };
                last.push(reference);
                referenceQueue.push({ reference, stack: last, index: last.length - 1 });
              } else {
                last.push({ type: types_1.types.CHAR, value: c.charCodeAt(0) });
              }
          }
          break;
        // Positionals.
        case "^":
          last.push({ type: types_1.types.POSITION, value: "^" });
          break;
        case "$":
          last.push({ type: types_1.types.POSITION, value: "$" });
          break;
        // Handle custom sets.
        case "[": {
          let not2;
          if (str[i] === "^") {
            not2 = true;
            i++;
          } else {
            not2 = false;
          }
          let classTokens = util2.tokenizeClass(str.slice(i), regexpStr);
          i += classTokens[1];
          last.push({
            type: types_1.types.SET,
            set: classTokens[0],
            not: not2
          });
          break;
        }
        // Class of any character except \n.
        case ".":
          last.push(sets2.anyChar());
          break;
        // Push group onto stack.
        case "(": {
          let group = {
            type: types_1.types.GROUP,
            stack: [],
            remember: true
          };
          if (str[i] === "?") {
            c = str[i + 1];
            i += 2;
            if (c === "=") {
              group.followedBy = true;
              group.remember = false;
            } else if (c === "!") {
              group.notFollowedBy = true;
              group.remember = false;
            } else if (c === "<") {
              let name = "";
              if (captureGroupFirstChar.test(str[i])) {
                name += str[i];
                i++;
              } else {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
              }
              while (i < str.length && captureGroupChars.test(str[i])) {
                name += str[i];
                i++;
              }
              if (!name) {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
              }
              if (str[i] !== ">") {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found '${str[i]}' at column ${i + 1}`);
              }
              group.name = name;
              i++;
            } else if (c === ":") {
              group.remember = false;
            } else {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}' after '?' at column ${i - 1}`);
            }
          } else {
            groupCount += 1;
          }
          last.push(group);
          groupStack.push(lastGroup);
          lastGroup = group;
          last = group.stack;
          break;
        }
        // Pop group out of stack.
        case ")":
          if (groupStack.length === 0) {
            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
          }
          lastGroup = groupStack.pop();
          last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
          break;
        // Use pipe character to give more choices.
        case "|": {
          if (!lastGroup.options) {
            lastGroup.options = [lastGroup.stack];
            delete lastGroup.stack;
          }
          let stack = [];
          lastGroup.options.push(stack);
          last = stack;
          break;
        }
        // Repetition.
        // For every repetition, remove last element from last stack
        // then insert back a RANGE object.
        // This design is chosen because there could be more than
        // one repetition symbols in a regex i.e. `a?+{2,3}`.
        case "{": {
          let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
          if (rs !== null) {
            if (last.length === 0) {
              repeatErr(i);
            }
            min = parseInt(rs[1], 10);
            max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
            i += rs[0].length;
            last.push({
              type: types_1.types.REPETITION,
              min,
              max,
              value: last.pop()
            });
          } else {
            last.push({
              type: types_1.types.CHAR,
              value: 123
            });
          }
          break;
        }
        case "?":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 0,
            max: 1,
            value: last.pop()
          });
          break;
        case "+":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 1,
            max: Infinity,
            value: last.pop()
          });
          break;
        case "*":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 0,
            max: Infinity,
            value: last.pop()
          });
          break;
        // Default is a character that is not `\[](){}?+*^$`.
        default:
          last.push({
            type: types_1.types.CHAR,
            value: c.charCodeAt(0)
          });
      }
    }
    if (groupStack.length !== 0) {
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
    }
    updateReferences(referenceQueue, groupCount);
    return start;
  };
  function updateReferences(referenceQueue, groupCount) {
    for (const elem of referenceQueue.reverse()) {
      if (groupCount < elem.reference.value) {
        elem.reference.type = types_1.types.CHAR;
        const valueString = elem.reference.value.toString();
        elem.reference.value = parseInt(valueString, 8);
        if (!/^[0-7]+$/.test(valueString)) {
          let i = 0;
          while (valueString[i] !== "8" && valueString[i] !== "9") {
            i += 1;
          }
          if (i === 0) {
            elem.reference.value = valueString.charCodeAt(0);
            i += 1;
          } else {
            elem.reference.value = parseInt(valueString.slice(0, i), 8);
          }
          if (valueString.length > i) {
            const tail = elem.stack.splice(elem.index + 1);
            for (const char of valueString.slice(i)) {
              elem.stack.push({
                type: types_1.types.CHAR,
                value: char.charCodeAt(0)
              });
            }
            elem.stack.push(...tail);
          }
        }
      }
    }
  }
  return tokenizer;
}
var reconstruct = {};
var writeSetTokens = {};
var setsLookup = {};
var hasRequiredSetsLookup;
function requireSetsLookup() {
  if (hasRequiredSetsLookup) return setsLookup;
  hasRequiredSetsLookup = 1;
  var __createBinding = setsLookup && setsLookup.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = setsLookup && setsLookup.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = setsLookup && setsLookup.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(setsLookup, "__esModule", { value: true });
  setsLookup.NOTANYCHAR = setsLookup.WHITESPACE = setsLookup.WORDS = setsLookup.INTS = void 0;
  const Sets = __importStar(requireSets());
  const types_1 = requireTypes();
  function setToLookup(tokens2) {
    let lookup = {};
    let len = 0;
    for (const token of tokens2) {
      if (token.type === types_1.types.CHAR) {
        lookup[token.value] = true;
      }
      if (token.type === types_1.types.RANGE) {
        lookup[`${token.from}-${token.to}`] = true;
      }
      len += 1;
    }
    return {
      lookup: () => Object.assign({}, lookup),
      len
    };
  }
  setsLookup.INTS = setToLookup(Sets.ints().set);
  setsLookup.WORDS = setToLookup(Sets.words().set);
  setsLookup.WHITESPACE = setToLookup(Sets.whitespace().set);
  setsLookup.NOTANYCHAR = setToLookup(Sets.anyChar().set);
  return setsLookup;
}
var hasRequiredWriteSetTokens;
function requireWriteSetTokens() {
  if (hasRequiredWriteSetTokens) return writeSetTokens;
  hasRequiredWriteSetTokens = 1;
  var __createBinding = writeSetTokens && writeSetTokens.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = writeSetTokens && writeSetTokens.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = writeSetTokens && writeSetTokens.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(writeSetTokens, "__esModule", { value: true });
  writeSetTokens.writeSetTokens = writeSetTokens.setChar = void 0;
  const types_1 = requireTypes();
  const sets2 = __importStar(requireSetsLookup());
  function setChar(charCode) {
    return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
  }
  writeSetTokens.setChar = setChar;
  function isSameSet(set, { lookup, len }) {
    if (len !== set.length) {
      return false;
    }
    const map = lookup();
    for (const elem of set) {
      if (elem.type === types_1.types.SET) {
        return false;
      }
      const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
      if (map[key]) {
        map[key] = false;
      } else {
        return false;
      }
    }
    return true;
  }
  function writeSetTokens$1(set, isNested = false) {
    if (isSameSet(set.set, sets2.INTS)) {
      return set.not ? "\\D" : "\\d";
    }
    if (isSameSet(set.set, sets2.WORDS)) {
      return set.not ? "\\W" : "\\w";
    }
    if (set.not && isSameSet(set.set, sets2.NOTANYCHAR)) {
      return ".";
    }
    if (isSameSet(set.set, sets2.WHITESPACE)) {
      return set.not ? "\\S" : "\\s";
    }
    let tokenString = "";
    for (let i = 0; i < set.set.length; i++) {
      const subset = set.set[i];
      tokenString += writeSetToken(subset);
    }
    const contents = `${set.not ? "^" : ""}${tokenString}`;
    return isNested ? contents : `[${contents}]`;
  }
  writeSetTokens.writeSetTokens = writeSetTokens$1;
  function writeSetToken(set) {
    if (set.type === types_1.types.CHAR) {
      return setChar(set.value);
    } else if (set.type === types_1.types.RANGE) {
      return `${setChar(set.from)}-${setChar(set.to)}`;
    }
    return writeSetTokens$1(set, true);
  }
  return writeSetTokens;
}
var hasRequiredReconstruct;
function requireReconstruct() {
  if (hasRequiredReconstruct) return reconstruct;
  hasRequiredReconstruct = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.reconstruct = void 0;
    const types_1 = requireTypes();
    const write_set_tokens_1 = requireWriteSetTokens();
    const reduceStack = (stack) => stack.map(exports$1.reconstruct).join("");
    const createAlternate = (token) => {
      if ("options" in token) {
        return token.options.map(reduceStack).join("|");
      } else if ("stack" in token) {
        return reduceStack(token.stack);
      } else {
        throw new Error(`options or stack must be Root or Group token`);
      }
    };
    exports$1.reconstruct = (token) => {
      switch (token.type) {
        case types_1.types.ROOT:
          return createAlternate(token);
        case types_1.types.CHAR: {
          const c = String.fromCharCode(token.value);
          return (/[[\\{}$^.|?*+()]/.test(c) ? "\\" : "") + c;
        }
        case types_1.types.POSITION:
          if (token.value === "^" || token.value === "$") {
            return token.value;
          } else {
            return `\\${token.value}`;
          }
        case types_1.types.REFERENCE:
          return `\\${token.value}`;
        case types_1.types.SET:
          return write_set_tokens_1.writeSetTokens(token);
        case types_1.types.GROUP: {
          const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
          return `(${prefix}${createAlternate(token)})`;
        }
        case types_1.types.REPETITION: {
          const { min, max } = token;
          let endWith;
          if (min === 0 && max === 1) {
            endWith = "?";
          } else if (min === 1 && max === Infinity) {
            endWith = "+";
          } else if (min === 0 && max === Infinity) {
            endWith = "*";
          } else if (max === Infinity) {
            endWith = `{${min},}`;
          } else if (min === max) {
            endWith = `{${min}}`;
          } else {
            endWith = `{${min},${max}}`;
          }
          return `${exports$1.reconstruct(token.value)}${endWith}`;
        }
        case types_1.types.RANGE:
          return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
        default:
          throw new Error(`Invalid token type ${token}`);
      }
    };
  })(reconstruct);
  return reconstruct;
}
var dist$1 = dist$2.exports;
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$2.exports;
  hasRequiredDist$1 = 1;
  (function(module, exports$1) {
    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = dist$1 && dist$1.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.types = void 0;
    const types_1 = requireTypes();
    Object.defineProperty(exports$1, "types", { enumerable: true, get: function() {
      return types_1.types;
    } });
    __exportStar(requireTokenizer(), exports$1);
    __exportStar(requireReconstruct(), exports$1);
    const tokenizer_1 = requireTokenizer();
    const reconstruct_1 = requireReconstruct();
    __exportStar(requireTypes(), exports$1);
    exports$1.default = tokenizer_1.tokenizer;
    module.exports = tokenizer_1.tokenizer;
    module.exports.types = types_1.types;
    module.exports.reconstruct = reconstruct_1.reconstruct;
  })(dist$2, dist$2.exports);
  return dist$2.exports;
}
var hasRequiredSafeRegex2;
function requireSafeRegex2() {
  if (hasRequiredSafeRegex2) return safeRegex2.exports;
  hasRequiredSafeRegex2 = 1;
  const parse2 = requireDist$1();
  const types2 = parse2.types;
  function safeRegex(re2, opts) {
    if (!opts) opts = {};
    const replimit = opts.limit === void 0 ? 25 : opts.limit;
    if (isRegExp(re2)) re2 = re2.source;
    else if (typeof re2 !== "string") re2 = String(re2);
    try {
      re2 = parse2(re2);
    } catch {
      return false;
    }
    let reps = 0;
    return (function walk(node2, starHeight) {
      let i;
      let ok;
      let len;
      if (node2.type === types2.REPETITION) {
        starHeight++;
        reps++;
        if (starHeight > 1) return false;
        if (reps > replimit) return false;
      }
      if (node2.options) {
        for (i = 0, len = node2.options.length; i < len; i++) {
          ok = walk({ stack: node2.options[i] }, starHeight);
          if (!ok) return false;
        }
      }
      const stack = node2.stack || node2.value?.stack;
      if (!stack) return true;
      for (i = 0; i < stack.length; i++) {
        ok = walk(stack[i], starHeight);
        if (!ok) return false;
      }
      return true;
    })(re2, 0);
  }
  function isRegExp(x) {
    return {}.toString.call(x) === "[object RegExp]";
  }
  safeRegex2.exports = safeRegex;
  safeRegex2.exports.default = safeRegex;
  safeRegex2.exports.safeRegex = safeRegex;
  return safeRegex2.exports;
}
var httpMethod;
var hasRequiredHttpMethod;
function requireHttpMethod() {
  if (hasRequiredHttpMethod) return httpMethod;
  hasRequiredHttpMethod = 1;
  httpMethod = {
    name: "__fmw_internal_strategy_merged_tree_http_method__",
    storage: function() {
      const handlers = /* @__PURE__ */ new Map();
      return {
        get: (type2) => {
          return handlers.get(type2) || null;
        },
        set: (type2, store) => {
          handlers.set(type2, store);
        }
      };
    },
    /* c8 ignore next 1 */
    deriveConstraint: (req2) => req2.method,
    mustMatchWhenDerived: true
  };
  return httpMethod;
}
var prettyPrint;
var hasRequiredPrettyPrint;
function requirePrettyPrint() {
  if (hasRequiredPrettyPrint) return prettyPrint;
  hasRequiredPrettyPrint = 1;
  const deepEqual = requireFastDeepEqual();
  const httpMethodStrategy = requireHttpMethod();
  const treeDataSymbol = /* @__PURE__ */ Symbol("treeData");
  function printObjectTree(obj, parentPrefix = "") {
    let tree = "";
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      const isLast = i === keys.length - 1;
      const nodePrefix = isLast ? "└── " : "├── ";
      const childPrefix = isLast ? "    " : "│   ";
      const nodeData = value[treeDataSymbol] || "";
      const prefixedNodeData = nodeData.replaceAll("\n", "\n" + parentPrefix + childPrefix);
      tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
      tree += printObjectTree(value, parentPrefix + childPrefix);
    }
    return tree;
  }
  function parseFunctionName(fn) {
    let fName = fn.name || "";
    fName = fName.replace("bound", "").trim();
    fName = (fName || "anonymous") + "()";
    return fName;
  }
  function parseMeta(meta2) {
    if (Array.isArray(meta2)) return meta2.map((m) => parseMeta(m));
    if (typeof meta2 === "symbol") return meta2.toString();
    if (typeof meta2 === "function") return parseFunctionName(meta2);
    return meta2;
  }
  function getRouteMetaData(route2, options) {
    if (!options.includeMeta) return {};
    const metaDataObject = options.buildPrettyMeta(route2);
    const filteredMetaData = {};
    let includeMetaKeys = options.includeMeta;
    if (!Array.isArray(includeMetaKeys)) {
      includeMetaKeys = Reflect.ownKeys(metaDataObject);
    }
    for (const metaKey of includeMetaKeys) {
      if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue;
      const serializedKey = metaKey.toString();
      const metaValue = metaDataObject[metaKey];
      if (metaValue !== void 0 && metaValue !== null) {
        const serializedValue = JSON.stringify(parseMeta(metaValue));
        filteredMetaData[serializedKey] = serializedValue;
      }
    }
    return filteredMetaData;
  }
  function serializeMetaData(metaData) {
    let serializedMetaData = "";
    for (const [key, value] of Object.entries(metaData)) {
      serializedMetaData += `
• (${key}) ${value}`;
    }
    return serializedMetaData;
  }
  function normalizeRoute(route2) {
    const constraints = { ...route2.opts.constraints };
    const method = constraints[httpMethodStrategy.name];
    delete constraints[httpMethodStrategy.name];
    return { ...route2, method, opts: { constraints } };
  }
  function serializeRoute(route2) {
    let serializedRoute = ` (${route2.method})`;
    const constraints = route2.opts.constraints || {};
    if (Object.keys(constraints).length !== 0) {
      serializedRoute += " " + JSON.stringify(constraints);
    }
    serializedRoute += serializeMetaData(route2.metaData);
    return serializedRoute;
  }
  function mergeSimilarRoutes(routes) {
    return routes.reduce((mergedRoutes, route2) => {
      for (const nodeRoute of mergedRoutes) {
        if (deepEqual(route2.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route2.metaData, nodeRoute.metaData)) {
          nodeRoute.method += ", " + route2.method;
          return mergedRoutes;
        }
      }
      mergedRoutes.push(route2);
      return mergedRoutes;
    }, []);
  }
  function serializeNode(node2, prefix, options) {
    let routes = node2.routes;
    if (options.method === void 0) {
      routes = routes.map(normalizeRoute);
    }
    routes = routes.map((route2) => {
      route2.metaData = getRouteMetaData(route2, options);
      return route2;
    });
    if (options.method === void 0) {
      routes = mergeSimilarRoutes(routes);
    }
    return routes.map(serializeRoute).join(`
${prefix}`);
  }
  function buildObjectTree(node2, tree, prefix, options) {
    if (node2.isLeafNode || options.commonPrefix !== false) {
      prefix = prefix || "(empty root node)";
      tree = tree[prefix] = {};
      if (node2.isLeafNode) {
        tree[treeDataSymbol] = serializeNode(node2, prefix, options);
      }
      prefix = "";
    }
    if (node2.staticChildren) {
      for (const child of Object.values(node2.staticChildren)) {
        buildObjectTree(child, tree, prefix + child.prefix, options);
      }
    }
    if (node2.parametricChildren) {
      for (const child of Object.values(node2.parametricChildren)) {
        const childPrefix = Array.from(child.nodePaths).join("|");
        buildObjectTree(child, tree, prefix + childPrefix, options);
      }
    }
    if (node2.wildcardChild) {
      buildObjectTree(node2.wildcardChild, tree, "*", options);
    }
  }
  function prettyPrintTree(root, options) {
    const objectTree = {};
    buildObjectTree(root, objectTree, root.prefix, options);
    return printObjectTree(objectTree);
  }
  prettyPrint = { prettyPrintTree };
  return prettyPrint;
}
var nullObject;
var hasRequiredNullObject;
function requireNullObject() {
  if (hasRequiredNullObject) return nullObject;
  hasRequiredNullObject = 1;
  const NullObject = function() {
  };
  NullObject.prototype = /* @__PURE__ */ Object.create(null);
  nullObject = {
    NullObject
  };
  return nullObject;
}
var handlerStorage;
var hasRequiredHandlerStorage;
function requireHandlerStorage() {
  if (hasRequiredHandlerStorage) return handlerStorage;
  hasRequiredHandlerStorage = 1;
  const { NullObject } = requireNullObject();
  const httpMethodStrategy = requireHttpMethod();
  class HandlerStorage {
    constructor() {
      this.unconstrainedHandler = null;
      this.constraints = [];
      this.handlers = [];
      this.constrainedHandlerStores = null;
    }
    // This is the hot path for node handler finding -- change with care!
    getMatchingHandler(derivedConstraints) {
      if (derivedConstraints === void 0) {
        return this.unconstrainedHandler;
      }
      return this._getHandlerMatchingConstraints(derivedConstraints);
    }
    addHandler(constrainer2, route2) {
      const params = route2.params;
      const constraints = route2.opts.constraints || {};
      const handlerObject = {
        params,
        constraints,
        handler: route2.handler,
        store: route2.store || null,
        _createParamsObject: this._compileCreateParamsObject(params)
      };
      const constraintsNames = Object.keys(constraints);
      if (constraintsNames.length === 0) {
        this.unconstrainedHandler = handlerObject;
      }
      for (const constraint of constraintsNames) {
        if (!this.constraints.includes(constraint)) {
          if (constraint === "version") {
            this.constraints.unshift(constraint);
          } else {
            this.constraints.push(constraint);
          }
        }
      }
      const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
      if (!isMergedTree && this.handlers.length >= 31) {
        throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
      }
      this.handlers.push(handlerObject);
      this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);
      if (!isMergedTree) {
        this._compileGetHandlerMatchingConstraints(constrainer2, constraints);
      }
    }
    _compileCreateParamsObject(params) {
      const fnBody = [];
      fnBody.push("const fn = function _createParamsObject (paramsArray) {");
      fnBody.push("const params = new NullObject()");
      for (let i = 0; i < params.length; i++) {
        fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
      }
      fnBody.push("return params");
      fnBody.push("}");
      fnBody.push("return fn");
      return new Function("NullObject", fnBody.join("\n"))(NullObject);
    }
    _getHandlerMatchingConstraints() {
      return null;
    }
    // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
    // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
    // The store's implementation comes from the strategies provided to the Router.
    _buildConstraintStore(store, constraint) {
      for (let i = 0; i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== void 0) {
          let indexes2 = store.get(constraintValue) || 0;
          indexes2 |= 1 << i;
          store.set(constraintValue, indexes2);
        }
      }
    }
    // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
    _constrainedIndexBitmask(constraint) {
      let mask = 0;
      for (let i = 0; i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== void 0) {
          mask |= 1 << i;
        }
      }
      return ~mask;
    }
    // Compile a fast function to match the handlers for this node
    // The function implements a general case multi-constraint matching algorithm.
    // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
    // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
    // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
    // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
    _compileGetHandlerMatchingConstraints(constrainer2) {
      this.constrainedHandlerStores = {};
      for (const constraint of this.constraints) {
        const store = constrainer2.newStoreForConstraint(constraint);
        this.constrainedHandlerStores[constraint] = store;
        this._buildConstraintStore(store, constraint);
      }
      const lines = [];
      lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
      for (const constraint of this.constraints) {
        lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
        const strategy = constrainer2.strategies[constraint];
        const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
        lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
      }
      for (const constraint in constrainer2.strategies) {
        if (!Object.hasOwn(constrainer2.strategies, constraint)) continue;
        const strategy = constrainer2.strategies[constraint];
        if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
          lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
        }
      }
      lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
      this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
    }
  }
  handlerStorage = HandlerStorage;
  return handlerStorage;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  const HandlerStorage = requireHandlerStorage();
  const NODE_TYPES = {
    STATIC: 0,
    PARAMETRIC: 1,
    WILDCARD: 2
  };
  class Node {
    constructor() {
      this.isLeafNode = false;
      this.routes = null;
      this.handlerStorage = null;
    }
    addRoute(route2, constrainer2) {
      if (this.routes === null) {
        this.routes = [];
      }
      if (this.handlerStorage === null) {
        this.handlerStorage = new HandlerStorage();
      }
      this.isLeafNode = true;
      this.routes.push(route2);
      this.handlerStorage.addHandler(constrainer2, route2);
    }
  }
  class ParentNode extends Node {
    constructor() {
      super();
      this.staticChildren = {};
    }
    findStaticMatchingChild(path2, pathIndex) {
      const staticChild = this.staticChildren[path2.charAt(pathIndex)];
      if (staticChild === void 0 || !staticChild.matchPrefix(path2, pathIndex)) {
        return null;
      }
      return staticChild;
    }
    getStaticChild(path2, pathIndex = 0) {
      if (path2.length === pathIndex) {
        return this;
      }
      const staticChild = this.findStaticMatchingChild(path2, pathIndex);
      if (staticChild) {
        return staticChild.getStaticChild(path2, pathIndex + staticChild.prefix.length);
      }
      return null;
    }
    createStaticChild(path2) {
      if (path2.length === 0) {
        return this;
      }
      let staticChild = this.staticChildren[path2.charAt(0)];
      if (staticChild) {
        let i = 1;
        for (; i < staticChild.prefix.length; i++) {
          if (path2.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
            staticChild = staticChild.split(this, i);
            break;
          }
        }
        return staticChild.createStaticChild(path2.slice(i));
      }
      const label = path2.charAt(0);
      this.staticChildren[label] = new StaticNode(path2);
      return this.staticChildren[label];
    }
  }
  class StaticNode extends ParentNode {
    constructor(prefix) {
      super();
      this.prefix = prefix;
      this.wildcardChild = null;
      this.parametricChildren = [];
      this.kind = NODE_TYPES.STATIC;
      this._compilePrefixMatch();
    }
    getParametricChild(regex) {
      const regexpSource = regex && regex.source;
      const parametricChild = this.parametricChildren.find((child) => {
        const childRegexSource = child.regex && child.regex.source;
        return childRegexSource === regexpSource;
      });
      if (parametricChild) {
        return parametricChild;
      }
      return null;
    }
    createParametricChild(regex, staticSuffix, nodePath) {
      let parametricChild = this.getParametricChild(regex);
      if (parametricChild) {
        parametricChild.nodePaths.add(nodePath);
        return parametricChild;
      }
      parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
      this.parametricChildren.push(parametricChild);
      this.parametricChildren.sort((child1, child2) => {
        if (!child1.isRegex) return 1;
        if (!child2.isRegex) return -1;
        if (child1.staticSuffix === null) return 1;
        if (child2.staticSuffix === null) return -1;
        if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
        if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
        return 0;
      });
      return parametricChild;
    }
    getWildcardChild() {
      return this.wildcardChild;
    }
    createWildcardChild() {
      this.wildcardChild = this.getWildcardChild() || new WildcardNode();
      return this.wildcardChild;
    }
    split(parentNode, length) {
      const parentPrefix = this.prefix.slice(0, length);
      const childPrefix = this.prefix.slice(length);
      this.prefix = childPrefix;
      this._compilePrefixMatch();
      const staticNode = new StaticNode(parentPrefix);
      staticNode.staticChildren[childPrefix.charAt(0)] = this;
      parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
      return staticNode;
    }
    getNextNode(path2, pathIndex, nodeStack, paramsCount) {
      let node2 = this.findStaticMatchingChild(path2, pathIndex);
      let parametricBrotherNodeIndex = 0;
      if (node2 === null) {
        if (this.parametricChildren.length === 0) {
          return this.wildcardChild;
        }
        node2 = this.parametricChildren[0];
        parametricBrotherNodeIndex = 1;
      }
      if (this.wildcardChild !== null) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.wildcardChild
        });
      }
      for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.parametricChildren[i]
        });
      }
      return node2;
    }
    _compilePrefixMatch() {
      if (this.prefix.length === 1) {
        this.matchPrefix = () => true;
        return;
      }
      const lines = [];
      for (let i = 1; i < this.prefix.length; i++) {
        const charCode = this.prefix.charCodeAt(i);
        lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
      }
      this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
    }
  }
  class ParametricNode extends ParentNode {
    constructor(regex, staticSuffix, nodePath) {
      super();
      this.isRegex = !!regex;
      this.regex = regex || null;
      this.staticSuffix = staticSuffix || null;
      this.kind = NODE_TYPES.PARAMETRIC;
      this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
    }
    getNextNode(path2, pathIndex) {
      return this.findStaticMatchingChild(path2, pathIndex);
    }
  }
  class WildcardNode extends Node {
    constructor() {
      super();
      this.kind = NODE_TYPES.WILDCARD;
    }
    getNextNode() {
      return null;
    }
  }
  node = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
  return node;
}
var acceptVersion;
var hasRequiredAcceptVersion;
function requireAcceptVersion() {
  if (hasRequiredAcceptVersion) return acceptVersion;
  hasRequiredAcceptVersion = 1;
  const assert = require$$0$8;
  function SemVerStore() {
    if (!(this instanceof SemVerStore)) {
      return new SemVerStore();
    }
    this.store = /* @__PURE__ */ new Map();
    this.maxMajor = 0;
    this.maxMinors = {};
    this.maxPatches = {};
  }
  SemVerStore.prototype.set = function(version2, store) {
    if (typeof version2 !== "string") {
      throw new TypeError("Version should be a string");
    }
    let [major, minor, patch] = version2.split(".", 3);
    if (isNaN(major)) {
      throw new TypeError("Major version must be a numeric value");
    }
    major = Number(major);
    minor = Number(minor) || 0;
    patch = Number(patch) || 0;
    if (major >= this.maxMajor) {
      this.maxMajor = major;
      this.store.set("x", store);
      this.store.set("*", store);
      this.store.set("x.x", store);
      this.store.set("x.x.x", store);
    }
    if (minor >= (this.maxMinors[major] || 0)) {
      this.maxMinors[major] = minor;
      this.store.set(`${major}.x`, store);
      this.store.set(`${major}.x.x`, store);
    }
    if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
      this.maxPatches[`${major}.${minor}`] = patch;
      this.store.set(`${major}.${minor}.x`, store);
    }
    this.store.set(`${major}.${minor}.${patch}`, store);
    return this;
  };
  SemVerStore.prototype.get = function(version2) {
    return this.store.get(version2);
  };
  acceptVersion = {
    name: "version",
    mustMatchWhenDerived: true,
    storage: SemVerStore,
    validate(value) {
      assert(typeof value === "string", "Version should be a string");
    }
  };
  return acceptVersion;
}
var acceptHost;
var hasRequiredAcceptHost;
function requireAcceptHost() {
  if (hasRequiredAcceptHost) return acceptHost;
  hasRequiredAcceptHost = 1;
  const assert = require$$0$8;
  function HostStorage() {
    const hosts = /* @__PURE__ */ new Map();
    const regexHosts = [];
    return {
      get: (host) => {
        const exact = hosts.get(host);
        if (exact) {
          return exact;
        }
        for (const regex of regexHosts) {
          if (regex.host.test(host)) {
            return regex.value;
          }
        }
      },
      set: (host, value) => {
        if (host instanceof RegExp) {
          regexHosts.push({ host, value });
        } else {
          hosts.set(host, value);
        }
      }
    };
  }
  acceptHost = {
    name: "host",
    mustMatchWhenDerived: false,
    storage: HostStorage,
    validate(value) {
      assert(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
    }
  };
  return acceptHost;
}
var constrainer;
var hasRequiredConstrainer;
function requireConstrainer() {
  if (hasRequiredConstrainer) return constrainer;
  hasRequiredConstrainer = 1;
  const acceptVersionStrategy = requireAcceptVersion();
  const acceptHostStrategy = requireAcceptHost();
  const assert = require$$0$8;
  class Constrainer {
    constructor(customStrategies) {
      this.strategies = {
        version: acceptVersionStrategy,
        host: acceptHostStrategy
      };
      this.strategiesInUse = /* @__PURE__ */ new Set();
      this.asyncStrategiesInUse = /* @__PURE__ */ new Set();
      if (customStrategies) {
        for (const strategy of Object.values(customStrategies)) {
          this.addConstraintStrategy(strategy);
        }
      }
    }
    isStrategyUsed(strategyName) {
      return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
    }
    hasConstraintStrategy(strategyName) {
      const customConstraintStrategy = this.strategies[strategyName];
      if (customConstraintStrategy !== void 0) {
        return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
      }
      return false;
    }
    addConstraintStrategy(strategy) {
      assert(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
      assert(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
      assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
      if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
        throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
      }
      if (this.isStrategyUsed(strategy.name)) {
        throw new Error(`There already exists a route with ${strategy.name} constraint.`);
      }
      strategy.isCustom = true;
      strategy.isAsync = strategy.deriveConstraint.length === 3;
      this.strategies[strategy.name] = strategy;
      if (strategy.mustMatchWhenDerived) {
        this.noteUsage({ [strategy.name]: strategy });
      }
    }
    deriveConstraints(req2, ctx, done) {
      const constraints = this.deriveSyncConstraints(req2, ctx);
      if (done === void 0) {
        return constraints;
      }
      this.deriveAsyncConstraints(constraints, req2, ctx, done);
    }
    deriveSyncConstraints(req2, ctx) {
      return void 0;
    }
    // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
    noteUsage(constraints) {
      if (constraints) {
        const beforeSize = this.strategiesInUse.size;
        for (const key in constraints) {
          if (!Object.hasOwn(constraints, key)) continue;
          const strategy = this.strategies[key];
          if (strategy.isAsync) {
            this.asyncStrategiesInUse.add(key);
          } else {
            this.strategiesInUse.add(key);
          }
        }
        if (beforeSize !== this.strategiesInUse.size) {
          this._buildDeriveConstraints();
        }
      }
    }
    newStoreForConstraint(constraint) {
      if (!this.strategies[constraint]) {
        throw new Error(`No strategy registered for constraint key ${constraint}`);
      }
      return this.strategies[constraint].storage();
    }
    validateConstraints(constraints) {
      for (const key in constraints) {
        if (!Object.hasOwn(constraints, key)) continue;
        const value = constraints[key];
        if (typeof value === "undefined") {
          throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
        }
        const strategy = this.strategies[key];
        if (!strategy) {
          throw new Error(`No strategy registered for constraint key ${key}`);
        }
        if (strategy.validate) {
          strategy.validate(value);
        }
      }
    }
    deriveAsyncConstraints(constraints, req2, ctx, done) {
      let asyncConstraintsCount = this.asyncStrategiesInUse.size;
      if (asyncConstraintsCount === 0) {
        done(null, constraints);
        return;
      }
      constraints = constraints || {};
      for (const key of this.asyncStrategiesInUse) {
        const strategy = this.strategies[key];
        strategy.deriveConstraint(req2, ctx, (err2, constraintValue) => {
          if (err2 !== null) {
            done(err2);
            return;
          }
          constraints[key] = constraintValue;
          if (--asyncConstraintsCount === 0) {
            done(null, constraints);
          }
        });
      }
    }
    // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
    // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
    // This allows us to not allocate an object to hold constraint values if no constraints are defined.
    _buildDeriveConstraints() {
      if (this.strategiesInUse.size === 0) return;
      const lines = ["return {"];
      for (const key of this.strategiesInUse) {
        const strategy = this.strategies[key];
        if (!strategy.isCustom) {
          if (key === "version") {
            lines.push("   version: req.headers['accept-version'],");
          } else {
            lines.push("   host: req.headers.host || req.headers[':authority'],");
          }
        } else {
          lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
        }
      }
      lines.push("}");
      this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
    }
  }
  constrainer = Constrainer;
  return constrainer;
}
var httpMethods_1;
var hasRequiredHttpMethods;
function requireHttpMethods() {
  if (hasRequiredHttpMethods) return httpMethods_1;
  hasRequiredHttpMethods = 1;
  const httpMethods = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "QUERY",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
  httpMethods_1 = httpMethods;
  return httpMethods_1;
}
var urlSanitizer;
var hasRequiredUrlSanitizer;
function requireUrlSanitizer() {
  if (hasRequiredUrlSanitizer) return urlSanitizer;
  hasRequiredUrlSanitizer = 1;
  function decodeComponentChar(highCharCode, lowCharCode) {
    if (highCharCode === 50) {
      if (lowCharCode === 53) return "%";
      if (lowCharCode === 51) return "#";
      if (lowCharCode === 52) return "$";
      if (lowCharCode === 54) return "&";
      if (lowCharCode === 66) return "+";
      if (lowCharCode === 98) return "+";
      if (lowCharCode === 67) return ",";
      if (lowCharCode === 99) return ",";
      if (lowCharCode === 70) return "/";
      if (lowCharCode === 102) return "/";
      return null;
    }
    if (highCharCode === 51) {
      if (lowCharCode === 65) return ":";
      if (lowCharCode === 97) return ":";
      if (lowCharCode === 66) return ";";
      if (lowCharCode === 98) return ";";
      if (lowCharCode === 68) return "=";
      if (lowCharCode === 100) return "=";
      if (lowCharCode === 70) return "?";
      if (lowCharCode === 102) return "?";
      return null;
    }
    if (highCharCode === 52 && lowCharCode === 48) {
      return "@";
    }
    return null;
  }
  function safeDecodeURI(path2, useSemicolonDelimiter) {
    let shouldDecode = false;
    let shouldDecodeParam = false;
    let querystring2 = "";
    for (let i = 1; i < path2.length; i++) {
      const charCode = path2.charCodeAt(i);
      if (charCode === 37) {
        const highCharCode = path2.charCodeAt(i + 1);
        const lowCharCode = path2.charCodeAt(i + 2);
        if (decodeComponentChar(highCharCode, lowCharCode) === null) {
          shouldDecode = true;
        } else {
          shouldDecodeParam = true;
          if (highCharCode === 50 && lowCharCode === 53) {
            shouldDecode = true;
            path2 = path2.slice(0, i + 1) + "25" + path2.slice(i + 1);
            i += 2;
          }
          i += 2;
        }
      } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
        querystring2 = path2.slice(i + 1);
        path2 = path2.slice(0, i);
        break;
      }
    }
    const decodedPath = shouldDecode ? decodeURI(path2) : path2;
    return { path: decodedPath, querystring: querystring2, shouldDecodeParam };
  }
  function safeDecodeURIComponent(uriComponent) {
    const startIndex = uriComponent.indexOf("%");
    if (startIndex === -1) return uriComponent;
    let decoded = "";
    let lastIndex = startIndex;
    for (let i = startIndex; i < uriComponent.length; i++) {
      if (uriComponent.charCodeAt(i) === 37) {
        const highCharCode = uriComponent.charCodeAt(i + 1);
        const lowCharCode = uriComponent.charCodeAt(i + 2);
        const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
        decoded += uriComponent.slice(lastIndex, i) + decodedChar;
        lastIndex = i + 3;
      }
    }
    return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
  }
  urlSanitizer = { safeDecodeURI, safeDecodeURIComponent };
  return urlSanitizer;
}
var findMyWay;
var hasRequiredFindMyWay;
function requireFindMyWay() {
  if (hasRequiredFindMyWay) return findMyWay;
  hasRequiredFindMyWay = 1;
  const assert = require$$0$8;
  const querystring2 = requireLib();
  const isRegexSafe = requireSafeRegex2();
  const deepEqual = requireFastDeepEqual();
  const { prettyPrintTree } = requirePrettyPrint();
  const { StaticNode, NODE_TYPES } = requireNode();
  const Constrainer = requireConstrainer();
  const httpMethods = requireHttpMethods();
  const httpMethodStrategy = requireHttpMethod();
  const { safeDecodeURI, safeDecodeURIComponent } = requireUrlSanitizer();
  const FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
  const OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
  const ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
  const REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;
  if (!isRegexSafe(FULL_PATH_REGEXP)) {
    throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
    throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(ESCAPE_REGEXP)) {
    throw new Error("the ESCAPE_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
    throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
  }
  function Router(opts) {
    if (!(this instanceof Router)) {
      return new Router(opts);
    }
    opts = opts || {};
    this._opts = opts;
    if (opts.defaultRoute) {
      assert(typeof opts.defaultRoute === "function", "The default route must be a function");
      this.defaultRoute = opts.defaultRoute;
    } else {
      this.defaultRoute = null;
    }
    if (opts.onBadUrl) {
      assert(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
      this.onBadUrl = opts.onBadUrl;
    } else {
      this.onBadUrl = null;
    }
    if (opts.buildPrettyMeta) {
      assert(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
      this.buildPrettyMeta = opts.buildPrettyMeta;
    } else {
      this.buildPrettyMeta = defaultBuildPrettyMeta;
    }
    if (opts.querystringParser) {
      assert(typeof opts.querystringParser === "function", "querystringParser must be a function");
      this.querystringParser = opts.querystringParser;
    } else {
      this.querystringParser = (query) => query.length === 0 ? {} : querystring2.parse(query);
    }
    this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
    this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
    this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
    this.maxParamLength = opts.maxParamLength || 100;
    this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
    this.constrainer = new Constrainer(opts.constraints);
    this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
    this.routes = [];
    this.trees = {};
  }
  Router.prototype.on = function on(method, path2, opts, handler, store) {
    if (typeof opts === "function") {
      if (handler !== void 0) {
        store = handler;
      }
      handler = opts;
      opts = {};
    }
    assert(typeof path2 === "string", "Path should be a string");
    assert(path2.length > 0, "The path could not be empty");
    assert(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
    assert(typeof handler === "function", "Handler should be a function");
    const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
      this.on(method, pathFull, opts, handler, store);
      this.on(method, pathOptional, opts, handler, store);
      return;
    }
    const route2 = path2;
    if (this.ignoreDuplicateSlashes) {
      path2 = removeDuplicateSlashes(path2);
    }
    if (this.ignoreTrailingSlash) {
      path2 = trimLastSlash(path2);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      assert(typeof method2 === "string", "Method should be a string");
      assert(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
      this._on(method2, path2, opts, handler, store, route2);
    }
  };
  Router.prototype._on = function _on(method, path2, opts, handler, store) {
    let constraints = {};
    if (opts.constraints !== void 0) {
      assert(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
      if (Object.keys(opts.constraints).length !== 0) {
        constraints = opts.constraints;
      }
    }
    this.constrainer.validateConstraints(constraints);
    this.constrainer.noteUsage(constraints);
    if (this.trees[method] === void 0) {
      this.trees[method] = new StaticNode("/");
    }
    let pattern2 = path2;
    if (pattern2 === "*" && this.trees[method].prefix.length !== 0) {
      const currentRoot = this.trees[method];
      this.trees[method] = new StaticNode("");
      this.trees[method].staticChildren["/"] = currentRoot;
    }
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    const params = [];
    for (let i = 0; i <= pattern2.length; i++) {
      if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern2.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern2.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.replaceAll("::", ":");
        staticNodePath = staticNodePath.replaceAll("%", "%25");
        currentNode = currentNode.createStaticChild(staticNodePath);
      }
      if (isParametricNode) {
        let isRegexNode = false;
        let isParamSafe = true;
        let backtrack = "";
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex; ; j++) {
          const charCode = pattern2.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern2.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern2.slice(lastParamStartIndex, j);
            params.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
              const regexString = pattern2.slice(j, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
              isParamSafe = true;
            } else {
              regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
              isParamSafe = false;
            }
            const staticPartStartIndex = j;
            for (; j < pattern2.length; j++) {
              const charCode2 = pattern2.charCodeAt(j);
              if (charCode2 === 47) break;
              if (charCode2 === 58) {
                const nextCharCode = pattern2.charCodeAt(j + 1);
                if (nextCharCode === 58) j++;
                else break;
              }
            }
            let staticPart = pattern2.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.replaceAll("::", ":");
              staticPart = staticPart.replaceAll("%", "%25");
              regexps.push(backtrack = escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern2.slice(i, j);
              pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params.push("*");
        currentNode = currentNode.createWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern2.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern2 = pattern2.toLowerCase();
    }
    if (pattern2 === "*") {
      pattern2 = "/*";
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern2 && deepEqual(routeConstraints, constraints)) {
        throw new Error(`Method '${method}' already declared for route '${pattern2}' with constraints '${JSON.stringify(constraints)}'`);
      }
    }
    const route2 = { method, path: path2, pattern: pattern2, params, opts, handler, store };
    this.routes.push(route2);
    currentNode.addRoute(route2, this.constrainer);
  };
  Router.prototype.hasRoute = function hasRoute(method, path2, constraints) {
    const route2 = this.findRoute(method, path2, constraints);
    return route2 !== null;
  };
  Router.prototype.findRoute = function findNode(method, path2, constraints = {}) {
    if (this.trees[method] === void 0) {
      return null;
    }
    let pattern2 = path2;
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    for (let i = 0; i <= pattern2.length; i++) {
      if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern2.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern2.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.replaceAll("::", ":");
        staticNodePath = staticNodePath.replaceAll("%", "%25");
        currentNode = currentNode.getStaticChild(staticNodePath);
        if (currentNode === null) {
          return null;
        }
      }
      if (isParametricNode) {
        let isRegexNode = false;
        let isParamSafe = true;
        let backtrack = "";
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex; ; j++) {
          const charCode = pattern2.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern2.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            pattern2.slice(lastParamStartIndex, j);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
              const regexString = pattern2.slice(j, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
              isParamSafe = false;
            } else {
              regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
              isParamSafe = false;
            }
            const staticPartStartIndex = j;
            for (; j < pattern2.length; j++) {
              const charCode2 = pattern2.charCodeAt(j);
              if (charCode2 === 47) break;
              if (charCode2 === 58) {
                const nextCharCode = pattern2.charCodeAt(j + 1);
                if (nextCharCode === 58) j++;
                else break;
              }
            }
            let staticPart = pattern2.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.replaceAll("::", ":");
              staticPart = staticPart.replaceAll("%", "%25");
              regexps.push(backtrack = escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern2.slice(i, j);
              pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
              if (currentNode === null) {
                return null;
              }
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        currentNode = currentNode.getWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern2.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern2 = pattern2.toLowerCase();
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern2 && deepEqual(routeConstraints, constraints)) {
        return {
          handler: existRoute.handler,
          store: existRoute.store,
          params: existRoute.params
        };
      }
    }
    return null;
  };
  Router.prototype.hasConstraintStrategy = function(strategyName) {
    return this.constrainer.hasConstraintStrategy(strategyName);
  };
  Router.prototype.addConstraintStrategy = function(constraints) {
    this.constrainer.addConstraintStrategy(constraints);
    this._rebuild(this.routes);
  };
  Router.prototype.reset = function reset() {
    this.trees = {};
    this.routes = [];
  };
  Router.prototype.off = function off(method, path2, constraints) {
    assert(typeof path2 === "string", "Path should be a string");
    assert(path2.length > 0, "The path could not be empty");
    assert(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
    assert(
      typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null,
      "Constraints should be an object or undefined."
    );
    const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.off(method, pathFull, constraints);
      this.off(method, pathOptional, constraints);
      return;
    }
    if (this.ignoreDuplicateSlashes) {
      path2 = removeDuplicateSlashes(path2);
    }
    if (this.ignoreTrailingSlash) {
      path2 = trimLastSlash(path2);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      this._off(method2, path2, constraints);
    }
  };
  Router.prototype._off = function _off(method, path2, constraints) {
    assert(typeof method === "string", "Method should be a string");
    assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
    function matcherWithoutConstraints(route2) {
      return method !== route2.method || path2 !== route2.path;
    }
    function matcherWithConstraints(route2) {
      return matcherWithoutConstraints(route2) || !deepEqual(constraints, route2.opts.constraints || {});
    }
    const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
    const newRoutes = this.routes.filter(predicate);
    this._rebuild(newRoutes);
  };
  Router.prototype.lookup = function lookup(req2, res2, ctx, done) {
    if (typeof ctx === "function") {
      done = ctx;
      ctx = void 0;
    }
    if (done === void 0) {
      const constraints = this.constrainer.deriveConstraints(req2, ctx);
      const handle = this.find(req2.method, req2.url, constraints);
      return this.callHandler(handle, req2, res2, ctx);
    }
    this.constrainer.deriveConstraints(req2, ctx, (err2, constraints) => {
      if (err2 !== null) {
        done(err2);
        return;
      }
      try {
        const handle = this.find(req2.method, req2.url, constraints);
        const result = this.callHandler(handle, req2, res2, ctx);
        done(null, result);
      } catch (err3) {
        done(err3);
      }
    });
  };
  Router.prototype.callHandler = function callHandler(handle, req2, res2, ctx) {
    if (handle === null) return this._defaultRoute(req2, res2, ctx);
    return ctx === void 0 ? handle.handler(req2, res2, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req2, res2, handle.params, handle.store, handle.searchParams);
  };
  Router.prototype.find = function find(method, path2, derivedConstraints) {
    let currentNode = this.trees[method];
    if (currentNode === void 0) return null;
    if (path2.charCodeAt(0) !== 47) {
      path2 = path2.replace(FULL_PATH_REGEXP, "/");
    }
    if (this.ignoreDuplicateSlashes) {
      path2 = removeDuplicateSlashes(path2);
    }
    let sanitizedUrl;
    let querystring3;
    let shouldDecodeParam;
    try {
      sanitizedUrl = safeDecodeURI(path2, this.useSemicolonDelimiter);
      path2 = sanitizedUrl.path;
      querystring3 = sanitizedUrl.querystring;
      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
    } catch (error2) {
      return this._onBadUrl(path2);
    }
    if (this.ignoreTrailingSlash) {
      path2 = trimLastSlash(path2);
    }
    const originPath = path2;
    if (this.caseSensitive === false) {
      path2 = path2.toLowerCase();
    }
    const maxParamLength = this.maxParamLength;
    let pathIndex = currentNode.prefix.length;
    const params = [];
    const pathLen = path2.length;
    const brothersNodesStack = [];
    while (true) {
      if (pathIndex === pathLen && currentNode.isLeafNode) {
        const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
        if (handle !== null) {
          return {
            handler: handle.handler,
            store: handle.store,
            params: handle._createParamsObject(params),
            searchParams: this.querystringParser(querystring3)
          };
        }
      }
      let node2 = currentNode.getNextNode(path2, pathIndex, brothersNodesStack, params.length);
      if (node2 === null) {
        if (brothersNodesStack.length === 0) {
          return null;
        }
        const brotherNodeState = brothersNodesStack.pop();
        pathIndex = brotherNodeState.brotherPathIndex;
        params.splice(brotherNodeState.paramsCount);
        node2 = brotherNodeState.brotherNode;
      }
      currentNode = node2;
      if (currentNode.kind === NODE_TYPES.STATIC) {
        pathIndex += currentNode.prefix.length;
        continue;
      }
      if (currentNode.kind === NODE_TYPES.WILDCARD) {
        let param2 = originPath.slice(pathIndex);
        if (shouldDecodeParam) {
          param2 = safeDecodeURIComponent(param2);
        }
        params.push(param2);
        pathIndex = pathLen;
        continue;
      }
      let paramEndIndex = originPath.indexOf("/", pathIndex);
      if (paramEndIndex === -1) {
        paramEndIndex = pathLen;
      }
      let param = originPath.slice(pathIndex, paramEndIndex);
      if (shouldDecodeParam) {
        param = safeDecodeURIComponent(param);
      }
      if (currentNode.isRegex) {
        const matchedParameters = currentNode.regex.exec(param);
        if (matchedParameters === null) continue;
        for (let i = 1; i < matchedParameters.length; i++) {
          const matchedParam = matchedParameters[i];
          if (matchedParam.length > maxParamLength) {
            return null;
          }
          params.push(matchedParam);
        }
      } else {
        if (param.length > maxParamLength) {
          return null;
        }
        params.push(param);
      }
      pathIndex = paramEndIndex;
    }
  };
  Router.prototype._rebuild = function(routes) {
    this.reset();
    for (const route2 of routes) {
      const { method, path: path2, opts, handler, store } = route2;
      this._on(method, path2, opts, handler, store);
    }
  };
  Router.prototype._defaultRoute = function(req2, res2, ctx) {
    if (this.defaultRoute !== null) {
      return ctx === void 0 ? this.defaultRoute(req2, res2) : this.defaultRoute.call(ctx, req2, res2);
    } else {
      res2.statusCode = 404;
      res2.end();
    }
  };
  Router.prototype._onBadUrl = function(path2) {
    if (this.onBadUrl === null) {
      return null;
    }
    const onBadUrl = this.onBadUrl;
    return {
      handler: (req2, res2, ctx) => onBadUrl(path2, req2, res2),
      params: {},
      store: null
    };
  };
  Router.prototype.prettyPrint = function(options = {}) {
    const method = options.method;
    options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
    let tree = null;
    if (method === void 0) {
      const { version: version2, host, ...constraints } = this.constrainer.strategies;
      constraints[httpMethodStrategy.name] = httpMethodStrategy;
      const mergedRouter = new Router({ ...this._opts, constraints });
      const mergedRoutes = this.routes.map((route2) => {
        const constraints2 = {
          ...route2.opts.constraints,
          [httpMethodStrategy.name]: route2.method
        };
        return { ...route2, method: "MERGED", opts: { constraints: constraints2 } };
      });
      mergedRouter._rebuild(mergedRoutes);
      tree = mergedRouter.trees.MERGED;
    } else {
      tree = this.trees[method];
    }
    if (tree == null) return "(empty tree)";
    return prettyPrintTree(tree, options);
  };
  for (const i in httpMethods) {
    if (!httpMethods.hasOwnProperty(i)) continue;
    const m = httpMethods[i];
    const methodName = m.toLowerCase();
    Router.prototype[methodName] = function(path2, handler, store) {
      return this.on(m, path2, handler, store);
    };
  }
  Router.prototype.all = function(path2, handler, store) {
    this.on(httpMethods, path2, handler, store);
  };
  Router.sanitizeUrlPath = function sanitizeUrlPath(url, useSemicolonDelimiter) {
    const decoded = safeDecodeURI(url, useSemicolonDelimiter);
    if (decoded.shouldDecodeParam) {
      return safeDecodeURIComponent(decoded.path);
    }
    return decoded.path;
  };
  Router.removeDuplicateSlashes = removeDuplicateSlashes;
  Router.trimLastSlash = trimLastSlash;
  findMyWay = Router;
  function escapeRegExp(string2) {
    return string2.replace(ESCAPE_REGEXP, "\\$&");
  }
  function removeDuplicateSlashes(path2) {
    return path2.indexOf("//") !== -1 ? path2.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, "/") : path2;
  }
  function trimLastSlash(path2) {
    if (path2.length > 1 && path2.charCodeAt(path2.length - 1) === 47) {
      return path2.slice(0, -1);
    }
    return path2;
  }
  function trimRegExpStartAndEnd(regexString) {
    if (regexString.charCodeAt(1) === 94) {
      regexString = regexString.slice(0, 1) + regexString.slice(2);
    }
    if (regexString.charCodeAt(regexString.length - 2) === 36) {
      regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
    }
    return regexString;
  }
  function getClosingParenthensePosition(path2, idx) {
    let parentheses = 1;
    while (idx < path2.length) {
      idx++;
      if (path2.charCodeAt(idx) === 92) {
        idx++;
        continue;
      }
      if (path2.charCodeAt(idx) === 41) {
        parentheses--;
      } else if (path2.charCodeAt(idx) === 40) {
        parentheses++;
      }
      if (!parentheses) return idx;
    }
    throw new TypeError('Invalid regexp expression in "' + path2 + '"');
  }
  function defaultBuildPrettyMeta(route2) {
    if (!route2) return {};
    if (!route2.store) return {};
    return Object.assign({}, route2.store);
  }
  return findMyWay;
}
var headRoute;
var hasRequiredHeadRoute;
function requireHeadRoute() {
  if (hasRequiredHeadRoute) return headRoute;
  hasRequiredHeadRoute = 1;
  function headRouteOnSendHandler(req2, reply2, payload, done) {
    if (payload === void 0) {
      reply2.header("content-length", "0");
      done(null, null);
      return;
    }
    if (typeof payload.resume === "function") {
      payload.on("error", (err2) => {
        reply2.log.error({ err: err2 }, "Error on Stream found for HEAD route");
      });
      payload.resume();
      done(null, null);
      return;
    }
    if (typeof payload.getReader === "function") {
      payload.cancel("Stream cancelled by HEAD route").catch((err2) => {
        reply2.log.error({ err: err2 }, "Error on Stream found for HEAD route");
      });
      done(null, null);
      return;
    }
    const size = "" + Buffer.byteLength(payload);
    reply2.header("content-length", size);
    done(null, null);
  }
  function parseHeadOnSendHandlers(onSendHandlers) {
    if (onSendHandlers == null) return headRouteOnSendHandler;
    return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
  }
  headRoute = {
    parseHeadOnSendHandlers
  };
  return headRoute;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const FindMyWay = requireFindMyWay();
  const Context = requireContext();
  const handleRequest2 = requireHandleRequest();
  const { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = requireHooks();
  const { normalizeSchema } = requireSchemas();
  const { parseHeadOnSendHandlers } = requireHeadRoute();
  const {
    compileSchemasForValidation,
    compileSchemasForSerialization
  } = requireValidation$1();
  const {
    FST_ERR_SCH_VALIDATION_BUILD,
    FST_ERR_SCH_SERIALIZATION_BUILD,
    FST_ERR_DUPLICATED_ROUTE,
    FST_ERR_INVALID_URL,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
    FST_ERR_ROUTE_DUPLICATED_HANDLER,
    FST_ERR_ROUTE_HANDLER_NOT_FN,
    FST_ERR_ROUTE_MISSING_HANDLER,
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
    FST_ERR_ROUTE_METHOD_INVALID,
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER
  } = requireErrors$2();
  const {
    kRoutePrefix,
    kSupportedHTTPMethods,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kOptions,
    kReplySerializerDefault,
    kReplyIsError,
    kRequestPayloadStream,
    kDisableRequestLogging,
    kSchemaErrorFormatter,
    kErrorHandler,
    kHasBeenDecorated,
    kRequestAcceptVersion,
    kRouteByFastify,
    kRouteContext
  } = requireSymbols$1();
  const { buildErrorHandler } = requireErrorHandler();
  const { createChildLogger } = requireLoggerFactory();
  const { getGenReqId } = requireReqIdGenFactory();
  const { FSTDEP022 } = requireWarnings();
  const routerKeys = [
    "allowUnsafeRegex",
    "buildPrettyMeta",
    "caseSensitive",
    "constraints",
    "defaultRoute",
    "ignoreDuplicateSlashes",
    "ignoreTrailingSlash",
    "maxParamLength",
    "onBadUrl",
    "querystringParser",
    "useSemicolonDelimiter"
  ];
  function buildRouting(options) {
    const router = FindMyWay(options);
    let avvio;
    let fourOhFour;
    let logger;
    let hasLogger;
    let setupResponseListeners;
    let throwIfAlreadyStarted;
    let disableRequestLogging;
    let disableRequestLoggingFn;
    let ignoreTrailingSlash;
    let ignoreDuplicateSlashes;
    let return503OnClosing;
    let globalExposeHeadRoutes;
    let keepAliveConnections;
    let closing = false;
    return {
      /**
       * @param {import('../fastify').FastifyServerOptions} options
       * @param {*} fastifyArgs
       */
      setup(options2, fastifyArgs) {
        avvio = fastifyArgs.avvio;
        fourOhFour = fastifyArgs.fourOhFour;
        logger = options2.logger;
        hasLogger = fastifyArgs.hasLogger;
        setupResponseListeners = fastifyArgs.setupResponseListeners;
        throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
        globalExposeHeadRoutes = options2.exposeHeadRoutes;
        disableRequestLogging = options2.disableRequestLogging;
        if (typeof disableRequestLogging === "function") {
          disableRequestLoggingFn = options2.disableRequestLogging;
        }
        ignoreTrailingSlash = options2.routerOptions.ignoreTrailingSlash;
        ignoreDuplicateSlashes = options2.routerOptions.ignoreDuplicateSlashes;
        return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
        keepAliveConnections = fastifyArgs.keepAliveConnections;
      },
      routing: router.lookup.bind(router),
      // router func to find the right handler to call
      route: route2,
      // configure a route in the fastify instance
      hasRoute,
      prepareRoute,
      routeHandler,
      closeRoutes: () => {
        closing = true;
      },
      printRoutes: router.prettyPrint.bind(router),
      addConstraintStrategy,
      hasConstraintStrategy,
      isAsyncConstraint,
      findRoute
    };
    function addConstraintStrategy(strategy) {
      throwIfAlreadyStarted("Cannot add constraint strategy!");
      return router.addConstraintStrategy(strategy);
    }
    function hasConstraintStrategy(strategyName) {
      return router.hasConstraintStrategy(strategyName);
    }
    function isAsyncConstraint() {
      return router.constrainer.asyncStrategiesInUse.size > 0;
    }
    function prepareRoute({ method, url, options: options2, handler, isFastify }) {
      if (typeof url !== "string") {
        throw new FST_ERR_INVALID_URL(typeof url);
      }
      if (!handler && typeof options2 === "function") {
        handler = options2;
        options2 = {};
      } else if (handler && typeof handler === "function") {
        if (Object.prototype.toString.call(options2) !== "[object Object]") {
          throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url);
        } else if (options2.handler) {
          if (typeof options2.handler === "function") {
            throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url);
          } else {
            throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url);
          }
        }
      }
      options2 = Object.assign({}, options2, {
        method,
        url,
        path: url,
        handler: handler || options2 && options2.handler
      });
      return route2.call(this, { options: options2, isFastify });
    }
    function hasRoute({ options: options2 }) {
      const normalizedMethod = options2.method?.toUpperCase() ?? "";
      return router.hasRoute(
        normalizedMethod,
        options2.url || "",
        options2.constraints
      );
    }
    function findRoute(options2) {
      const route3 = router.find(
        options2.method,
        options2.url || "",
        options2.constraints
      );
      if (route3) {
        return {
          handler: route3.handler,
          params: route3.params,
          searchParams: route3.searchParams
        };
      } else {
        return null;
      }
    }
    function route2({ options: options2, isFastify }) {
      throwIfAlreadyStarted("Cannot add route!");
      const opts = { ...options2 };
      const path2 = opts.url || opts.path || "";
      if (!opts.handler) {
        throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path2);
      }
      if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
        throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path2);
      }
      validateBodyLimitOption(opts.bodyLimit);
      const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
      let isGetRoute = false;
      let isHeadRoute = false;
      if (Array.isArray(opts.method)) {
        for (let i = 0; i < opts.method.length; ++i) {
          opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
          validateSchemaBodyOption.call(this, opts.method[i], path2, opts.schema);
          isGetRoute = opts.method.includes("GET");
          isHeadRoute = opts.method.includes("HEAD");
        }
      } else {
        opts.method = normalizeAndValidateMethod.call(this, opts.method);
        validateSchemaBodyOption.call(this, opts.method, path2, opts.schema);
        isGetRoute = opts.method === "GET";
        isHeadRoute = opts.method === "HEAD";
      }
      const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
      const prefix = this[kRoutePrefix];
      if (path2 === "/" && prefix.length > 0 && opts.method !== "HEAD") {
        switch (opts.prefixTrailingSlash) {
          case "slash":
            addNewRoute.call(this, { path: path2, isFastify });
            break;
          case "no-slash":
            addNewRoute.call(this, { path: "", isFastify });
            break;
          case "both":
          default:
            addNewRoute.call(this, { path: "", isFastify });
            if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
              addNewRoute.call(this, { path: path2, prefixing: true, isFastify });
            }
        }
      } else if (path2[0] === "/" && prefix.endsWith("/")) {
        addNewRoute.call(this, { path: path2.slice(1), isFastify });
      } else {
        addNewRoute.call(this, { path: path2, isFastify });
      }
      return this;
      function addNewRoute({ path: path3, prefixing = false, isFastify: isFastify2 = false }) {
        const url = prefix + path3;
        opts.url = url;
        opts.path = url;
        opts.routePath = path3;
        opts.prefix = prefix;
        opts.logLevel = opts.logLevel || this[kLogLevel];
        if (this[kLogSerializers] || opts.logSerializers) {
          opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
        }
        if (opts.attachValidation == null) {
          opts.attachValidation = false;
        }
        if (prefixing === false) {
          for (const hook of this[kHooks].onRoute) {
            hook.call(this, opts);
          }
        }
        for (const hook of lifecycleHooks) {
          if (opts && hook in opts) {
            if (Array.isArray(opts[hook])) {
              for (const func of opts[hook]) {
                if (typeof func !== "function") {
                  throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                }
                if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                  if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                  }
                } else if (hook === "onRequestAbort") {
                  if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                  }
                } else {
                  if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                  }
                }
              }
            } else if (opts[hook] !== void 0 && typeof opts[hook] !== "function") {
              throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
            }
          }
        }
        const constraints = opts.constraints || {};
        const config2 = {
          ...opts.config,
          url,
          method: opts.method
        };
        const context2 = new Context({
          schema: opts.schema,
          handler: opts.handler.bind(this),
          config: config2,
          errorHandler: opts.errorHandler,
          childLoggerFactory: opts.childLoggerFactory,
          bodyLimit: opts.bodyLimit,
          logLevel: opts.logLevel,
          logSerializers: opts.logSerializers,
          attachValidation: opts.attachValidation,
          schemaErrorFormatter: opts.schemaErrorFormatter,
          replySerializer: this[kReplySerializerDefault],
          validatorCompiler: opts.validatorCompiler,
          serializerCompiler: opts.serializerCompiler,
          exposeHeadRoute: shouldExposeHead,
          prefixTrailingSlash: opts.prefixTrailingSlash || "both",
          server: this,
          isFastify: isFastify2
        });
        const headHandler = router.findRoute("HEAD", opts.url, constraints);
        const hasHEADHandler = headHandler !== null;
        try {
          router.on(opts.method, opts.url, { constraints }, routeHandler, context2);
        } catch (error2) {
          if (!context2[kRouteByFastify]) {
            const isDuplicatedRoute = error2.message.includes(`Method '${opts.method}' already declared for route`);
            if (isDuplicatedRoute) {
              throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
            }
            throw error2;
          }
        }
        this.after((notHandledErr, done) => {
          context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
          context2._parserOptions.limit = opts.bodyLimit || null;
          context2.logLevel = opts.logLevel;
          context2.logSerializers = opts.logSerializers;
          context2.attachValidation = opts.attachValidation;
          context2[kReplySerializerDefault] = this[kReplySerializerDefault];
          context2.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context2.schemaErrorFormatter;
          avvio.once("preReady", () => {
            for (const hook of lifecycleHooks) {
              const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
              context2[hook] = toSet.length ? toSet : null;
            }
            while (!context2.Request[kHasBeenDecorated] && context2.Request.parent) {
              context2.Request = context2.Request.parent;
            }
            while (!context2.Reply[kHasBeenDecorated] && context2.Reply.parent) {
              context2.Reply = context2.Reply.parent;
            }
            fourOhFour.setContext(this, context2);
            if (opts.schema) {
              context2.schema = normalizeSchema(context2.schema, this.initialConfig);
              const schemaController2 = this[kSchemaController];
              const hasValidationSchema = opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params;
              if (!opts.validatorCompiler && hasValidationSchema) {
                schemaController2.setupValidator(this[kOptions]);
              }
              try {
                const isCustom = typeof opts?.validatorCompiler === "function" || schemaController2.isCustomValidatorCompiler;
                compileSchemasForValidation(
                  context2,
                  opts.validatorCompiler || schemaController2.validatorCompiler,
                  isCustom
                );
              } catch (error2) {
                throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error2.message);
              }
              if (opts.schema.response && !opts.serializerCompiler) {
                schemaController2.setupSerializer(this[kOptions]);
              }
              try {
                compileSchemasForSerialization(context2, opts.serializerCompiler || schemaController2.serializerCompiler);
              } catch (error2) {
                throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error2.message);
              }
            }
          });
          done(notHandledErr);
        });
        if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
          const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
          prepareRoute.call(this, { method: "HEAD", url: path3, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
        }
      }
    }
    function routeHandler(req2, res2, params, context2, query) {
      const id2 = getGenReqId(context2.server, req2);
      const loggerOpts = {
        level: context2.logLevel
      };
      if (context2.logSerializers) {
        loggerOpts.serializers = context2.logSerializers;
      }
      const childLogger = createChildLogger(context2, logger, req2, id2, loggerOpts);
      childLogger[kDisableRequestLogging] = disableRequestLoggingFn ? false : disableRequestLogging;
      if (closing === true) {
        if (req2.httpVersionMajor !== 2) {
          res2.setHeader("Connection", "close");
        }
        if (return503OnClosing) {
          const headers = {
            "Content-Type": "application/json",
            "Content-Length": "80"
          };
          res2.writeHead(503, headers);
          res2.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
          childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
          return;
        }
      }
      const connHeader = String.prototype.toLowerCase.call(req2.headers.connection || "");
      if (connHeader === "keep-alive") {
        if (keepAliveConnections.has(req2.socket) === false) {
          keepAliveConnections.add(req2.socket);
          req2.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req2.socket }));
        }
      }
      if (req2.headers[kRequestAcceptVersion] !== void 0) {
        req2.headers["accept-version"] = req2.headers[kRequestAcceptVersion];
        req2.headers[kRequestAcceptVersion] = void 0;
      }
      const request2 = new context2.Request(id2, params, req2, query, childLogger, context2);
      const reply2 = new context2.Reply(res2, request2, childLogger);
      const resolvedDisableRequestLogging = disableRequestLoggingFn ? disableRequestLoggingFn(request2) : disableRequestLogging;
      childLogger[kDisableRequestLogging] = resolvedDisableRequestLogging;
      if (resolvedDisableRequestLogging === false) {
        childLogger.info({ req: request2 }, "incoming request");
      }
      if (hasLogger === true || context2.onResponse !== null) {
        setupResponseListeners(reply2);
      }
      if (context2.onRequest !== null) {
        onRequestHookRunner(
          context2.onRequest,
          request2,
          reply2,
          runPreParsing
        );
      } else {
        runPreParsing(null, request2, reply2);
      }
      if (context2.onRequestAbort !== null) {
        req2.on("close", () => {
          if (req2.aborted) {
            onRequestAbortHookRunner(
              context2.onRequestAbort,
              request2,
              handleOnRequestAbortHooksErrors.bind(null, reply2)
            );
          }
        });
      }
      if (context2.onTimeout !== null) {
        if (!request2.raw.socket._meta) {
          request2.raw.socket.on("timeout", handleTimeout);
        }
        request2.raw.socket._meta = { context: context2, request: request2, reply: reply2 };
      }
    }
  }
  function handleOnRequestAbortHooksErrors(reply2, err2) {
    if (err2) {
      reply2.log.error({ err: err2 }, "onRequestAborted hook failed");
    }
  }
  function handleTimeout() {
    const { context: context2, request: request2, reply: reply2 } = this._meta;
    onTimeoutHookRunner(
      context2.onTimeout,
      request2,
      reply2,
      noop2
    );
  }
  function normalizeAndValidateMethod(method) {
    if (typeof method !== "string") {
      throw new FST_ERR_ROUTE_METHOD_INVALID();
    }
    method = method.toUpperCase();
    if (!this[kSupportedHTTPMethods].bodyless.has(method) && !this[kSupportedHTTPMethods].bodywith.has(method)) {
      throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
    }
    return method;
  }
  function validateSchemaBodyOption(method, path2, schema) {
    if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
      throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path2);
    }
  }
  function validateBodyLimitOption(bodyLimit) {
    if (bodyLimit === void 0) return;
    if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
      throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
    }
  }
  function runPreParsing(err2, request2, reply2) {
    if (reply2.sent === true) return;
    if (err2 != null) {
      reply2[kReplyIsError] = true;
      reply2.send(err2);
      return;
    }
    request2[kRequestPayloadStream] = request2.raw;
    if (request2[kRouteContext].preParsing !== null) {
      preParsingHookRunner(request2[kRouteContext].preParsing, request2, reply2, handleRequest2.bind(request2.server));
    } else {
      handleRequest2.call(request2.server, null, request2, reply2);
    }
  }
  function buildRouterOptions(options, defaultOptions) {
    const routerOptions = options.routerOptions || /* @__PURE__ */ Object.create(null);
    const usedDeprecatedOptions = routerKeys.filter((key) => Object.hasOwn(options, key));
    if (usedDeprecatedOptions.length > 0) {
      FSTDEP022(usedDeprecatedOptions.join(", "));
    }
    for (const key of routerKeys) {
      if (!Object.hasOwn(routerOptions, key)) {
        routerOptions[key] = options[key] ?? defaultOptions[key];
      }
    }
    return routerOptions;
  }
  function removeTrackedSocket() {
    this.keepAliveConnections.delete(this.socket);
  }
  function noop2() {
  }
  route = { buildRouting, validateBodyLimitOption, buildRouterOptions };
  return route;
}
var fourOhFour_1;
var hasRequiredFourOhFour;
function requireFourOhFour() {
  if (hasRequiredFourOhFour) return fourOhFour_1;
  hasRequiredFourOhFour = 1;
  const FindMyWay = requireFindMyWay();
  const Reply = requireReply();
  const Request = requireRequest$1();
  const Context = requireContext();
  const {
    kRoutePrefix,
    kCanSetNotFoundHandler,
    kFourOhFourLevelInstance,
    kFourOhFourContext,
    kHooks,
    kErrorHandler
  } = requireSymbols$1();
  const { lifecycleHooks } = requireHooks();
  const { buildErrorHandler } = requireErrorHandler();
  const {
    FST_ERR_NOT_FOUND
  } = requireErrors$2();
  const { createChildLogger } = requireLoggerFactory();
  const { getGenReqId } = requireReqIdGenFactory();
  function fourOhFour(options) {
    const { logger, disableRequestLogging } = options;
    const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
    let _onBadUrlHandler = null;
    return { router, setNotFoundHandler, setContext, arrange404 };
    function arrange404(instance) {
      instance[kFourOhFourLevelInstance] = instance;
      instance[kCanSetNotFoundHandler] = true;
      router.onBadUrl = router.onBadUrl.bind(instance);
      router.defaultRoute = router.defaultRoute.bind(instance);
    }
    function basic404(request2, reply2) {
      const { url, method } = request2.raw;
      const message = `Route ${method}:${url} not found`;
      const resolvedDisableRequestLogging = typeof disableRequestLogging === "function" ? disableRequestLogging(request2.raw) : disableRequestLogging;
      if (!resolvedDisableRequestLogging) {
        request2.log.info(message);
      }
      reply2.code(404).send({
        message,
        error: "Not Found",
        statusCode: 404
      });
    }
    function createOnBadUrl() {
      return function onBadUrl(path2, req2, res2) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id2 = getGenReqId(fourOhFourContext.server, req2);
        const childLogger = createChildLogger(fourOhFourContext, logger, req2, id2);
        const request2 = new Request(id2, null, req2, null, childLogger, fourOhFourContext);
        const reply2 = new Reply(res2, request2, childLogger);
        _onBadUrlHandler(request2, reply2);
      };
    }
    function setContext(instance, context2) {
      const _404Context = Object.assign({}, instance[kFourOhFourContext]);
      _404Context.onSend = context2.onSend;
      context2[kFourOhFourContext] = _404Context;
    }
    function setNotFoundHandler(opts, handler, avvio, routeHandler) {
      if (this[kCanSetNotFoundHandler] === void 0) {
        this[kCanSetNotFoundHandler] = true;
      }
      if (this[kFourOhFourContext] === void 0) {
        this[kFourOhFourContext] = null;
      }
      const _fastify = this;
      const prefix = this[kRoutePrefix] || "/";
      if (this[kCanSetNotFoundHandler] === false) {
        throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
      }
      if (typeof opts === "object") {
        if (opts.preHandler) {
          if (Array.isArray(opts.preHandler)) {
            opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
          } else {
            opts.preHandler = opts.preHandler.bind(_fastify);
          }
        }
        if (opts.preValidation) {
          if (Array.isArray(opts.preValidation)) {
            opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
          } else {
            opts.preValidation = opts.preValidation.bind(_fastify);
          }
        }
      }
      if (typeof opts === "function") {
        handler = opts;
        opts = void 0;
      }
      opts = opts || {};
      if (handler) {
        this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
        handler = handler.bind(this);
        _onBadUrlHandler = handler;
      } else {
        handler = basic404;
        _onBadUrlHandler = basic404;
      }
      this.after((notHandledErr, done) => {
        _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
        done(notHandledErr);
      });
    }
    function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
      const context2 = new Context({
        schema: opts.schema,
        handler,
        config: opts.config || {},
        server: this
      });
      avvio.once("preReady", () => {
        const context3 = this[kFourOhFourContext];
        for (const hook of lifecycleHooks) {
          const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
          context3[hook] = toSet.length ? toSet : null;
        }
        context3.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
      });
      if (this[kFourOhFourContext] !== null && prefix === "/") {
        Object.assign(this[kFourOhFourContext], context2);
        return;
      }
      this[kFourOhFourLevelInstance][kFourOhFourContext] = context2;
      router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context2);
      router.all(prefix, routeHandler, context2);
    }
    function fourOhFourFallBack(req2, res2) {
      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
      const id2 = getGenReqId(fourOhFourContext.server, req2);
      const childLogger = createChildLogger(fourOhFourContext, logger, req2, id2);
      childLogger.info({ req: req2 }, "incoming request");
      const request2 = new Request(id2, null, req2, null, childLogger, fourOhFourContext);
      const reply2 = new Reply(res2, request2, childLogger);
      request2.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
      request2.log.warn(router.prettyPrint());
      reply2.code(404).send(new FST_ERR_NOT_FOUND());
    }
  }
  fourOhFour_1 = fourOhFour;
  return fourOhFour_1;
}
var initialConfigValidation = { exports: {} };
var configValidator$1 = { exports: {} };
var hasRequiredConfigValidator$1;
function requireConfigValidator$1() {
  if (hasRequiredConfigValidator$1) return configValidator$1.exports;
  hasRequiredConfigValidator$1 = 1;
  configValidator$1.exports = validate10;
  configValidator$1.exports.default = validate10;
  const schema11 = { "properties": { "connectionTimeout": { "type": "integer", "default": 0 }, "keepAliveTimeout": { "type": "integer", "default": 72e3 }, "forceCloseConnections": { "oneOf": [{ "type": "string", "pattern": "idle" }, { "type": "boolean" }] }, "maxRequestsPerSocket": { "type": "integer", "default": 0, "nullable": true }, "requestTimeout": { "type": "integer", "default": 0 }, "bodyLimit": { "type": "integer", "default": 1048576 }, "caseSensitive": { "type": "boolean", "default": true }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "http2": { "type": "boolean" }, "https": { "if": { "not": { "oneOf": [{ "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["allowHTTP1"], "properties": { "allowHTTP1": { "type": "boolean" } } }] } }, "then": { "setDefaultValue": true } }, "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "disableRequestLogging": { "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "onProtoPoisoning": { "type": "string", "default": "error" }, "onConstructorPoisoning": { "type": "string", "default": "error" }, "pluginTimeout": { "type": "integer", "default": 1e4 }, "requestIdHeader": { "anyOf": [{ "type": "boolean" }, { "type": "string" }], "default": false }, "requestIdLogLabel": { "type": "string", "default": "reqId" }, "http2SessionTimeout": { "type": "integer", "default": 72e3 }, "exposeHeadRoutes": { "type": "boolean", "default": true }, "useSemicolonDelimiter": { "type": "boolean", "default": false }, "routerOptions": { "type": "object", "additionalProperties": true, "properties": { "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "useSemicolonDelimiter": { "type": "boolean", "default": false } } }, "constraints": { "type": "object", "additionalProperties": { "type": "object", "required": ["name", "storage", "validate", "deriveConstraint"], "additionalProperties": true, "properties": { "name": { "type": "string" }, "storage": {}, "validate": {}, "deriveConstraint": {} } } } } };
  const func2 = Object.prototype.hasOwnProperty;
  const pattern0 = new RegExp("idle", "u");
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    if (errors2 === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.connectionTimeout === void 0) {
          data.connectionTimeout = 0;
        }
        if (data.keepAliveTimeout === void 0) {
          data.keepAliveTimeout = 72e3;
        }
        if (data.maxRequestsPerSocket === void 0) {
          data.maxRequestsPerSocket = 0;
        }
        if (data.requestTimeout === void 0) {
          data.requestTimeout = 0;
        }
        if (data.bodyLimit === void 0) {
          data.bodyLimit = 1048576;
        }
        if (data.caseSensitive === void 0) {
          data.caseSensitive = true;
        }
        if (data.allowUnsafeRegex === void 0) {
          data.allowUnsafeRegex = false;
        }
        if (data.ignoreTrailingSlash === void 0) {
          data.ignoreTrailingSlash = false;
        }
        if (data.ignoreDuplicateSlashes === void 0) {
          data.ignoreDuplicateSlashes = false;
        }
        if (data.disableRequestLogging === void 0) {
          data.disableRequestLogging = false;
        }
        if (data.maxParamLength === void 0) {
          data.maxParamLength = 100;
        }
        if (data.onProtoPoisoning === void 0) {
          data.onProtoPoisoning = "error";
        }
        if (data.onConstructorPoisoning === void 0) {
          data.onConstructorPoisoning = "error";
        }
        if (data.pluginTimeout === void 0) {
          data.pluginTimeout = 1e4;
        }
        if (data.requestIdHeader === void 0) {
          data.requestIdHeader = false;
        }
        if (data.requestIdLogLabel === void 0) {
          data.requestIdLogLabel = "reqId";
        }
        if (data.http2SessionTimeout === void 0) {
          data.http2SessionTimeout = 72e3;
        }
        if (data.exposeHeadRoutes === void 0) {
          data.exposeHeadRoutes = true;
        }
        if (data.useSemicolonDelimiter === void 0) {
          data.useSemicolonDelimiter = false;
        }
        const _errs1 = errors2;
        for (const key0 in data) {
          if (!func2.call(schema11.properties, key0)) {
            delete data[key0];
          }
        }
        if (_errs1 === errors2) {
          let data0 = data.connectionTimeout;
          const _errs2 = errors2;
          if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            let dataType0 = typeof data0;
            let coerced0 = void 0;
            if (!(coerced0 !== void 0)) {
              if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                coerced0 = +data0;
              } else {
                validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                return false;
              }
            }
            if (coerced0 !== void 0) {
              data0 = coerced0;
              if (data !== void 0) {
                data["connectionTimeout"] = coerced0;
              }
            }
          }
          var valid0 = _errs2 === errors2;
          if (valid0) {
            let data1 = data.keepAliveTimeout;
            const _errs4 = errors2;
            if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
              let dataType1 = typeof data1;
              let coerced1 = void 0;
              if (!(coerced1 !== void 0)) {
                if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                  coerced1 = +data1;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced1 !== void 0) {
                data1 = coerced1;
                if (data !== void 0) {
                  data["keepAliveTimeout"] = coerced1;
                }
              }
            }
            var valid0 = _errs4 === errors2;
            if (valid0) {
              if (data.forceCloseConnections !== void 0) {
                let data2 = data.forceCloseConnections;
                const _errs6 = errors2;
                const _errs7 = errors2;
                let valid1 = false;
                let passing0 = null;
                const _errs8 = errors2;
                if (typeof data2 !== "string") {
                  let dataType2 = typeof data2;
                  let coerced2 = void 0;
                  if (!(coerced2 !== void 0)) {
                    if (dataType2 == "number" || dataType2 == "boolean") {
                      coerced2 = "" + data2;
                    } else if (data2 === null) {
                      coerced2 = "";
                    } else {
                      const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err0];
                      } else {
                        vErrors.push(err0);
                      }
                      errors2++;
                    }
                  }
                  if (coerced2 !== void 0) {
                    data2 = coerced2;
                    if (data !== void 0) {
                      data["forceCloseConnections"] = coerced2;
                    }
                  }
                }
                if (errors2 === _errs8) {
                  if (typeof data2 === "string") {
                    if (!pattern0.test(data2)) {
                      const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors2++;
                    }
                  }
                }
                var _valid0 = _errs8 === errors2;
                if (_valid0) {
                  valid1 = true;
                  passing0 = 0;
                }
                const _errs10 = errors2;
                if (typeof data2 !== "boolean") {
                  let coerced3 = void 0;
                  if (!(coerced3 !== void 0)) {
                    if (data2 === "false" || data2 === 0 || data2 === null) {
                      coerced3 = false;
                    } else if (data2 === "true" || data2 === 1) {
                      coerced3 = true;
                    } else {
                      const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                      if (vErrors === null) {
                        vErrors = [err2];
                      } else {
                        vErrors.push(err2);
                      }
                      errors2++;
                    }
                  }
                  if (coerced3 !== void 0) {
                    data2 = coerced3;
                    if (data !== void 0) {
                      data["forceCloseConnections"] = coerced3;
                    }
                  }
                }
                var _valid0 = _errs10 === errors2;
                if (_valid0 && valid1) {
                  valid1 = false;
                  passing0 = [passing0, 1];
                } else {
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 1;
                  }
                }
                if (!valid1) {
                  const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors2++;
                  validate10.errors = vErrors;
                  return false;
                } else {
                  errors2 = _errs7;
                  if (vErrors !== null) {
                    if (_errs7) {
                      vErrors.length = _errs7;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid0 = _errs6 === errors2;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                let data3 = data.maxRequestsPerSocket;
                const _errs12 = errors2;
                if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3)) && data3 !== null) {
                  let dataType4 = typeof data3;
                  let coerced4 = void 0;
                  if (!(coerced4 !== void 0)) {
                    if (dataType4 === "boolean" || data3 === null || dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1)) {
                      coerced4 = +data3;
                    } else if (data3 === "" || data3 === 0 || data3 === false) {
                      coerced4 = null;
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                      return false;
                    }
                  }
                  if (coerced4 !== void 0) {
                    data3 = coerced4;
                    if (data !== void 0) {
                      data["maxRequestsPerSocket"] = coerced4;
                    }
                  }
                }
                var valid0 = _errs12 === errors2;
                if (valid0) {
                  let data4 = data.requestTimeout;
                  const _errs15 = errors2;
                  if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                    let dataType5 = typeof data4;
                    let coerced5 = void 0;
                    if (!(coerced5 !== void 0)) {
                      if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                        coerced5 = +data4;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced5 !== void 0) {
                      data4 = coerced5;
                      if (data !== void 0) {
                        data["requestTimeout"] = coerced5;
                      }
                    }
                  }
                  var valid0 = _errs15 === errors2;
                  if (valid0) {
                    let data5 = data.bodyLimit;
                    const _errs17 = errors2;
                    if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                      let dataType6 = typeof data5;
                      let coerced6 = void 0;
                      if (!(coerced6 !== void 0)) {
                        if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                          coerced6 = +data5;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced6 !== void 0) {
                        data5 = coerced6;
                        if (data !== void 0) {
                          data["bodyLimit"] = coerced6;
                        }
                      }
                    }
                    var valid0 = _errs17 === errors2;
                    if (valid0) {
                      let data6 = data.caseSensitive;
                      const _errs19 = errors2;
                      if (typeof data6 !== "boolean") {
                        let coerced7 = void 0;
                        if (!(coerced7 !== void 0)) {
                          if (data6 === "false" || data6 === 0 || data6 === null) {
                            coerced7 = false;
                          } else if (data6 === "true" || data6 === 1) {
                            coerced7 = true;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                            return false;
                          }
                        }
                        if (coerced7 !== void 0) {
                          data6 = coerced7;
                          if (data !== void 0) {
                            data["caseSensitive"] = coerced7;
                          }
                        }
                      }
                      var valid0 = _errs19 === errors2;
                      if (valid0) {
                        let data7 = data.allowUnsafeRegex;
                        const _errs21 = errors2;
                        if (typeof data7 !== "boolean") {
                          let coerced8 = void 0;
                          if (!(coerced8 !== void 0)) {
                            if (data7 === "false" || data7 === 0 || data7 === null) {
                              coerced8 = false;
                            } else if (data7 === "true" || data7 === 1) {
                              coerced8 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced8 !== void 0) {
                            data7 = coerced8;
                            if (data !== void 0) {
                              data["allowUnsafeRegex"] = coerced8;
                            }
                          }
                        }
                        var valid0 = _errs21 === errors2;
                        if (valid0) {
                          if (data.http2 !== void 0) {
                            let data8 = data.http2;
                            const _errs23 = errors2;
                            if (typeof data8 !== "boolean") {
                              let coerced9 = void 0;
                              if (!(coerced9 !== void 0)) {
                                if (data8 === "false" || data8 === 0 || data8 === null) {
                                  coerced9 = false;
                                } else if (data8 === "true" || data8 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== void 0) {
                                data8 = coerced9;
                                if (data !== void 0) {
                                  data["http2"] = coerced9;
                                }
                              }
                            }
                            var valid0 = _errs23 === errors2;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.https !== void 0) {
                              let data9 = data.https;
                              const _errs25 = errors2;
                              const _errs26 = errors2;
                              let valid2 = true;
                              const _errs27 = errors2;
                              const _errs28 = errors2;
                              const _errs29 = errors2;
                              const _errs30 = errors2;
                              let valid4 = false;
                              const _errs31 = errors2;
                              if (typeof data9 !== "boolean") {
                                let coerced10 = void 0;
                                if (!(coerced10 !== void 0)) {
                                  if (data9 === "false" || data9 === 0 || data9 === null) {
                                    coerced10 = false;
                                  } else if (data9 === "true" || data9 === 1) {
                                    coerced10 = true;
                                  } else {
                                    const err4 = {};
                                    if (vErrors === null) {
                                      vErrors = [err4];
                                    } else {
                                      vErrors.push(err4);
                                    }
                                    errors2++;
                                  }
                                }
                                if (coerced10 !== void 0) {
                                  data9 = coerced10;
                                  if (data !== void 0) {
                                    data["https"] = coerced10;
                                  }
                                }
                              }
                              var _valid2 = _errs31 === errors2;
                              if (_valid2) {
                                valid4 = true;
                              }
                              const _errs33 = errors2;
                              if (data9 !== null) {
                                let coerced11 = void 0;
                                if (!(coerced11 !== void 0)) {
                                  if (data9 === "" || data9 === 0 || data9 === false) {
                                    coerced11 = null;
                                  } else {
                                    const err5 = {};
                                    if (vErrors === null) {
                                      vErrors = [err5];
                                    } else {
                                      vErrors.push(err5);
                                    }
                                    errors2++;
                                  }
                                }
                                if (coerced11 !== void 0) {
                                  data9 = coerced11;
                                  if (data !== void 0) {
                                    data["https"] = coerced11;
                                  }
                                }
                              }
                              var _valid2 = _errs33 === errors2;
                              if (_valid2 && valid4) {
                                valid4 = false;
                              } else {
                                if (_valid2) {
                                  valid4 = true;
                                }
                                const _errs35 = errors2;
                                if (errors2 === _errs35) {
                                  if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                    if (data9.allowHTTP1 === void 0 && "allowHTTP1") {
                                      const err6 = {};
                                      if (vErrors === null) {
                                        vErrors = [err6];
                                      } else {
                                        vErrors.push(err6);
                                      }
                                      errors2++;
                                    } else {
                                      const _errs37 = errors2;
                                      for (const key1 in data9) {
                                        if (!(key1 === "allowHTTP1")) {
                                          delete data9[key1];
                                        }
                                      }
                                      if (_errs37 === errors2) {
                                        if (data9.allowHTTP1 !== void 0) {
                                          let data10 = data9.allowHTTP1;
                                          if (typeof data10 !== "boolean") {
                                            let coerced12 = void 0;
                                            if (!(coerced12 !== void 0)) {
                                              if (data10 === "false" || data10 === 0 || data10 === null) {
                                                coerced12 = false;
                                              } else if (data10 === "true" || data10 === 1) {
                                                coerced12 = true;
                                              } else {
                                                const err7 = {};
                                                if (vErrors === null) {
                                                  vErrors = [err7];
                                                } else {
                                                  vErrors.push(err7);
                                                }
                                                errors2++;
                                              }
                                            }
                                            if (coerced12 !== void 0) {
                                              data10 = coerced12;
                                              if (data9 !== void 0) {
                                                data9["allowHTTP1"] = coerced12;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    const err8 = {};
                                    if (vErrors === null) {
                                      vErrors = [err8];
                                    } else {
                                      vErrors.push(err8);
                                    }
                                    errors2++;
                                  }
                                }
                                var _valid2 = _errs35 === errors2;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                  }
                                }
                              }
                              if (!valid4) {
                                const err9 = {};
                                if (vErrors === null) {
                                  vErrors = [err9];
                                } else {
                                  vErrors.push(err9);
                                }
                                errors2++;
                              } else {
                                errors2 = _errs30;
                                if (vErrors !== null) {
                                  if (_errs30) {
                                    vErrors.length = _errs30;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var valid3 = _errs29 === errors2;
                              if (valid3) {
                                const err10 = {};
                                if (vErrors === null) {
                                  vErrors = [err10];
                                } else {
                                  vErrors.push(err10);
                                }
                                errors2++;
                              } else {
                                errors2 = _errs28;
                                if (vErrors !== null) {
                                  if (_errs28) {
                                    vErrors.length = _errs28;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var _valid1 = _errs27 === errors2;
                              errors2 = _errs26;
                              if (vErrors !== null) {
                                if (_errs26) {
                                  vErrors.length = _errs26;
                                } else {
                                  vErrors = null;
                                }
                              }
                              if (_valid1) {
                                const _errs40 = errors2;
                                data["https"] = true;
                                var _valid1 = _errs40 === errors2;
                                valid2 = _valid1;
                              }
                              if (!valid2) {
                                const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                                if (vErrors === null) {
                                  vErrors = [err11];
                                } else {
                                  vErrors.push(err11);
                                }
                                errors2++;
                                validate10.errors = vErrors;
                                return false;
                              }
                              var valid0 = _errs25 === errors2;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              let data11 = data.ignoreTrailingSlash;
                              const _errs41 = errors2;
                              if (typeof data11 !== "boolean") {
                                let coerced13 = void 0;
                                if (!(coerced13 !== void 0)) {
                                  if (data11 === "false" || data11 === 0 || data11 === null) {
                                    coerced13 = false;
                                  } else if (data11 === "true" || data11 === 1) {
                                    coerced13 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced13 !== void 0) {
                                  data11 = coerced13;
                                  if (data !== void 0) {
                                    data["ignoreTrailingSlash"] = coerced13;
                                  }
                                }
                              }
                              var valid0 = _errs41 === errors2;
                              if (valid0) {
                                let data12 = data.ignoreDuplicateSlashes;
                                const _errs43 = errors2;
                                if (typeof data12 !== "boolean") {
                                  let coerced14 = void 0;
                                  if (!(coerced14 !== void 0)) {
                                    if (data12 === "false" || data12 === 0 || data12 === null) {
                                      coerced14 = false;
                                    } else if (data12 === "true" || data12 === 1) {
                                      coerced14 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced14 !== void 0) {
                                    data12 = coerced14;
                                    if (data !== void 0) {
                                      data["ignoreDuplicateSlashes"] = coerced14;
                                    }
                                  }
                                }
                                var valid0 = _errs43 === errors2;
                                if (valid0) {
                                  let data13 = data.maxParamLength;
                                  const _errs45 = errors2;
                                  if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                    let dataType15 = typeof data13;
                                    let coerced15 = void 0;
                                    if (!(coerced15 !== void 0)) {
                                      if (dataType15 === "boolean" || data13 === null || dataType15 === "string" && data13 && data13 == +data13 && !(data13 % 1)) {
                                        coerced15 = +data13;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                        return false;
                                      }
                                    }
                                    if (coerced15 !== void 0) {
                                      data13 = coerced15;
                                      if (data !== void 0) {
                                        data["maxParamLength"] = coerced15;
                                      }
                                    }
                                  }
                                  var valid0 = _errs45 === errors2;
                                  if (valid0) {
                                    let data14 = data.onProtoPoisoning;
                                    const _errs47 = errors2;
                                    if (typeof data14 !== "string") {
                                      let dataType16 = typeof data14;
                                      let coerced16 = void 0;
                                      if (!(coerced16 !== void 0)) {
                                        if (dataType16 == "number" || dataType16 == "boolean") {
                                          coerced16 = "" + data14;
                                        } else if (data14 === null) {
                                          coerced16 = "";
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                      }
                                      if (coerced16 !== void 0) {
                                        data14 = coerced16;
                                        if (data !== void 0) {
                                          data["onProtoPoisoning"] = coerced16;
                                        }
                                      }
                                    }
                                    var valid0 = _errs47 === errors2;
                                    if (valid0) {
                                      let data15 = data.onConstructorPoisoning;
                                      const _errs49 = errors2;
                                      if (typeof data15 !== "string") {
                                        let dataType17 = typeof data15;
                                        let coerced17 = void 0;
                                        if (!(coerced17 !== void 0)) {
                                          if (dataType17 == "number" || dataType17 == "boolean") {
                                            coerced17 = "" + data15;
                                          } else if (data15 === null) {
                                            coerced17 = "";
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                        if (coerced17 !== void 0) {
                                          data15 = coerced17;
                                          if (data !== void 0) {
                                            data["onConstructorPoisoning"] = coerced17;
                                          }
                                        }
                                      }
                                      var valid0 = _errs49 === errors2;
                                      if (valid0) {
                                        let data16 = data.pluginTimeout;
                                        const _errs51 = errors2;
                                        if (!(typeof data16 == "number" && (!(data16 % 1) && !isNaN(data16)) && isFinite(data16))) {
                                          let dataType18 = typeof data16;
                                          let coerced18 = void 0;
                                          if (!(coerced18 !== void 0)) {
                                            if (dataType18 === "boolean" || data16 === null || dataType18 === "string" && data16 && data16 == +data16 && !(data16 % 1)) {
                                              coerced18 = +data16;
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                              return false;
                                            }
                                          }
                                          if (coerced18 !== void 0) {
                                            data16 = coerced18;
                                            if (data !== void 0) {
                                              data["pluginTimeout"] = coerced18;
                                            }
                                          }
                                        }
                                        var valid0 = _errs51 === errors2;
                                        if (valid0) {
                                          let data17 = data.requestIdHeader;
                                          const _errs53 = errors2;
                                          const _errs54 = errors2;
                                          let valid6 = false;
                                          const _errs55 = errors2;
                                          if (typeof data17 !== "boolean") {
                                            let coerced19 = void 0;
                                            if (!(coerced19 !== void 0)) {
                                              if (data17 === "false" || data17 === 0 || data17 === null) {
                                                coerced19 = false;
                                              } else if (data17 === "true" || data17 === 1) {
                                                coerced19 = true;
                                              } else {
                                                const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                if (vErrors === null) {
                                                  vErrors = [err12];
                                                } else {
                                                  vErrors.push(err12);
                                                }
                                                errors2++;
                                              }
                                            }
                                            if (coerced19 !== void 0) {
                                              data17 = coerced19;
                                              if (data !== void 0) {
                                                data["requestIdHeader"] = coerced19;
                                              }
                                            }
                                          }
                                          var _valid3 = _errs55 === errors2;
                                          valid6 = valid6 || _valid3;
                                          if (!valid6) {
                                            const _errs57 = errors2;
                                            if (typeof data17 !== "string") {
                                              let dataType20 = typeof data17;
                                              let coerced20 = void 0;
                                              if (!(coerced20 !== void 0)) {
                                                if (dataType20 == "number" || dataType20 == "boolean") {
                                                  coerced20 = "" + data17;
                                                } else if (data17 === null) {
                                                  coerced20 = "";
                                                } else {
                                                  const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  if (vErrors === null) {
                                                    vErrors = [err13];
                                                  } else {
                                                    vErrors.push(err13);
                                                  }
                                                  errors2++;
                                                }
                                              }
                                              if (coerced20 !== void 0) {
                                                data17 = coerced20;
                                                if (data !== void 0) {
                                                  data["requestIdHeader"] = coerced20;
                                                }
                                              }
                                            }
                                            var _valid3 = _errs57 === errors2;
                                            valid6 = valid6 || _valid3;
                                          }
                                          if (!valid6) {
                                            const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            if (vErrors === null) {
                                              vErrors = [err14];
                                            } else {
                                              vErrors.push(err14);
                                            }
                                            errors2++;
                                            validate10.errors = vErrors;
                                            return false;
                                          } else {
                                            errors2 = _errs54;
                                            if (vErrors !== null) {
                                              if (_errs54) {
                                                vErrors.length = _errs54;
                                              } else {
                                                vErrors = null;
                                              }
                                            }
                                          }
                                          var valid0 = _errs53 === errors2;
                                          if (valid0) {
                                            let data18 = data.requestIdLogLabel;
                                            const _errs59 = errors2;
                                            if (typeof data18 !== "string") {
                                              let dataType21 = typeof data18;
                                              let coerced21 = void 0;
                                              if (!(coerced21 !== void 0)) {
                                                if (dataType21 == "number" || dataType21 == "boolean") {
                                                  coerced21 = "" + data18;
                                                } else if (data18 === null) {
                                                  coerced21 = "";
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced21 !== void 0) {
                                                data18 = coerced21;
                                                if (data !== void 0) {
                                                  data["requestIdLogLabel"] = coerced21;
                                                }
                                              }
                                            }
                                            var valid0 = _errs59 === errors2;
                                            if (valid0) {
                                              let data19 = data.http2SessionTimeout;
                                              const _errs61 = errors2;
                                              if (!(typeof data19 == "number" && (!(data19 % 1) && !isNaN(data19)) && isFinite(data19))) {
                                                let dataType22 = typeof data19;
                                                let coerced22 = void 0;
                                                if (!(coerced22 !== void 0)) {
                                                  if (dataType22 === "boolean" || data19 === null || dataType22 === "string" && data19 && data19 == +data19 && !(data19 % 1)) {
                                                    coerced22 = +data19;
                                                  } else {
                                                    validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                    return false;
                                                  }
                                                }
                                                if (coerced22 !== void 0) {
                                                  data19 = coerced22;
                                                  if (data !== void 0) {
                                                    data["http2SessionTimeout"] = coerced22;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs61 === errors2;
                                              if (valid0) {
                                                let data20 = data.exposeHeadRoutes;
                                                const _errs63 = errors2;
                                                if (typeof data20 !== "boolean") {
                                                  let coerced23 = void 0;
                                                  if (!(coerced23 !== void 0)) {
                                                    if (data20 === "false" || data20 === 0 || data20 === null) {
                                                      coerced23 = false;
                                                    } else if (data20 === "true" || data20 === 1) {
                                                      coerced23 = true;
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced23 !== void 0) {
                                                    data20 = coerced23;
                                                    if (data !== void 0) {
                                                      data["exposeHeadRoutes"] = coerced23;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs63 === errors2;
                                                if (valid0) {
                                                  let data21 = data.useSemicolonDelimiter;
                                                  const _errs65 = errors2;
                                                  if (typeof data21 !== "boolean") {
                                                    let coerced24 = void 0;
                                                    if (!(coerced24 !== void 0)) {
                                                      if (data21 === "false" || data21 === 0 || data21 === null) {
                                                        coerced24 = false;
                                                      } else if (data21 === "true" || data21 === 1) {
                                                        coerced24 = true;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced24 !== void 0) {
                                                      data21 = coerced24;
                                                      if (data !== void 0) {
                                                        data["useSemicolonDelimiter"] = coerced24;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs65 === errors2;
                                                  if (valid0) {
                                                    if (data.routerOptions !== void 0) {
                                                      let data22 = data.routerOptions;
                                                      const _errs67 = errors2;
                                                      if (errors2 === _errs67) {
                                                        if (data22 && typeof data22 == "object" && !Array.isArray(data22)) {
                                                          if (data22.ignoreTrailingSlash === void 0) {
                                                            data22.ignoreTrailingSlash = false;
                                                          }
                                                          if (data22.ignoreDuplicateSlashes === void 0) {
                                                            data22.ignoreDuplicateSlashes = false;
                                                          }
                                                          if (data22.maxParamLength === void 0) {
                                                            data22.maxParamLength = 100;
                                                          }
                                                          if (data22.allowUnsafeRegex === void 0) {
                                                            data22.allowUnsafeRegex = false;
                                                          }
                                                          if (data22.useSemicolonDelimiter === void 0) {
                                                            data22.useSemicolonDelimiter = false;
                                                          }
                                                          let data23 = data22.ignoreTrailingSlash;
                                                          const _errs70 = errors2;
                                                          if (typeof data23 !== "boolean") {
                                                            let coerced25 = void 0;
                                                            if (!(coerced25 !== void 0)) {
                                                              if (data23 === "false" || data23 === 0 || data23 === null) {
                                                                coerced25 = false;
                                                              } else if (data23 === "true" || data23 === 1) {
                                                                coerced25 = true;
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreTrailingSlash", schemaPath: "#/properties/routerOptions/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                return false;
                                                              }
                                                            }
                                                            if (coerced25 !== void 0) {
                                                              data23 = coerced25;
                                                              if (data22 !== void 0) {
                                                                data22["ignoreTrailingSlash"] = coerced25;
                                                              }
                                                            }
                                                          }
                                                          var valid7 = _errs70 === errors2;
                                                          if (valid7) {
                                                            let data24 = data22.ignoreDuplicateSlashes;
                                                            const _errs72 = errors2;
                                                            if (typeof data24 !== "boolean") {
                                                              let coerced26 = void 0;
                                                              if (!(coerced26 !== void 0)) {
                                                                if (data24 === "false" || data24 === 0 || data24 === null) {
                                                                  coerced26 = false;
                                                                } else if (data24 === "true" || data24 === 1) {
                                                                  coerced26 = true;
                                                                } else {
                                                                  validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreDuplicateSlashes", schemaPath: "#/properties/routerOptions/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                  return false;
                                                                }
                                                              }
                                                              if (coerced26 !== void 0) {
                                                                data24 = coerced26;
                                                                if (data22 !== void 0) {
                                                                  data22["ignoreDuplicateSlashes"] = coerced26;
                                                                }
                                                              }
                                                            }
                                                            var valid7 = _errs72 === errors2;
                                                            if (valid7) {
                                                              let data25 = data22.maxParamLength;
                                                              const _errs74 = errors2;
                                                              if (!(typeof data25 == "number" && (!(data25 % 1) && !isNaN(data25)) && isFinite(data25))) {
                                                                let dataType27 = typeof data25;
                                                                let coerced27 = void 0;
                                                                if (!(coerced27 !== void 0)) {
                                                                  if (dataType27 === "boolean" || data25 === null || dataType27 === "string" && data25 && data25 == +data25 && !(data25 % 1)) {
                                                                    coerced27 = +data25;
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/routerOptions/maxParamLength", schemaPath: "#/properties/routerOptions/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                if (coerced27 !== void 0) {
                                                                  data25 = coerced27;
                                                                  if (data22 !== void 0) {
                                                                    data22["maxParamLength"] = coerced27;
                                                                  }
                                                                }
                                                              }
                                                              var valid7 = _errs74 === errors2;
                                                              if (valid7) {
                                                                let data26 = data22.allowUnsafeRegex;
                                                                const _errs76 = errors2;
                                                                if (typeof data26 !== "boolean") {
                                                                  let coerced28 = void 0;
                                                                  if (!(coerced28 !== void 0)) {
                                                                    if (data26 === "false" || data26 === 0 || data26 === null) {
                                                                      coerced28 = false;
                                                                    } else if (data26 === "true" || data26 === 1) {
                                                                      coerced28 = true;
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/routerOptions/allowUnsafeRegex", schemaPath: "#/properties/routerOptions/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  if (coerced28 !== void 0) {
                                                                    data26 = coerced28;
                                                                    if (data22 !== void 0) {
                                                                      data22["allowUnsafeRegex"] = coerced28;
                                                                    }
                                                                  }
                                                                }
                                                                var valid7 = _errs76 === errors2;
                                                                if (valid7) {
                                                                  let data27 = data22.useSemicolonDelimiter;
                                                                  const _errs78 = errors2;
                                                                  if (typeof data27 !== "boolean") {
                                                                    let coerced29 = void 0;
                                                                    if (!(coerced29 !== void 0)) {
                                                                      if (data27 === "false" || data27 === 0 || data27 === null) {
                                                                        coerced29 = false;
                                                                      } else if (data27 === "true" || data27 === 1) {
                                                                        coerced29 = true;
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/routerOptions/useSemicolonDelimiter", schemaPath: "#/properties/routerOptions/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    if (coerced29 !== void 0) {
                                                                      data27 = coerced29;
                                                                      if (data22 !== void 0) {
                                                                        data22["useSemicolonDelimiter"] = coerced29;
                                                                      }
                                                                    }
                                                                  }
                                                                  var valid7 = _errs78 === errors2;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/routerOptions", schemaPath: "#/properties/routerOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                          return false;
                                                        }
                                                      }
                                                      var valid0 = _errs67 === errors2;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.constraints !== void 0) {
                                                        let data28 = data.constraints;
                                                        const _errs80 = errors2;
                                                        if (errors2 === _errs80) {
                                                          if (data28 && typeof data28 == "object" && !Array.isArray(data28)) {
                                                            for (const key2 in data28) {
                                                              let data29 = data28[key2];
                                                              const _errs83 = errors2;
                                                              if (errors2 === _errs83) {
                                                                if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                  let missing1;
                                                                  if (data29.name === void 0 && (missing1 = "name") || data29.storage === void 0 && (missing1 = "storage") || data29.validate === void 0 && (missing1 = "validate") || data29.deriveConstraint === void 0 && (missing1 = "deriveConstraint")) {
                                                                    validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                    return false;
                                                                  } else {
                                                                    if (data29.name !== void 0) {
                                                                      let data30 = data29.name;
                                                                      if (typeof data30 !== "string") {
                                                                        let dataType30 = typeof data30;
                                                                        let coerced30 = void 0;
                                                                        if (!(coerced30 !== void 0)) {
                                                                          if (dataType30 == "number" || dataType30 == "boolean") {
                                                                            coerced30 = "" + data30;
                                                                          } else if (data30 === null) {
                                                                            coerced30 = "";
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        if (coerced30 !== void 0) {
                                                                          data30 = coerced30;
                                                                          if (data29 !== void 0) {
                                                                            data29["name"] = coerced30;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid8 = _errs83 === errors2;
                                                              if (!valid8) {
                                                                break;
                                                              }
                                                            }
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid0 = _errs80 === errors2;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors2 === 0;
  }
  configValidator$1.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 72e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "allowUnsafeRegex": false, "disableRequestLogging": false, "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": false, "requestIdLogLabel": "reqId", "http2SessionTimeout": 72e3, "exposeHeadRoutes": true, "useSemicolonDelimiter": false, "allowErrorHandlerOverride": true, "routerOptions": { "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "allowUnsafeRegex": false, "useSemicolonDelimiter": false } };
  return configValidator$1.exports;
}
var hasRequiredInitialConfigValidation;
function requireInitialConfigValidation() {
  if (hasRequiredInitialConfigValidation) return initialConfigValidation.exports;
  hasRequiredInitialConfigValidation = 1;
  const validate2 = requireConfigValidator$1();
  const deepClone = requireRfdc()({ circles: true, proto: false });
  const { FST_ERR_INIT_OPTS_INVALID } = requireErrors$2();
  function validateInitialConfig(options) {
    const opts = deepClone(options);
    if (!validate2(opts)) {
      const error2 = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate2.errors.map((e) => e.message)));
      error2.errors = validate2.errors;
      throw error2;
    }
    return deepFreezeObject(opts);
  }
  function deepFreezeObject(object2) {
    const properties2 = Object.getOwnPropertyNames(object2);
    for (const name of properties2) {
      const value = object2[name];
      if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
        continue;
      }
      object2[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
    }
    return Object.freeze(object2);
  }
  initialConfigValidation.exports = validateInitialConfig;
  initialConfigValidation.exports.defaultInitOptions = validate2.defaultInitOptions;
  initialConfigValidation.exports.utils = { deepFreezeObject };
  return initialConfigValidation.exports;
}
var pluginOverride;
var hasRequiredPluginOverride;
function requirePluginOverride() {
  if (hasRequiredPluginOverride) return pluginOverride;
  hasRequiredPluginOverride = 1;
  const {
    kAvvioBoot,
    kChildren,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kPluginNameChain,
    kErrorHandlerAlreadySet
  } = requireSymbols$1();
  const Reply = requireReply();
  const Request = requireRequest$1();
  const SchemaController = requireSchemaController();
  const ContentTypeParser = requireContentTypeParser();
  const { buildHooks } = requireHooks();
  const pluginUtils2 = requirePluginUtils();
  pluginOverride = function override(old, fn, opts) {
    const shouldSkipOverride = pluginUtils2.registerPlugin.call(old, fn);
    const fnName = pluginUtils2.getPluginName(fn) || pluginUtils2.getFuncPreview(fn);
    if (shouldSkipOverride) {
      old[kPluginNameChain].push(fnName);
      return old;
    }
    const instance = Object.create(old);
    old[kChildren].push(instance);
    instance.ready = old[kAvvioBoot].bind(instance);
    instance[kChildren] = [];
    instance[kReply] = Reply.buildReply(instance[kReply]);
    instance[kRequest] = Request.buildRequest(instance[kRequest]);
    instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
    instance[kHooks] = buildHooks(instance[kHooks]);
    instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
    instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
    instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
    instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
    instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
    instance[pluginUtils2.kRegisteredPlugins] = Object.create(instance[pluginUtils2.kRegisteredPlugins]);
    instance[kPluginNameChain] = [fnName];
    instance[kErrorHandlerAlreadySet] = false;
    if (instance[kLogSerializers] || opts.logSerializers) {
      instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
    }
    if (opts.prefix) {
      instance[kFourOhFour].arrange404(instance);
    }
    for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);
    return instance;
  };
  function buildRoutePrefix(instancePrefix, pluginPrefix) {
    if (!pluginPrefix) {
      return instancePrefix;
    }
    if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
      pluginPrefix = pluginPrefix.slice(1);
    } else if (pluginPrefix[0] !== "/") {
      pluginPrefix = "/" + pluginPrefix;
    }
    return instancePrefix + pluginPrefix;
  }
  return pluginOverride;
}
var lightMyRequest = { exports: {} };
var request = { exports: {} };
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.parseCookie = parseCookie;
  dist.parse = parseCookie;
  dist.stringifyCookie = stringifyCookie;
  dist.stringifySetCookie = stringifySetCookie;
  dist.serialize = stringifySetCookie;
  dist.parseSetCookie = parseSetCookie;
  dist.stringifySetCookie = stringifySetCookie;
  dist.serialize = stringifySetCookie;
  const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  const maxAgeRegExp = /^-?\d+$/;
  const __toString = Object.prototype.toString;
  const NullObject = /* @__PURE__ */ (() => {
    const C = function() {
    };
    C.prototype = /* @__PURE__ */ Object.create(null);
    return C;
  })();
  function parseCookie(str, options) {
    const obj = new NullObject();
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode2;
    let index = 0;
    do {
      const eqIdx = eqIndex(str, index, len);
      if (eqIdx === -1)
        break;
      const endIdx = endIndex(str, index, len);
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const key = valueSlice(str, index, eqIdx);
      if (obj[key] === void 0) {
        obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function stringifyCookie(cookie, options) {
    const enc = options?.encode || encodeURIComponent;
    const cookieStrings = [];
    for (const name of Object.keys(cookie)) {
      const val = cookie[name];
      if (val === void 0)
        continue;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`cookie name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`cookie val is invalid: ${val}`);
      }
      cookieStrings.push(`${name}=${value}`);
    }
    return cookieStrings.join("; ");
  }
  function stringifySetCookie(_name, _val, _opts) {
    const cookie = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
    const options = typeof _val === "object" ? _val : _opts;
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(cookie.name)) {
      throw new TypeError(`argument name is invalid: ${cookie.name}`);
    }
    const value = cookie.value ? enc(cookie.value) : "";
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${cookie.value}`);
    }
    let str = cookie.name + "=" + value;
    if (cookie.maxAge !== void 0) {
      if (!Number.isInteger(cookie.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);
      }
      str += "; Max-Age=" + cookie.maxAge;
    }
    if (cookie.domain) {
      if (!domainValueRegExp.test(cookie.domain)) {
        throw new TypeError(`option domain is invalid: ${cookie.domain}`);
      }
      str += "; Domain=" + cookie.domain;
    }
    if (cookie.path) {
      if (!pathValueRegExp.test(cookie.path)) {
        throw new TypeError(`option path is invalid: ${cookie.path}`);
      }
      str += "; Path=" + cookie.path;
    }
    if (cookie.expires) {
      if (!isDate2(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${cookie.expires}`);
      }
      str += "; Expires=" + cookie.expires.toUTCString();
    }
    if (cookie.httpOnly) {
      str += "; HttpOnly";
    }
    if (cookie.secure) {
      str += "; Secure";
    }
    if (cookie.partitioned) {
      str += "; Partitioned";
    }
    if (cookie.priority) {
      const priority = typeof cookie.priority === "string" ? cookie.priority.toLowerCase() : void 0;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${cookie.priority}`);
      }
    }
    if (cookie.sameSite) {
      const sameSite = typeof cookie.sameSite === "string" ? cookie.sameSite.toLowerCase() : cookie.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);
      }
    }
    return str;
  }
  function parseSetCookie(str, options) {
    const dec = options?.decode || decode2;
    const len = str.length;
    const endIdx = endIndex(str, 0, len);
    const eqIdx = eqIndex(str, 0, endIdx);
    const setCookie2 = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
      name: valueSlice(str, 0, eqIdx),
      value: dec(valueSlice(str, eqIdx + 1, endIdx))
    };
    let index = endIdx + 1;
    while (index < len) {
      const endIdx2 = endIndex(str, index, len);
      const eqIdx2 = eqIndex(str, index, endIdx2);
      const attr = eqIdx2 === -1 ? valueSlice(str, index, endIdx2) : valueSlice(str, index, eqIdx2);
      const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
      switch (attr.toLowerCase()) {
        case "httponly":
          setCookie2.httpOnly = true;
          break;
        case "secure":
          setCookie2.secure = true;
          break;
        case "partitioned":
          setCookie2.partitioned = true;
          break;
        case "domain":
          setCookie2.domain = val;
          break;
        case "path":
          setCookie2.path = val;
          break;
        case "max-age":
          if (val && maxAgeRegExp.test(val))
            setCookie2.maxAge = Number(val);
          break;
        case "expires":
          if (!val)
            break;
          const date2 = new Date(val);
          if (Number.isFinite(date2.valueOf()))
            setCookie2.expires = date2;
          break;
        case "priority":
          if (!val)
            break;
          const priority = val.toLowerCase();
          if (priority === "low" || priority === "medium" || priority === "high") {
            setCookie2.priority = priority;
          }
          break;
        case "samesite":
          if (!val)
            break;
          const sameSite = val.toLowerCase();
          if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
            setCookie2.sameSite = sameSite;
          }
          break;
      }
      index = endIdx2 + 1;
    }
    return setCookie2;
  }
  function endIndex(str, min, len) {
    const index = str.indexOf(";", min);
    return index === -1 ? len : index;
  }
  function eqIndex(str, min, max) {
    const index = str.indexOf("=", min);
    return index < max ? index : -1;
  }
  function valueSlice(str, min, max) {
    let start = min;
    let end = max;
    do {
      const code2 = str.charCodeAt(start);
      if (code2 !== 32 && code2 !== 9)
        break;
    } while (++start < end);
    while (end > start) {
      const code2 = str.charCodeAt(end - 1);
      if (code2 !== 32 && code2 !== 9)
        break;
      end--;
    }
    return str.slice(start, end);
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]";
  }
  return dist;
}
var processWarning = { exports: {} };
var hasRequiredProcessWarning;
function requireProcessWarning() {
  if (hasRequiredProcessWarning) return processWarning.exports;
  hasRequiredProcessWarning = 1;
  const { format: format2 } = require$$0$1;
  function createDeprecation(params) {
    return createWarning({ ...params, name: "DeprecationWarning" });
  }
  function createWarning({ name, code: code2, message, unlimited = false } = {}) {
    if (!name) throw new Error("Warning name must not be empty");
    if (!code2) throw new Error("Warning code must not be empty");
    if (!message) throw new Error("Warning message must not be empty");
    if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
    code2 = code2.toUpperCase();
    let warningContainer = {
      [name]: function(a, b, c) {
        if (warning.emitted === true && warning.unlimited !== true) {
          return;
        }
        warning.emitted = true;
        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
      }
    };
    if (unlimited) {
      warningContainer = {
        [name]: function(a, b, c) {
          warning.emitted = true;
          process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
        }
      };
    }
    const warning = warningContainer[name];
    warning.emitted = false;
    warning.message = message;
    warning.unlimited = unlimited;
    warning.code = code2;
    warning.format = function(a, b, c) {
      let formatted;
      if (a && b && c) {
        formatted = format2(message, a, b, c);
      } else if (a && b) {
        formatted = format2(message, a, b);
      } else if (a) {
        formatted = format2(message, a);
      } else {
        formatted = message;
      }
      return formatted;
    };
    return warning;
  }
  const out = { createWarning, createDeprecation };
  processWarning.exports = out;
  processWarning.exports.default = out;
  processWarning.exports.processWarning = out;
  return processWarning.exports;
}
var parseUrl;
var hasRequiredParseUrl;
function requireParseUrl() {
  if (hasRequiredParseUrl) return parseUrl;
  hasRequiredParseUrl = 1;
  const { URL: URL2 } = require$$4$2;
  const BASE_URL = "http://localhost";
  parseUrl = function parseURL(url, query) {
    if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
      url = BASE_URL + url;
    }
    const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL), url) : new URL2(url, BASE_URL);
    if (typeof query === "string") {
      query = new URLSearchParams(query);
      for (const key of query.keys()) {
        result.searchParams.delete(key);
        for (const value of query.getAll(key)) {
          result.searchParams.append(key, value);
        }
      }
    } else {
      const merged = Object.assign({}, url.query, query);
      for (const key in merged) {
        const value = merged[key];
        if (Array.isArray(value)) {
          result.searchParams.delete(key);
          for (const param of value) {
            result.searchParams.append(key, param);
          }
        } else {
          result.searchParams.set(key, value);
        }
      }
    }
    return result;
  };
  return parseUrl;
}
var formData = {};
var hasRequiredFormData;
function requireFormData() {
  if (hasRequiredFormData) return formData;
  hasRequiredFormData = 1;
  const { randomUUID } = require$$0$9;
  const { Readable } = require$$0$6;
  let textEncoder;
  function isFormDataLike(payload) {
    return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
  }
  function formDataToStream(formdata) {
    textEncoder = textEncoder ?? new TextEncoder();
    const boundary = `----formdata-${randomUUID()}`;
    const prefix = `--${boundary}\r
Content-Disposition: form-data`;
    const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
    const linebreak = new Uint8Array([13, 10]);
    async function* asyncIterator() {
      for (const [name, value] of formdata) {
        if (typeof value === "string") {
          yield textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
          yield textEncoder.encode(`${normalizeLinefeeds(value)}\r
`);
        } else {
          let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
          value.name && (header += `; filename="${escape2(value.name)}"`);
          header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
          yield textEncoder.encode(header);
          if (value.stream) {
            yield* value.stream();
          } else {
            yield value;
          }
          yield linebreak;
        }
      }
      yield textEncoder.encode(`--${boundary}--`);
    }
    const stream = Readable.from(asyncIterator());
    return {
      stream,
      contentType: `multipart/form-data; boundary=${boundary}`
    };
  }
  formData.isFormDataLike = isFormDataLike;
  formData.formDataToStream = formDataToStream;
  return formData;
}
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request.exports;
  hasRequiredRequest = 1;
  const { Readable, addAbortSignal } = require$$0$6;
  const util2 = require$$0$1;
  const cookie = /* @__PURE__ */ requireDist();
  const assert = require$$0$8;
  const { createDeprecation } = requireProcessWarning();
  const parseURL = requireParseUrl();
  const { isFormDataLike, formDataToStream } = requireFormData();
  const { EventEmitter } = require$$0$2;
  const FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
  function hostHeaderFromURL(parsedURL) {
    return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
  }
  class MockSocket extends EventEmitter {
    constructor(remoteAddress) {
      super();
      this.remoteAddress = remoteAddress;
    }
  }
  function CustomRequest(options) {
    return new _CustomLMRRequest(this);
    function _CustomLMRRequest(obj) {
      Request.call(obj, {
        ...options,
        Request: void 0
      });
      Object.assign(this, obj);
      for (const fn of Object.keys(Request.prototype)) {
        this.constructor.prototype[fn] = Request.prototype[fn];
      }
      util2.inherits(this.constructor, options.Request);
      return this;
    }
  }
  function Request(options) {
    Readable.call(this, {
      autoDestroy: false
    });
    const parsedURL = parseURL(options.url || options.path, options.query);
    this.url = parsedURL.pathname + parsedURL.search;
    this.aborted = false;
    this.httpVersionMajor = 1;
    this.httpVersionMinor = 1;
    this.httpVersion = "1.1";
    this.method = options.method ? options.method.toUpperCase() : "GET";
    this.headers = {};
    this.rawHeaders = [];
    const headers = options.headers || {};
    for (const field in headers) {
      const fieldLowerCase = field.toLowerCase();
      if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === void 0) {
        this.headers[fieldLowerCase] = void 0;
        continue;
      }
      const value = headers[field];
      assert(value !== void 0, 'invalid value "undefined" for header ' + field);
      this.headers[fieldLowerCase] = "" + value;
    }
    if ("user-agent" in this.headers === false) {
      this.headers["user-agent"] = "lightMyRequest";
    }
    this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
    if (options.cookies) {
      const { cookies } = options;
      const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
      if (this.headers.cookie) {
        cookieValues.unshift(this.headers.cookie);
      }
      this.headers.cookie = cookieValues.join("; ");
    }
    this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
    Object.defineProperty(this, "connection", {
      get() {
        FST_LIGHTMYREQUEST_DEP01();
        return this.socket;
      },
      configurable: true
    });
    let payload = options.payload || options.body || null;
    let payloadResume = payload && typeof payload.resume === "function";
    if (isFormDataLike(payload)) {
      const stream = formDataToStream(payload);
      payload = stream.stream;
      payloadResume = true;
      this.headers["content-type"] = stream.contentType;
      this.headers["transfer-encoding"] = "chunked";
    }
    if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
      payload = JSON.stringify(payload);
      if ("content-type" in this.headers === false) {
        this.headers["content-type"] = "application/json";
      }
    }
    if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
      this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
    }
    for (const header of Object.keys(this.headers)) {
      this.rawHeaders.push(header, this.headers[header]);
    }
    this._lightMyRequest = {
      payload,
      isDone: false,
      simulate: options.simulate || {},
      payloadAsStream: options.payloadAsStream,
      signal: options.signal
    };
    const signal = options.signal;
    if (signal) {
      addAbortSignal(signal, this);
    }
    {
      const payload2 = this._lightMyRequest.payload;
      if (payload2?._readableState) {
        this._read = readStream;
        payload2.on("error", (err2) => {
          this.destroy(err2);
        });
        payload2.on("end", () => {
          this.push(null);
        });
      } else {
        this._read = readEverythingElse;
      }
    }
    return this;
  }
  function readStream() {
    const payload = this._lightMyRequest.payload;
    let more = true;
    let pushed = false;
    let chunk;
    while (more && (chunk = payload.read())) {
      pushed = true;
      more = this.push(chunk);
    }
    if (more && !pushed) {
      this._lightMyRequest.payload.once("readable", this._read.bind(this));
    }
  }
  function readEverythingElse() {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
        return;
      }
      this._lightMyRequest.isDone = true;
      if (this._lightMyRequest.payload) {
        if (this._lightMyRequest.simulate.split) {
          this.push(this._lightMyRequest.payload.slice(0, 1));
          this.push(this._lightMyRequest.payload.slice(1));
        } else {
          this.push(this._lightMyRequest.payload);
        }
      }
      if (this._lightMyRequest.simulate.error) {
        this.emit("error", new Error("Simulated"));
      }
      if (this._lightMyRequest.simulate.close) {
        this.emit("close");
      }
      if (this._lightMyRequest.simulate.end !== false) {
        this.push(null);
      }
    });
  }
  util2.inherits(Request, Readable);
  util2.inherits(CustomRequest, Request);
  Request.prototype.destroy = function(error2) {
    if (this.destroyed || this._lightMyRequest.isDone) return;
    this.destroyed = true;
    if (error2) {
      this._error = true;
      process.nextTick(() => this.emit("error", error2));
    }
    process.nextTick(() => this.emit("close"));
  };
  request.exports = Request;
  request.exports.Request = Request;
  request.exports.CustomRequest = CustomRequest;
  return request.exports;
}
var setCookie = { exports: {} };
var hasRequiredSetCookie;
function requireSetCookie() {
  if (hasRequiredSetCookie) return setCookie.exports;
  hasRequiredSetCookie = 1;
  var defaultParseOptions = {
    decodeValues: true,
    map: false,
    silent: false
  };
  function isForbiddenKey(key) {
    return typeof key !== "string" || key in {};
  }
  function createNullObj() {
    return /* @__PURE__ */ Object.create(null);
  }
  function isNonEmptyString(str) {
    return typeof str === "string" && !!str.trim();
  }
  function parseString(setCookieValue, options) {
    var parts = setCookieValue.split(";").filter(isNonEmptyString);
    var nameValuePairStr = parts.shift();
    var parsed = parseNameValuePair(nameValuePairStr);
    var name = parsed.name;
    var value = parsed.value;
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (isForbiddenKey(name)) {
      return null;
    }
    try {
      value = options.decodeValues ? decodeURIComponent(value) : value;
    } catch (e) {
      console.error(
        "set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.",
        e
      );
    }
    var cookie = createNullObj();
    cookie.name = name;
    cookie.value = value;
    parts.forEach(function(part) {
      var sides = part.split("=");
      var key = sides.shift().trimLeft().toLowerCase();
      if (isForbiddenKey(key)) {
        return;
      }
      var value2 = sides.join("=");
      if (key === "expires") {
        cookie.expires = new Date(value2);
      } else if (key === "max-age") {
        var n = parseInt(value2, 10);
        if (!Number.isNaN(n)) cookie.maxAge = n;
      } else if (key === "secure") {
        cookie.secure = true;
      } else if (key === "httponly") {
        cookie.httpOnly = true;
      } else if (key === "samesite") {
        cookie.sameSite = value2;
      } else if (key === "partitioned") {
        cookie.partitioned = true;
      } else if (key) {
        cookie[key] = value2;
      }
    });
    return cookie;
  }
  function parseNameValuePair(nameValuePairStr) {
    var name = "";
    var value = "";
    var nameValueArr = nameValuePairStr.split("=");
    if (nameValueArr.length > 1) {
      name = nameValueArr.shift();
      value = nameValueArr.join("=");
    } else {
      value = nameValuePairStr;
    }
    return { name, value };
  }
  function parse2(input, options) {
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (!input) {
      if (!options.map) {
        return [];
      } else {
        return createNullObj();
      }
    }
    if (input.headers) {
      if (typeof input.headers.getSetCookie === "function") {
        input = input.headers.getSetCookie();
      } else if (input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          );
        }
        input = sch;
      }
    }
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!options.map) {
      return input.filter(isNonEmptyString).map(function(str) {
        return parseString(str, options);
      }).filter(Boolean);
    } else {
      var cookies = createNullObj();
      return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
        var cookie = parseString(str, options);
        if (cookie && !isForbiddenKey(cookie.name)) {
          cookies2[cookie.name] = cookie;
        }
        return cookies2;
      }, cookies);
    }
  }
  function splitCookiesString(cookiesString) {
    if (Array.isArray(cookiesString)) {
      return cookiesString;
    }
    if (typeof cookiesString !== "string") {
      return [];
    }
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
      while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
        pos += 1;
      }
      return pos < cookiesString.length;
    }
    function notSpecialChar() {
      ch = cookiesString.charAt(pos);
      return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while (pos < cookiesString.length) {
      start = pos;
      cookiesSeparatorFound = false;
      while (skipWhitespace()) {
        ch = cookiesString.charAt(pos);
        if (ch === ",") {
          lastComma = pos;
          pos += 1;
          skipWhitespace();
          nextStart = pos;
          while (pos < cookiesString.length && notSpecialChar()) {
            pos += 1;
          }
          if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
            cookiesSeparatorFound = true;
            pos = nextStart;
            cookiesStrings.push(cookiesString.substring(start, lastComma));
            start = pos;
          } else {
            pos = lastComma + 1;
          }
        } else {
          pos += 1;
        }
      }
      if (!cookiesSeparatorFound || pos >= cookiesString.length) {
        cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
    }
    return cookiesStrings;
  }
  setCookie.exports = parse2;
  setCookie.exports.parse = parse2;
  setCookie.exports.parseString = parseString;
  setCookie.exports.splitCookiesString = splitCookiesString;
  return setCookie.exports;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  const http = require$$0$3;
  const { Writable, Readable, addAbortSignal } = require$$0$6;
  const util2 = require$$0$1;
  const setCookie2 = /* @__PURE__ */ requireSetCookie();
  function Response(req2, onEnd, reject) {
    http.ServerResponse.call(this, req2);
    if (req2._lightMyRequest?.payloadAsStream) {
      const read = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
      const signal = req2._lightMyRequest.signal;
      if (signal) {
        addAbortSignal(signal, this._lightMyRequest.stream);
      }
    } else {
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    }
    this.setHeader("foo", "bar");
    this.removeHeader("foo");
    this.assignSocket(getNullSocket());
    this._promiseCallback = typeof reject === "function";
    let called = false;
    const onEndSuccess = (payload) => {
      if (called) return;
      called = true;
      if (this._promiseCallback) {
        return process.nextTick(() => onEnd(payload));
      }
      process.nextTick(() => onEnd(null, payload));
    };
    this._lightMyRequest.onEndSuccess = onEndSuccess;
    let finished = false;
    const onEndFailure = (err2) => {
      if (called) {
        if (this._lightMyRequest.stream && !finished) {
          if (!err2) {
            err2 = new Error("response destroyed before completion");
            err2.code = "LIGHT_ECONNRESET";
          }
          this._lightMyRequest.stream.destroy(err2);
          this._lightMyRequest.stream.on("error", () => {
          });
        }
        return;
      }
      called = true;
      if (!err2) {
        err2 = new Error("response destroyed before completion");
        err2.code = "LIGHT_ECONNRESET";
      }
      if (this._promiseCallback) {
        return process.nextTick(() => reject(err2));
      }
      process.nextTick(() => onEnd(err2, null));
    };
    if (this._lightMyRequest.stream) {
      this.once("finish", () => {
        finished = true;
        this._lightMyRequest.stream.push(null);
      });
    } else {
      this.once("finish", () => {
        const res2 = generatePayload(this);
        res2.raw.req = req2;
        onEndSuccess(res2);
      });
    }
    this.connection.once("error", onEndFailure);
    this.once("error", onEndFailure);
    this.once("close", onEndFailure);
  }
  util2.inherits(Response, http.ServerResponse);
  Response.prototype.setTimeout = function(msecs, callback) {
    this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, msecs);
    this.on("timeout", callback);
    return this;
  };
  Response.prototype.writeHead = function() {
    const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);
    copyHeaders(this);
    if (this._lightMyRequest.stream) {
      this._lightMyRequest.onEndSuccess(generatePayload(this));
    }
    return result;
  };
  Response.prototype.write = function(data, encoding, callback) {
    if (this.timeoutHandle) {
      clearTimeout(this.timeoutHandle);
    }
    http.ServerResponse.prototype.write.call(this, data, encoding, callback);
    if (this._lightMyRequest.stream) {
      return this._lightMyRequest.stream.push(Buffer.from(data, encoding));
    } else {
      this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
      return true;
    }
  };
  Response.prototype.end = function(data, encoding, callback) {
    if (data) {
      this.write(data, encoding);
    }
    http.ServerResponse.prototype.end.call(this, callback);
    this.emit("finish");
    this.destroy();
  };
  Response.prototype.destroy = function(error2) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (error2) {
      process.nextTick(() => this.emit("error", error2));
    }
    process.nextTick(() => this.emit("close"));
  };
  Response.prototype.addTrailers = function(trailers) {
    for (const key in trailers) {
      this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
    }
  };
  function generatePayload(response2) {
    if (response2._lightMyRequest.headers === null) {
      copyHeaders(response2);
    }
    serializeHeaders(response2);
    const res2 = {
      raw: {
        res: response2
      },
      headers: response2._lightMyRequest.headers,
      statusCode: response2.statusCode,
      statusMessage: response2.statusMessage,
      trailers: {},
      get cookies() {
        return setCookie2.parse(this);
      }
    };
    res2.trailers = response2._lightMyRequest.trailers;
    if (response2._lightMyRequest.payloadChunks) {
      const rawBuffer = Buffer.concat(response2._lightMyRequest.payloadChunks);
      res2.rawPayload = rawBuffer;
      res2.payload = rawBuffer.toString();
      res2.body = res2.payload;
      res2.json = function parseJsonPayload() {
        return JSON.parse(res2.payload);
      };
    } else {
      res2.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    }
    res2.stream = function streamPayload() {
      if (response2._lightMyRequest.stream) {
        return response2._lightMyRequest.stream;
      }
      return Readable.from(response2._lightMyRequest.payloadChunks);
    };
    return res2;
  }
  function getNullSocket() {
    return new Writable({
      write(_chunk, _encoding, callback) {
        setImmediate(callback);
      }
    });
  }
  function serializeHeaders(response2) {
    const headers = response2._lightMyRequest.headers;
    for (const headerName of Object.keys(headers)) {
      const headerValue = headers[headerName];
      if (Array.isArray(headerValue)) {
        headers[headerName] = headerValue.map((value) => "" + value);
      } else {
        headers[headerName] = "" + headerValue;
      }
    }
  }
  function copyHeaders(response2) {
    response2._lightMyRequest.headers = Object.assign({}, response2.getHeaders());
    ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
      const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
      const field = response2._header?.match(regex);
      if (field) {
        response2._lightMyRequest.headers[name.toLowerCase()] = field[1];
      }
    });
  }
  response = Response;
  return response;
}
var configValidator = { exports: {} };
var hasRequiredConfigValidator;
function requireConfigValidator() {
  if (hasRequiredConfigValidator) return configValidator.exports;
  hasRequiredConfigValidator = 1;
  configValidator.exports = validate10;
  configValidator.exports.default = validate10;
  const schema11 = { "properties": { "method": { "enum": ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    const _errs1 = errors2;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors2;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.url === void 0 && (missing0 = "url")) {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
    }
    var _valid0 = _errs2 === errors2;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs3 = errors2;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing1;
      if (data.path === void 0 && (missing1 = "path")) {
        const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
    }
    var _valid0 = _errs3 === errors2;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors2++;
      validate10.errors = vErrors;
      return false;
    } else {
      errors2 = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    if (errors2 === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.url !== void 0) {
          let data0 = data.url;
          const _errs5 = errors2;
          const _errs6 = errors2;
          let valid2 = false;
          let passing1 = null;
          const _errs7 = errors2;
          if (typeof data0 !== "string") {
            let dataType0 = typeof data0;
            let coerced0 = void 0;
            if (!(coerced0 !== void 0)) {
              if (dataType0 == "number" || dataType0 == "boolean") {
                coerced0 = "" + data0;
              } else if (data0 === null) {
                coerced0 = "";
              } else {
                const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
              }
            }
            if (coerced0 !== void 0) {
              data0 = coerced0;
              if (data !== void 0) {
                data["url"] = coerced0;
              }
            }
          }
          var _valid1 = _errs7 === errors2;
          if (_valid1) {
            valid2 = true;
            passing1 = 0;
          }
          const _errs9 = errors2;
          if (errors2 === _errs9) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              let missing2;
              if (data0.pathname === void 0 && (missing2 = "pathname")) {
                const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              } else {
                if (data0.protocol !== void 0) {
                  let data1 = data0.protocol;
                  const _errs12 = errors2;
                  if (typeof data1 !== "string") {
                    let dataType1 = typeof data1;
                    let coerced1 = void 0;
                    if (!(coerced1 !== void 0)) {
                      if (dataType1 == "number" || dataType1 == "boolean") {
                        coerced1 = "" + data1;
                      } else if (data1 === null) {
                        coerced1 = "";
                      } else {
                        const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors2++;
                      }
                    }
                    if (coerced1 !== void 0) {
                      data1 = coerced1;
                      if (data0 !== void 0) {
                        data0["protocol"] = coerced1;
                      }
                    }
                  }
                  var valid3 = _errs12 === errors2;
                } else {
                  var valid3 = true;
                }
                if (valid3) {
                  if (data0.hostname !== void 0) {
                    let data2 = data0.hostname;
                    const _errs14 = errors2;
                    if (typeof data2 !== "string") {
                      let dataType2 = typeof data2;
                      let coerced2 = void 0;
                      if (!(coerced2 !== void 0)) {
                        if (dataType2 == "number" || dataType2 == "boolean") {
                          coerced2 = "" + data2;
                        } else if (data2 === null) {
                          coerced2 = "";
                        } else {
                          const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors2++;
                        }
                      }
                      if (coerced2 !== void 0) {
                        data2 = coerced2;
                        if (data0 !== void 0) {
                          data0["hostname"] = coerced2;
                        }
                      }
                    }
                    var valid3 = _errs14 === errors2;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.pathname !== void 0) {
                      let data3 = data0.pathname;
                      const _errs16 = errors2;
                      if (typeof data3 !== "string") {
                        let dataType3 = typeof data3;
                        let coerced3 = void 0;
                        if (!(coerced3 !== void 0)) {
                          if (dataType3 == "number" || dataType3 == "boolean") {
                            coerced3 = "" + data3;
                          } else if (data3 === null) {
                            coerced3 = "";
                          } else {
                            const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err7];
                            } else {
                              vErrors.push(err7);
                            }
                            errors2++;
                          }
                        }
                        if (coerced3 !== void 0) {
                          data3 = coerced3;
                          if (data0 !== void 0) {
                            data0["pathname"] = coerced3;
                          }
                        }
                      }
                      var valid3 = _errs16 === errors2;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              }
            } else {
              const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors2++;
            }
          }
          var _valid1 = _errs9 === errors2;
          if (_valid1 && valid2) {
            valid2 = false;
            passing1 = [passing1, 1];
          } else {
            if (_valid1) {
              valid2 = true;
              passing1 = 1;
            }
          }
          if (!valid2) {
            const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
            validate10.errors = vErrors;
            return false;
          } else {
            errors2 = _errs6;
            if (vErrors !== null) {
              if (_errs6) {
                vErrors.length = _errs6;
              } else {
                vErrors = null;
              }
            }
          }
          var valid1 = _errs5 === errors2;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.path !== void 0) {
            let data4 = data.path;
            const _errs18 = errors2;
            const _errs19 = errors2;
            let valid4 = false;
            let passing2 = null;
            const _errs20 = errors2;
            if (typeof data4 !== "string") {
              let dataType4 = typeof data4;
              let coerced4 = void 0;
              if (!(coerced4 !== void 0)) {
                if (dataType4 == "number" || dataType4 == "boolean") {
                  coerced4 = "" + data4;
                } else if (data4 === null) {
                  coerced4 = "";
                } else {
                  const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors2++;
                }
              }
              if (coerced4 !== void 0) {
                data4 = coerced4;
                if (data !== void 0) {
                  data["path"] = coerced4;
                }
              }
            }
            var _valid2 = _errs20 === errors2;
            if (_valid2) {
              valid4 = true;
              passing2 = 0;
            }
            const _errs22 = errors2;
            if (errors2 === _errs22) {
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                let missing3;
                if (data4.pathname === void 0 && (missing3 = "pathname")) {
                  const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors2++;
                } else {
                  if (data4.protocol !== void 0) {
                    let data5 = data4.protocol;
                    const _errs25 = errors2;
                    if (typeof data5 !== "string") {
                      let dataType5 = typeof data5;
                      let coerced5 = void 0;
                      if (!(coerced5 !== void 0)) {
                        if (dataType5 == "number" || dataType5 == "boolean") {
                          coerced5 = "" + data5;
                        } else if (data5 === null) {
                          coerced5 = "";
                        } else {
                          const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err12];
                          } else {
                            vErrors.push(err12);
                          }
                          errors2++;
                        }
                      }
                      if (coerced5 !== void 0) {
                        data5 = coerced5;
                        if (data4 !== void 0) {
                          data4["protocol"] = coerced5;
                        }
                      }
                    }
                    var valid5 = _errs25 === errors2;
                  } else {
                    var valid5 = true;
                  }
                  if (valid5) {
                    if (data4.hostname !== void 0) {
                      let data6 = data4.hostname;
                      const _errs27 = errors2;
                      if (typeof data6 !== "string") {
                        let dataType6 = typeof data6;
                        let coerced6 = void 0;
                        if (!(coerced6 !== void 0)) {
                          if (dataType6 == "number" || dataType6 == "boolean") {
                            coerced6 = "" + data6;
                          } else if (data6 === null) {
                            coerced6 = "";
                          } else {
                            const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err13];
                            } else {
                              vErrors.push(err13);
                            }
                            errors2++;
                          }
                        }
                        if (coerced6 !== void 0) {
                          data6 = coerced6;
                          if (data4 !== void 0) {
                            data4["hostname"] = coerced6;
                          }
                        }
                      }
                      var valid5 = _errs27 === errors2;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.pathname !== void 0) {
                        let data7 = data4.pathname;
                        const _errs29 = errors2;
                        if (typeof data7 !== "string") {
                          let dataType7 = typeof data7;
                          let coerced7 = void 0;
                          if (!(coerced7 !== void 0)) {
                            if (dataType7 == "number" || dataType7 == "boolean") {
                              coerced7 = "" + data7;
                            } else if (data7 === null) {
                              coerced7 = "";
                            } else {
                              const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err14];
                              } else {
                                vErrors.push(err14);
                              }
                              errors2++;
                            }
                          }
                          if (coerced7 !== void 0) {
                            data7 = coerced7;
                            if (data4 !== void 0) {
                              data4["pathname"] = coerced7;
                            }
                          }
                        }
                        var valid5 = _errs29 === errors2;
                      } else {
                        var valid5 = true;
                      }
                    }
                  }
                }
              } else {
                const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors2++;
              }
            }
            var _valid2 = _errs22 === errors2;
            if (_valid2 && valid4) {
              valid4 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid4 = true;
                passing2 = 1;
              }
            }
            if (!valid4) {
              const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors2++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors2 = _errs19;
              if (vErrors !== null) {
                if (_errs19) {
                  vErrors.length = _errs19;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs18 === errors2;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.cookies !== void 0) {
              let data8 = data.cookies;
              const _errs31 = errors2;
              if (errors2 === _errs31) {
                if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                  validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid1 = _errs31 === errors2;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.headers !== void 0) {
                let data9 = data.headers;
                const _errs34 = errors2;
                if (errors2 === _errs34) {
                  if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                    validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs34 === errors2;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data.query !== void 0) {
                  let data10 = data.query;
                  const _errs37 = errors2;
                  const _errs38 = errors2;
                  let valid6 = false;
                  const _errs39 = errors2;
                  if (errors2 === _errs39) {
                    if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                      const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors2++;
                    }
                  }
                  var _valid3 = _errs39 === errors2;
                  valid6 = valid6 || _valid3;
                  if (!valid6) {
                    const _errs42 = errors2;
                    if (typeof data10 !== "string") {
                      let dataType8 = typeof data10;
                      let coerced8 = void 0;
                      if (!(coerced8 !== void 0)) {
                        if (dataType8 == "number" || dataType8 == "boolean") {
                          coerced8 = "" + data10;
                        } else if (data10 === null) {
                          coerced8 = "";
                        } else {
                          const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err18];
                          } else {
                            vErrors.push(err18);
                          }
                          errors2++;
                        }
                      }
                      if (coerced8 !== void 0) {
                        data10 = coerced8;
                        if (data !== void 0) {
                          data["query"] = coerced8;
                        }
                      }
                    }
                    var _valid3 = _errs42 === errors2;
                    valid6 = valid6 || _valid3;
                  }
                  if (!valid6) {
                    const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    if (vErrors === null) {
                      vErrors = [err19];
                    } else {
                      vErrors.push(err19);
                    }
                    errors2++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors2 = _errs38;
                    if (vErrors !== null) {
                      if (_errs38) {
                        vErrors.length = _errs38;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid1 = _errs37 === errors2;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data.simulate !== void 0) {
                    let data11 = data.simulate;
                    const _errs44 = errors2;
                    if (errors2 === _errs44) {
                      if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                        if (data11.end !== void 0) {
                          let data12 = data11.end;
                          const _errs46 = errors2;
                          if (typeof data12 !== "boolean") {
                            let coerced9 = void 0;
                            if (!(coerced9 !== void 0)) {
                              if (data12 === "false" || data12 === 0 || data12 === null) {
                                coerced9 = false;
                              } else if (data12 === "true" || data12 === 1) {
                                coerced9 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced9 !== void 0) {
                              data12 = coerced9;
                              if (data11 !== void 0) {
                                data11["end"] = coerced9;
                              }
                            }
                          }
                          var valid7 = _errs46 === errors2;
                        } else {
                          var valid7 = true;
                        }
                        if (valid7) {
                          if (data11.split !== void 0) {
                            let data13 = data11.split;
                            const _errs48 = errors2;
                            if (typeof data13 !== "boolean") {
                              let coerced10 = void 0;
                              if (!(coerced10 !== void 0)) {
                                if (data13 === "false" || data13 === 0 || data13 === null) {
                                  coerced10 = false;
                                } else if (data13 === "true" || data13 === 1) {
                                  coerced10 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced10 !== void 0) {
                                data13 = coerced10;
                                if (data11 !== void 0) {
                                  data11["split"] = coerced10;
                                }
                              }
                            }
                            var valid7 = _errs48 === errors2;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.error !== void 0) {
                              let data14 = data11.error;
                              const _errs50 = errors2;
                              if (typeof data14 !== "boolean") {
                                let coerced11 = void 0;
                                if (!(coerced11 !== void 0)) {
                                  if (data14 === "false" || data14 === 0 || data14 === null) {
                                    coerced11 = false;
                                  } else if (data14 === "true" || data14 === 1) {
                                    coerced11 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced11 !== void 0) {
                                  data14 = coerced11;
                                  if (data11 !== void 0) {
                                    data11["error"] = coerced11;
                                  }
                                }
                              }
                              var valid7 = _errs50 === errors2;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.close !== void 0) {
                                let data15 = data11.close;
                                const _errs52 = errors2;
                                if (typeof data15 !== "boolean") {
                                  let coerced12 = void 0;
                                  if (!(coerced12 !== void 0)) {
                                    if (data15 === "false" || data15 === 0 || data15 === null) {
                                      coerced12 = false;
                                    } else if (data15 === "true" || data15 === 1) {
                                      coerced12 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced12 !== void 0) {
                                    data15 = coerced12;
                                    if (data11 !== void 0) {
                                      data11["close"] = coerced12;
                                    }
                                  }
                                }
                                var valid7 = _errs52 === errors2;
                              } else {
                                var valid7 = true;
                              }
                            }
                          }
                        }
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs44 === errors2;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data.authority !== void 0) {
                      let data16 = data.authority;
                      const _errs54 = errors2;
                      if (typeof data16 !== "string") {
                        let dataType13 = typeof data16;
                        let coerced13 = void 0;
                        if (!(coerced13 !== void 0)) {
                          if (dataType13 == "number" || dataType13 == "boolean") {
                            coerced13 = "" + data16;
                          } else if (data16 === null) {
                            coerced13 = "";
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                        }
                        if (coerced13 !== void 0) {
                          data16 = coerced13;
                          if (data !== void 0) {
                            data["authority"] = coerced13;
                          }
                        }
                      }
                      var valid1 = _errs54 === errors2;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data.remoteAddress !== void 0) {
                        let data17 = data.remoteAddress;
                        const _errs56 = errors2;
                        if (typeof data17 !== "string") {
                          let dataType14 = typeof data17;
                          let coerced14 = void 0;
                          if (!(coerced14 !== void 0)) {
                            if (dataType14 == "number" || dataType14 == "boolean") {
                              coerced14 = "" + data17;
                            } else if (data17 === null) {
                              coerced14 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced14 !== void 0) {
                            data17 = coerced14;
                            if (data !== void 0) {
                              data["remoteAddress"] = coerced14;
                            }
                          }
                        }
                        var valid1 = _errs56 === errors2;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data.method !== void 0) {
                          let data18 = data.method;
                          const _errs58 = errors2;
                          if (typeof data18 !== "string") {
                            let dataType15 = typeof data18;
                            let coerced15 = void 0;
                            if (!(coerced15 !== void 0)) {
                              if (dataType15 == "number" || dataType15 == "boolean") {
                                coerced15 = "" + data18;
                              } else if (data18 === null) {
                                coerced15 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced15 !== void 0) {
                              data18 = coerced15;
                              if (data !== void 0) {
                                data["method"] = coerced15;
                              }
                            }
                          }
                          if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                            validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs58 === errors2;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data.validate !== void 0) {
                            let data19 = data.validate;
                            const _errs60 = errors2;
                            if (typeof data19 !== "boolean") {
                              let coerced16 = void 0;
                              if (!(coerced16 !== void 0)) {
                                if (data19 === "false" || data19 === 0 || data19 === null) {
                                  coerced16 = false;
                                } else if (data19 === "true" || data19 === 1) {
                                  coerced16 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced16 !== void 0) {
                                data19 = coerced16;
                                if (data !== void 0) {
                                  data["validate"] = coerced16;
                                }
                              }
                            }
                            var valid1 = _errs60 === errors2;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors2 === 0;
  }
  return configValidator.exports;
}
var hasRequiredLightMyRequest;
function requireLightMyRequest() {
  if (hasRequiredLightMyRequest) return lightMyRequest.exports;
  hasRequiredLightMyRequest = 1;
  const assert = require$$0$8;
  const Request = requireRequest();
  const Response = requireResponse();
  const errorMessage = "The dispatch function has already been invoked";
  const optsValidator = requireConfigValidator();
  function inject(dispatchFunc, options, callback) {
    if (callback === void 0) {
      return new Chain(dispatchFunc, options);
    } else {
      return doInject(dispatchFunc, options, callback);
    }
  }
  function supportStream1(req2, next) {
    const payload = req2._lightMyRequest.payload;
    if (!payload || payload._readableState || typeof payload.resume !== "function") {
      return next();
    }
    const chunks = [];
    payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    payload.on("end", () => {
      const payload2 = Buffer.concat(chunks);
      req2.headers["content-length"] = req2.headers["content-length"] || "" + payload2.length;
      delete req2.headers["transfer-encoding"];
      req2._lightMyRequest.payload = payload2;
      return next();
    });
    payload.resume();
  }
  function makeRequest(dispatchFunc, server2, req2, res2) {
    req2.once("error", function(err2) {
      if (this.destroyed) res2.destroy(err2);
    });
    req2.once("close", function() {
      if (this.destroyed && !this._error) {
        res2.destroy();
      }
    });
    return supportStream1(req2, () => dispatchFunc.call(server2, req2, res2));
  }
  function doInject(dispatchFunc, options, callback) {
    options = typeof options === "string" ? { url: options } : options;
    if (options.validate !== false) {
      assert(typeof dispatchFunc === "function", "dispatchFunc should be a function");
      const isOptionValid = optsValidator(options);
      if (!isOptionValid) {
        throw new Error(optsValidator.errors.map((e) => e.message));
      }
    }
    const server2 = options.server || {};
    const RequestConstructor = options.Request ? Request.CustomRequest : Request;
    if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response.prototype);
    }
    if (typeof callback === "function") {
      const req2 = new RequestConstructor(options);
      const res2 = new Response(req2, callback);
      return makeRequest(dispatchFunc, server2, req2, res2);
    } else {
      return new Promise((resolve2, reject) => {
        const req2 = new RequestConstructor(options);
        const res2 = new Response(req2, resolve2, reject);
        makeRequest(dispatchFunc, server2, req2, res2);
      });
    }
  }
  function Chain(dispatch, option) {
    if (typeof option === "string") {
      this.option = { url: option };
    } else {
      this.option = Object.assign({}, option);
    }
    this.dispatch = dispatch;
    this._hasInvoked = false;
    this._promise = null;
    if (this.option.autoStart !== false) {
      process.nextTick(() => {
        if (!this._hasInvoked) {
          this.end();
        }
      });
    }
  }
  const httpMethods = [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ];
  httpMethods.forEach((method) => {
    Chain.prototype[method] = function(url) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option.url = url;
      this.option.method = method.toUpperCase();
      return this;
    };
  });
  const chainMethods = [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ];
  chainMethods.forEach((method) => {
    Chain.prototype[method] = function(value) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option[method] = value;
      return this;
    };
  });
  Chain.prototype.end = function(callback) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }
    this._hasInvoked = true;
    if (typeof callback === "function") {
      doInject(this.dispatch, this.option, callback);
    } else {
      this._promise = doInject(this.dispatch, this.option);
      return this._promise;
    }
  };
  Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
    if (method === "constructor") return;
    Chain.prototype[method] = function(...args) {
      if (!this._promise) {
        if (this._hasInvoked === true) {
          throw new Error(errorMessage);
        }
        this._hasInvoked = true;
        this._promise = doInject(this.dispatch, this.option);
      }
      return this._promise[method](...args);
    };
  });
  function isInjection(obj) {
    return obj instanceof Request || obj instanceof Response || obj?.constructor?.name === "_CustomLMRRequest";
  }
  lightMyRequest.exports = inject;
  lightMyRequest.exports.default = inject;
  lightMyRequest.exports.inject = inject;
  lightMyRequest.exports.isInjection = isInjection;
  return lightMyRequest.exports;
}
var hasRequiredFastify;
function requireFastify() {
  if (hasRequiredFastify) return fastify$1.exports;
  hasRequiredFastify = 1;
  const VERSION = "5.7.4";
  const Avvio = requireBoot();
  const http = require$$0$3;
  const diagnostics = require$$0$4;
  let lightMyRequest2;
  const {
    kAvvioBoot,
    kChildren,
    kServerBindings,
    kBodyLimit,
    kSupportedHTTPMethods,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kRequestAcceptVersion,
    kReplySerializerDefault,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kState,
    kOptions,
    kPluginNameChain,
    kSchemaErrorFormatter,
    kErrorHandler,
    kKeepAliveConnections,
    kChildLoggerFactory,
    kGenReqId,
    kErrorHandlerAlreadySet
  } = requireSymbols$1();
  const { createServer } = requireServer();
  const Reply = requireReply();
  const Request = requireRequest$1();
  const Context = requireContext();
  const decorator = requireDecorate();
  const ContentTypeParser = requireContentTypeParser();
  const SchemaController = requireSchemaController();
  const { Hooks, hookRunnerApplication, supportedHooks } = requireHooks();
  const { createChildLogger, defaultChildLoggerFactory, createLogger } = requireLoggerFactory();
  const pluginUtils2 = requirePluginUtils();
  const { getGenReqId, reqIdGenFactory } = requireReqIdGenFactory();
  const { buildRouting, validateBodyLimitOption, buildRouterOptions } = requireRoute();
  const build404 = requireFourOhFour();
  const getSecuredInitialConfig = requireInitialConfigValidation();
  const override = requirePluginOverride();
  const {
    appendStackTrace,
    AVVIO_ERRORS_MAP,
    ...errorCodes
  } = requireErrors$2();
  const PonyPromise = requirePromise();
  const { defaultInitOptions } = getSecuredInitialConfig;
  const {
    FST_ERR_ASYNC_CONSTRAINT,
    FST_ERR_BAD_URL,
    FST_ERR_OPTIONS_NOT_OBJ,
    FST_ERR_QSP_NOT_FN,
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
    FST_ERR_INSTANCE_ALREADY_LISTENING,
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_ROUTE_REWRITE_NOT_STR,
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
    FST_ERR_ERROR_HANDLER_NOT_FN,
    FST_ERR_ERROR_HANDLER_ALREADY_SET,
    FST_ERR_ROUTE_METHOD_INVALID
  } = errorCodes;
  const { buildErrorHandler } = requireErrorHandler();
  const { FSTWRN004 } = requireWarnings();
  const initChannel = diagnostics.channel("fastify.initialization");
  function fastify2(serverOptions) {
    const {
      options,
      genReqId,
      disableRequestLogging,
      hasLogger,
      initialConfig
    } = processOptions(serverOptions, defaultRoute, onBadUrl);
    const router = buildRouting(options.routerOptions);
    const fourOhFour = build404(options);
    const httpHandler = wrapRouting(router, options);
    const {
      server: server2,
      listen,
      forceCloseConnections,
      serverHasCloseAllConnections,
      serverHasCloseHttp2Sessions,
      keepAliveConnections
    } = createServer(options, httpHandler);
    const setupResponseListeners = Reply.setupResponseListeners;
    const schemaController2 = SchemaController.buildSchemaController(null, options.schemaController);
    const fastify3 = {
      // Fastify internals
      [kState]: {
        listening: false,
        closing: false,
        started: false,
        ready: false,
        booting: false,
        aborted: false,
        readyResolver: null
      },
      [kKeepAliveConnections]: keepAliveConnections,
      [kSupportedHTTPMethods]: {
        bodyless: /* @__PURE__ */ new Set([
          // Standard
          "GET",
          "HEAD",
          "TRACE"
        ]),
        bodywith: /* @__PURE__ */ new Set([
          // Standard
          "DELETE",
          "OPTIONS",
          "PATCH",
          "PUT",
          "POST"
        ])
      },
      [kOptions]: options,
      [kChildren]: [],
      [kServerBindings]: [],
      [kBodyLimit]: options.bodyLimit,
      [kRoutePrefix]: "",
      [kLogLevel]: "",
      [kLogSerializers]: null,
      [kHooks]: new Hooks(),
      [kSchemaController]: schemaController2,
      [kSchemaErrorFormatter]: null,
      [kErrorHandler]: buildErrorHandler(),
      [kErrorHandlerAlreadySet]: false,
      [kChildLoggerFactory]: options.childLoggerFactory || defaultChildLoggerFactory,
      [kReplySerializerDefault]: null,
      [kContentTypeParser]: new ContentTypeParser(
        options.bodyLimit,
        options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning,
        options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning
      ),
      [kReply]: Reply.buildReply(Reply),
      [kRequest]: Request.buildRequest(Request, options.trustProxy),
      [kFourOhFour]: fourOhFour,
      [pluginUtils2.kRegisteredPlugins]: [],
      [kPluginNameChain]: ["fastify"],
      [kAvvioBoot]: null,
      [kGenReqId]: genReqId,
      // routing method
      routing: httpHandler,
      // routes shorthand methods
      delete: function _delete(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "DELETE", url, options: options2, handler });
      },
      get: function _get(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "GET", url, options: options2, handler });
      },
      head: function _head(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "HEAD", url, options: options2, handler });
      },
      trace: function _trace(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "TRACE", url, options: options2, handler });
      },
      patch: function _patch(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PATCH", url, options: options2, handler });
      },
      post: function _post(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "POST", url, options: options2, handler });
      },
      put: function _put(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PUT", url, options: options2, handler });
      },
      options: function _options(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "OPTIONS", url, options: options2, handler });
      },
      all: function _all(url, options2, handler) {
        return router.prepareRoute.call(this, { method: this.supportedMethods, url, options: options2, handler });
      },
      // extended route
      route: function _route(options2) {
        return router.route.call(this, { options: options2 });
      },
      hasRoute: function _route(options2) {
        return router.hasRoute.call(this, { options: options2 });
      },
      findRoute: function _findRoute(options2) {
        return router.findRoute(options2);
      },
      // expose logger instance
      log: options.logger,
      // type provider
      withTypeProvider,
      // hooks
      addHook,
      // schemas
      addSchema,
      getSchema: schemaController2.getSchema.bind(schemaController2),
      getSchemas: schemaController2.getSchemas.bind(schemaController2),
      setValidatorCompiler,
      setSerializerCompiler,
      setSchemaController,
      setReplySerializer,
      setSchemaErrorFormatter,
      // set generated request id
      setGenReqId,
      // custom parsers
      addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
      hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
      getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
      defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
      removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
      removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
      // Fastify architecture methods (initialized by Avvio)
      register: null,
      after: null,
      ready: null,
      onClose: null,
      close: null,
      printPlugins: null,
      hasPlugin: function(name) {
        return this[pluginUtils2.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
      },
      // http server
      listen,
      server: server2,
      addresses: function() {
        const binded = this[kServerBindings].map((b) => b.address());
        binded.push(this.server.address());
        return binded.filter((adr) => adr);
      },
      // extend fastify objects
      decorate: decorator.add,
      hasDecorator: decorator.exist,
      decorateReply: decorator.decorateReply,
      decorateRequest: decorator.decorateRequest,
      hasRequestDecorator: decorator.existRequest,
      hasReplyDecorator: decorator.existReply,
      getDecorator: decorator.getInstanceDecorator,
      addHttpMethod,
      // fake http injection
      inject,
      // pretty print of the registered routes
      printRoutes,
      // custom error handling
      setNotFoundHandler,
      setErrorHandler,
      // child logger
      setChildLoggerFactory,
      // Set fastify initial configuration options read-only object
      initialConfig,
      // constraint strategies
      addConstraintStrategy: router.addConstraintStrategy.bind(router),
      hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
    };
    Object.defineProperties(fastify3, {
      listeningOrigin: {
        get() {
          const address = this.addresses().slice(-1).pop();
          if (typeof address === "string") {
            return address;
          }
          const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
          return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
        }
      },
      pluginName: {
        configurable: true,
        get() {
          if (this[kPluginNameChain].length > 1) {
            return this[kPluginNameChain].join(" -> ");
          }
          return this[kPluginNameChain][0];
        }
      },
      prefix: {
        configurable: true,
        get() {
          return this[kRoutePrefix];
        }
      },
      validatorCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getValidatorCompiler();
        }
      },
      serializerCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getSerializerCompiler();
        }
      },
      childLoggerFactory: {
        configurable: true,
        get() {
          return this[kChildLoggerFactory];
        }
      },
      version: {
        configurable: true,
        get() {
          return VERSION;
        }
      },
      errorHandler: {
        configurable: true,
        get() {
          return this[kErrorHandler].func;
        }
      },
      genReqId: {
        configurable: true,
        get() {
          return this[kGenReqId];
        }
      },
      supportedMethods: {
        configurable: false,
        get() {
          return [
            ...this[kSupportedHTTPMethods].bodyless,
            ...this[kSupportedHTTPMethods].bodywith
          ];
        }
      }
    });
    if (options.schemaErrorFormatter) {
      validateSchemaErrorFormatter(options.schemaErrorFormatter);
      fastify3[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify3);
    }
    const avvioPluginTimeout = Number(options.pluginTimeout);
    const avvio = Avvio(fastify3, {
      autostart: false,
      timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
      expose: {
        use: "register"
      }
    });
    avvio.override = override;
    avvio.on("start", () => fastify3[kState].started = true);
    fastify3[kAvvioBoot] = fastify3.ready;
    fastify3.ready = ready;
    fastify3.printPlugins = avvio.prettyPrint.bind(avvio);
    avvio.once("preReady", () => {
      fastify3.onClose((instance, done) => {
        fastify3[kState].closing = true;
        router.closeRoutes();
        hookRunnerApplication("preClose", fastify3[kAvvioBoot], fastify3, function() {
          if (fastify3[kState].listening) {
            if (forceCloseConnections === "idle") {
              instance.server.closeIdleConnections();
            } else if (serverHasCloseAllConnections && forceCloseConnections) {
              instance.server.closeAllConnections();
            } else if (forceCloseConnections === true) {
              for (const conn of fastify3[kKeepAliveConnections]) {
                conn.destroy();
                fastify3[kKeepAliveConnections].delete(conn);
              }
            }
          }
          if (serverHasCloseHttp2Sessions) {
            instance.server.closeHttp2Sessions();
          }
          if (!options.serverFactory || fastify3[kState].listening) {
            instance.server.close(function(err2) {
              if (err2 && err2.code !== "ERR_SERVER_NOT_RUNNING") {
                done(null);
              } else {
                done();
              }
            });
          } else {
            process.nextTick(done, null);
          }
        });
      });
    });
    const onBadUrlContext = new Context({
      server: fastify3,
      config: {}
    });
    fastify3.setNotFoundHandler();
    fourOhFour.arrange404(fastify3);
    router.setup(options, {
      avvio,
      fourOhFour,
      hasLogger,
      setupResponseListeners,
      throwIfAlreadyStarted,
      keepAliveConnections
    });
    server2.on("clientError", options.clientErrorHandler.bind(fastify3));
    if (initChannel.hasSubscribers) {
      initChannel.publish({ fastify: fastify3 });
    }
    if ("asyncDispose" in Symbol) {
      fastify3[Symbol.asyncDispose] = function dispose() {
        return fastify3.close();
      };
    }
    return fastify3;
    function throwIfAlreadyStarted(msg) {
      if (fastify3[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
    }
    function inject(opts, cb) {
      if (lightMyRequest2 === void 0) {
        lightMyRequest2 = requireLightMyRequest();
      }
      if (fastify3[kState].started) {
        if (fastify3[kState].closing) {
          const error2 = new FST_ERR_REOPENED_CLOSE_SERVER();
          if (cb) {
            cb(error2);
            return;
          } else {
            return Promise.reject(error2);
          }
        }
        return lightMyRequest2(httpHandler, opts, cb);
      }
      if (cb) {
        this.ready((err2) => {
          if (err2) cb(err2, null);
          else lightMyRequest2(httpHandler, opts, cb);
        });
      } else {
        return lightMyRequest2((req2, res2) => {
          this.ready(function(err2) {
            if (err2) {
              res2.emit("error", err2);
              return;
            }
            httpHandler(req2, res2);
          });
        }, opts);
      }
    }
    function ready(cb) {
      if (this[kState].readyResolver !== null) {
        if (cb != null) {
          this[kState].readyResolver.promise.then(() => cb(null, fastify3), cb);
          return;
        }
        return this[kState].readyResolver.promise;
      }
      process.nextTick(runHooks);
      this[kState].readyResolver = PonyPromise.withResolvers();
      if (!cb) {
        return this[kState].readyResolver.promise;
      } else {
        this[kState].readyResolver.promise.then(() => cb(null, fastify3), cb);
      }
      function runHooks() {
        fastify3[kAvvioBoot]((err2, done) => {
          if (err2 || fastify3[kState].started || fastify3[kState].ready || fastify3[kState].booting) {
            manageErr(err2);
          } else {
            fastify3[kState].booting = true;
            hookRunnerApplication("onReady", fastify3[kAvvioBoot], fastify3, manageErr);
          }
          done();
        });
      }
      function manageErr(err2) {
        err2 = err2 != null && AVVIO_ERRORS_MAP[err2.code] != null ? appendStackTrace(err2, new AVVIO_ERRORS_MAP[err2.code](err2.message)) : err2;
        if (err2) {
          return fastify3[kState].readyResolver.reject(err2);
        }
        fastify3[kState].readyResolver.resolve(fastify3);
        fastify3[kState].booting = false;
        fastify3[kState].ready = true;
        fastify3[kState].readyResolver = null;
      }
    }
    function withTypeProvider() {
      return this;
    }
    function addHook(name, fn) {
      throwIfAlreadyStarted('Cannot call "addHook"!');
      if (fn == null) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
      }
      if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
        }
      } else if (name === "onReady" || name === "onListen") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
        }
      } else if (name === "onRequestAbort") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
        }
      } else {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
        }
      }
      if (name === "onClose") {
        this.onClose(fn.bind(this));
      } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
        this[kHooks].add(name, fn);
      } else {
        this.after((err2, done) => {
          try {
            _addHook.call(this, name, fn);
            done(err2);
          } catch (err3) {
            done(err3);
          }
        });
      }
      return this;
      function _addHook(name2, fn2) {
        this[kHooks].add(name2, fn2);
        this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
      }
    }
    function addSchema(schema) {
      throwIfAlreadyStarted('Cannot call "addSchema"!');
      this[kSchemaController].add(schema);
      this[kChildren].forEach((child) => child.addSchema(schema));
      return this;
    }
    function defaultRoute(req2, res2) {
      if (req2.headers["accept-version"] !== void 0) {
        req2.headers[kRequestAcceptVersion] = req2.headers["accept-version"];
        req2.headers["accept-version"] = void 0;
      }
      fourOhFour.router.lookup(req2, res2);
    }
    function onBadUrl(path2, req2, res2) {
      if (options.frameworkErrors) {
        const id2 = getGenReqId(onBadUrlContext.server, req2);
        const childLogger = createChildLogger(onBadUrlContext, options.logger, req2, id2);
        const request2 = new Request(id2, null, req2, null, childLogger, onBadUrlContext);
        const reply2 = new Reply(res2, request2, childLogger);
        const resolvedDisableRequestLogging = typeof disableRequestLogging === "function" ? disableRequestLogging(req2) : disableRequestLogging;
        if (resolvedDisableRequestLogging === false) {
          childLogger.info({ req: request2 }, "incoming request");
        }
        return options.frameworkErrors(new FST_ERR_BAD_URL(path2), request2, reply2);
      }
      const body = JSON.stringify({
        error: "Bad Request",
        code: "FST_ERR_BAD_URL",
        message: `'${path2}' is not a valid url component`,
        statusCode: 400
      });
      res2.writeHead(400, {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(body)
      });
      res2.end(body);
    }
    function buildAsyncConstraintCallback(isAsync, req2, res2) {
      if (isAsync === false) return void 0;
      return function onAsyncConstraintError(err2) {
        if (err2) {
          if (options.frameworkErrors) {
            const id2 = getGenReqId(onBadUrlContext.server, req2);
            const childLogger = createChildLogger(onBadUrlContext, options.logger, req2, id2);
            const request2 = new Request(id2, null, req2, null, childLogger, onBadUrlContext);
            const reply2 = new Reply(res2, request2, childLogger);
            const resolvedDisableRequestLogging = typeof disableRequestLogging === "function" ? disableRequestLogging(req2) : disableRequestLogging;
            if (resolvedDisableRequestLogging === false) {
              childLogger.info({ req: request2 }, "incoming request");
            }
            return options.frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request2, reply2);
          }
          const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          res2.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": body.length
          });
          res2.end(body);
        }
      };
    }
    function setNotFoundHandler(opts, handler) {
      throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
      fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
      return this;
    }
    function setValidatorCompiler(validatorCompiler2) {
      throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
      this[kSchemaController].setValidatorCompiler(validatorCompiler2);
      return this;
    }
    function setSchemaErrorFormatter(errorFormatter) {
      throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
      validateSchemaErrorFormatter(errorFormatter);
      this[kSchemaErrorFormatter] = errorFormatter.bind(this);
      return this;
    }
    function setSerializerCompiler(serializerCompiler2) {
      throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
      this[kSchemaController].setSerializerCompiler(serializerCompiler2);
      return this;
    }
    function setSchemaController(schemaControllerOpts) {
      throwIfAlreadyStarted('Cannot call "setSchemaController"!');
      const old = this[kSchemaController];
      const schemaController3 = SchemaController.buildSchemaController(
        old,
        Object.assign({}, old.opts, schemaControllerOpts)
      );
      this[kSchemaController] = schemaController3;
      this.getSchema = schemaController3.getSchema.bind(schemaController3);
      this.getSchemas = schemaController3.getSchemas.bind(schemaController3);
      return this;
    }
    function setReplySerializer(replySerializer) {
      throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
      this[kReplySerializerDefault] = replySerializer;
      return this;
    }
    function setErrorHandler(func) {
      throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
      if (typeof func !== "function") {
        throw new FST_ERR_ERROR_HANDLER_NOT_FN();
      }
      if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
        throw new FST_ERR_ERROR_HANDLER_ALREADY_SET();
      } else if (this[kErrorHandlerAlreadySet]) {
        FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
      }
      this[kErrorHandlerAlreadySet] = true;
      this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
      return this;
    }
    function setChildLoggerFactory(factory) {
      throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
      this[kChildLoggerFactory] = factory;
      return this;
    }
    function printRoutes(opts = {}) {
      opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
      return router.printRoutes(opts);
    }
    function wrapRouting(router2, { rewriteUrl, logger }) {
      let isAsync;
      return function preRouting(req2, res2) {
        if (isAsync === void 0) isAsync = router2.isAsyncConstraint();
        if (rewriteUrl) {
          req2.originalUrl = req2.url;
          const url = rewriteUrl.call(fastify3, req2);
          if (typeof url === "string") {
            req2.url = url;
          } else {
            const err2 = new FST_ERR_ROUTE_REWRITE_NOT_STR(req2.url, typeof url);
            req2.destroy(err2);
          }
        }
        router2.routing(req2, res2, buildAsyncConstraintCallback(isAsync, req2, res2));
      };
    }
    function setGenReqId(func) {
      throwIfAlreadyStarted('Cannot call "setGenReqId"!');
      this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
      return this;
    }
    function addHttpMethod(method, { hasBody = false } = {}) {
      if (typeof method !== "string" || http.METHODS.indexOf(method) === -1) {
        throw new FST_ERR_ROUTE_METHOD_INVALID();
      }
      if (hasBody === true) {
        this[kSupportedHTTPMethods].bodywith.add(method);
        this[kSupportedHTTPMethods].bodyless.delete(method);
      } else {
        this[kSupportedHTTPMethods].bodywith.delete(method);
        this[kSupportedHTTPMethods].bodyless.add(method);
      }
      const _method = method.toLowerCase();
      if (!this.hasDecorator(_method)) {
        this.decorate(_method, function(url, options2, handler) {
          return router.prepareRoute.call(this, { method, url, options: options2, handler });
        });
      }
      return this;
    }
  }
  function processOptions(options, defaultRoute, onBadUrl) {
    if (options && typeof options !== "object") {
      throw new FST_ERR_OPTIONS_NOT_OBJ();
    } else {
      options = Object.assign({}, options);
    }
    if (options.querystringParser && typeof options.querystringParser !== "function" || options.routerOptions?.querystringParser && typeof options.routerOptions.querystringParser !== "function") {
      throw new FST_ERR_QSP_NOT_FN(typeof (options.querystringParser ?? options.routerOptions.querystringParser));
    }
    if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
      throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
    }
    validateBodyLimitOption(options.bodyLimit);
    const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
    const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
    const requestIdLogLabel = options.requestIdLogLabel || "reqId";
    options.bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
    const disableRequestLogging = options.disableRequestLogging || false;
    const ajvOptions = Object.assign({
      customOptions: {},
      plugins: []
    }, options.ajv);
    if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
    }
    if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
    }
    const { logger, hasLogger } = createLogger(options);
    options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
    options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
    options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
    options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
    options.logger = logger;
    options.requestIdHeader = requestIdHeader;
    options.requestIdLogLabel = requestIdLogLabel;
    options.disableRequestLogging = disableRequestLogging;
    options.ajv = ajvOptions;
    options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
    options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;
    const initialConfig = getSecuredInitialConfig(options);
    options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
    options.http2SessionTimeout = initialConfig.http2SessionTimeout;
    options.routerOptions = buildRouterOptions(options, {
      defaultRoute,
      onBadUrl,
      ignoreTrailingSlash: defaultInitOptions.ignoreTrailingSlash,
      ignoreDuplicateSlashes: defaultInitOptions.ignoreDuplicateSlashes,
      maxParamLength: defaultInitOptions.maxParamLength,
      allowUnsafeRegex: defaultInitOptions.allowUnsafeRegex,
      buildPrettyMeta: defaultBuildPrettyMeta,
      useSemicolonDelimiter: defaultInitOptions.useSemicolonDelimiter
    });
    return {
      options,
      genReqId,
      disableRequestLogging,
      hasLogger,
      initialConfig
    };
  }
  function defaultBuildPrettyMeta(route2) {
    const cleanKeys = {};
    const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
    allowedProps.concat(supportedHooks).forEach((k) => {
      cleanKeys[k] = route2.store[k];
    });
    return Object.assign({}, cleanKeys);
  }
  function defaultClientErrorHandler(err2, socket) {
    if (err2.code === "ECONNRESET" || socket.destroyed) {
      return;
    }
    let body, errorCode, errorStatus2, errorLabel;
    if (err2.code === "ERR_HTTP_REQUEST_TIMEOUT") {
      errorCode = "408";
      errorStatus2 = http.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus2}","message":"Client Timeout","statusCode":408}`;
      errorLabel = "timeout";
    } else if (err2.code === "HPE_HEADER_OVERFLOW") {
      errorCode = "431";
      errorStatus2 = http.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus2}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
      errorLabel = "header_overflow";
    } else {
      errorCode = "400";
      errorStatus2 = http.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus2}","message":"Client Error","statusCode":400}`;
      errorLabel = "error";
    }
    this.log.trace({ err: err2 }, `client ${errorLabel}`);
    if (socket.writable) {
      socket.write(`HTTP/1.1 ${errorCode} ${errorStatus2}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
    }
    socket.destroy(err2);
  }
  function validateSchemaErrorFormatter(schemaErrorFormatter) {
    if (typeof schemaErrorFormatter !== "function") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
    } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
    }
  }
  fastify$1.exports = fastify2;
  fastify$1.exports.errorCodes = errorCodes;
  fastify$1.exports.fastify = fastify2;
  fastify$1.exports.default = fastify2;
  return fastify$1.exports;
}
var fastifyExports = requireFastify();
const Fastify = /* @__PURE__ */ getDefaultExportFromCjs(fastifyExports);
var cors$1 = { exports: {} };
var plugin = { exports: {} };
var getPluginName = { exports: {} };
var hasRequiredGetPluginName;
function requireGetPluginName() {
  if (hasRequiredGetPluginName) return getPluginName.exports;
  hasRequiredGetPluginName = 1;
  const fpStackTracePattern = /at\s(?:.*\.)?plugin\s.*\n\s*(.*)/;
  const fileNamePattern = /(\w*(\.\w*)*)\..*/;
  getPluginName.exports = function getPluginName2(fn) {
    if (fn.name.length > 0) return fn.name;
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 10;
    try {
      throw new Error("anonymous function");
    } catch (e) {
      Error.stackTraceLimit = stackTraceLimit;
      return extractPluginName(e.stack);
    }
  };
  function extractPluginName(stack) {
    const m = stack.match(fpStackTracePattern);
    return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
  }
  getPluginName.exports.extractPluginName = extractPluginName;
  return getPluginName.exports;
}
var toCamelCase;
var hasRequiredToCamelCase;
function requireToCamelCase() {
  if (hasRequiredToCamelCase) return toCamelCase;
  hasRequiredToCamelCase = 1;
  toCamelCase = function toCamelCase2(name) {
    if (name[0] === "@") {
      name = name.slice(1).replace("/", "-");
    }
    return name.replace(/-(.)/g, function(match, g1) {
      return g1.toUpperCase();
    });
  };
  return toCamelCase;
}
var hasRequiredPlugin;
function requirePlugin() {
  if (hasRequiredPlugin) return plugin.exports;
  hasRequiredPlugin = 1;
  const getPluginName2 = requireGetPluginName();
  const toCamelCase2 = requireToCamelCase();
  let count = 0;
  function plugin$12(fn, options = {}) {
    let autoName = false;
    if (fn.default !== void 0) {
      fn = fn.default;
    }
    if (typeof fn !== "function") {
      throw new TypeError(
        `fastify-plugin expects a function, instead got a '${typeof fn}'`
      );
    }
    if (typeof options === "string") {
      options = {
        fastify: options
      };
    }
    if (typeof options !== "object" || Array.isArray(options) || options === null) {
      throw new TypeError("The options object should be an object");
    }
    if (options.fastify !== void 0 && typeof options.fastify !== "string") {
      throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
    }
    if (!options.name) {
      autoName = true;
      options.name = getPluginName2(fn) + "-auto-" + count++;
    }
    fn[/* @__PURE__ */ Symbol.for("skip-override")] = options.encapsulate !== true;
    fn[/* @__PURE__ */ Symbol.for("fastify.display-name")] = options.name;
    fn[/* @__PURE__ */ Symbol.for("plugin-meta")] = options;
    if (!fn.default) {
      fn.default = fn;
    }
    const camelCase = toCamelCase2(options.name);
    if (!autoName && !fn[camelCase]) {
      fn[camelCase] = fn;
    }
    return fn;
  }
  plugin.exports = plugin$12;
  plugin.exports.default = plugin$12;
  plugin.exports.fastifyPlugin = plugin$12;
  return plugin.exports;
}
var vary = {};
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary;
  hasRequiredVary = 1;
  const { FifoMap: FifoCache } = requireToadCache();
  const validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
  function validateFieldname(fieldname) {
    if (validFieldnameRE.test(fieldname) === false) {
      throw new TypeError("Fieldname contains invalid characters.");
    }
  }
  function parse2(header) {
    header = header.trim().toLowerCase();
    const result = [];
    if (header.length === 0) ;
    else if (header.indexOf(",") === -1) {
      result.push(header);
    } else {
      const il = header.length;
      let i = 0;
      let pos = 0;
      let char;
      for (i; i < il; ++i) {
        char = header[i];
        if (char === " ") {
          pos = i + 1;
        } else if (char === ",") {
          if (pos !== i) {
            result.push(header.slice(pos, i));
          }
          pos = i + 1;
        }
      }
      if (pos !== i) {
        result.push(header.slice(pos, i));
      }
    }
    return result;
  }
  function createAddFieldnameToVary(fieldname) {
    const headerCache = new FifoCache(1e3);
    validateFieldname(fieldname);
    return function(reply2) {
      let header = reply2.getHeader("Vary");
      if (!header) {
        reply2.header("Vary", fieldname);
        return;
      }
      if (header === "*") {
        return;
      }
      if (fieldname === "*") {
        reply2.header("Vary", "*");
        return;
      }
      if (Array.isArray(header)) {
        header = header.join(", ");
      }
      if (headerCache.get(header) === void 0) {
        const vals = parse2(header);
        if (vals.indexOf("*") !== -1) {
          headerCache.set(header, "*");
        } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
          headerCache.set(header, header + ", " + fieldname);
        } else {
          headerCache.set(header, null);
        }
      }
      const cached2 = headerCache.get(header);
      if (cached2 !== null) {
        reply2.header("Vary", cached2);
      }
    };
  }
  vary.createAddFieldnameToVary = createAddFieldnameToVary;
  vary.addOriginToVaryHeader = createAddFieldnameToVary("Origin");
  vary.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary("Access-Control-Request-Headers");
  vary.parse = parse2;
  return vary;
}
var hasRequiredCors;
function requireCors() {
  if (hasRequiredCors) return cors$1.exports;
  hasRequiredCors = 1;
  const fp = requirePlugin();
  const {
    addAccessControlRequestHeadersToVaryHeader,
    addOriginToVaryHeader
  } = requireVary();
  const defaultOptions = {
    origin: "*",
    methods: "GET,HEAD,POST",
    hook: "onRequest",
    preflightContinue: false,
    optionsSuccessStatus: 204,
    credentials: false,
    exposedHeaders: null,
    allowedHeaders: null,
    maxAge: null,
    preflight: true,
    strictPreflight: true
  };
  const validHooks = [
    "onRequest",
    "preParsing",
    "preValidation",
    "preHandler",
    "preSerialization",
    "onSend"
  ];
  const hookWithPayload = [
    "preSerialization",
    "preParsing",
    "onSend"
  ];
  function validateHook(value, next) {
    if (validHooks.indexOf(value) !== -1) {
      return;
    }
    next(new TypeError("@fastify/cors: Invalid hook option provided."));
  }
  function fastifyCors(fastify2, opts, next) {
    fastify2.decorateRequest("corsPreflightEnabled", false);
    let hideOptionsRoute = true;
    let logLevel;
    if (typeof opts === "function") {
      handleCorsOptionsDelegator(opts, fastify2, { hook: defaultOptions.hook }, next);
    } else if (opts.delegator) {
      const { delegator, ...options } = opts;
      handleCorsOptionsDelegator(delegator, fastify2, options, next);
    } else {
      const corsOptions = normalizeCorsOptions(opts);
      validateHook(corsOptions.hook, next);
      if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
        fastify2.addHook(corsOptions.hook, function handleCors(req2, reply2, _payload, next2) {
          addCorsHeadersHandler(fastify2, corsOptions, req2, reply2, next2);
        });
      } else {
        fastify2.addHook(corsOptions.hook, function handleCors(req2, reply2, next2) {
          addCorsHeadersHandler(fastify2, corsOptions, req2, reply2, next2);
        });
      }
    }
    if (opts.logLevel !== void 0) logLevel = opts.logLevel;
    if (opts.hideOptionsRoute !== void 0) hideOptionsRoute = opts.hideOptionsRoute;
    fastify2.options("*", { schema: { hide: hideOptionsRoute }, logLevel }, (req2, reply2) => {
      if (!req2.corsPreflightEnabled) {
        reply2.callNotFound();
        return;
      }
      reply2.send();
    });
    next();
  }
  function handleCorsOptionsDelegator(optionsResolver, fastify2, opts, next) {
    const hook = opts?.hook || defaultOptions.hook;
    validateHook(hook, next);
    if (optionsResolver.length === 2) {
      if (hookWithPayload.indexOf(hook) !== -1) {
        fastify2.addHook(hook, function handleCors(req2, reply2, _payload, next2) {
          handleCorsOptionsCallbackDelegator(optionsResolver, fastify2, req2, reply2, next2);
        });
      } else {
        fastify2.addHook(hook, function handleCors(req2, reply2, next2) {
          handleCorsOptionsCallbackDelegator(optionsResolver, fastify2, req2, reply2, next2);
        });
      }
    } else {
      if (hookWithPayload.indexOf(hook) !== -1) {
        fastify2.addHook(hook, function handleCors(req2, reply2, _payload, next2) {
          const ret = optionsResolver(req2);
          if (ret && typeof ret.then === "function") {
            ret.then((options) => addCorsHeadersHandler(fastify2, normalizeCorsOptions(options, true), req2, reply2, next2)).catch(next2);
            return;
          }
          next2(new Error("Invalid CORS origin option"));
        });
      } else {
        fastify2.addHook(hook, function handleCors(req2, reply2, next2) {
          const ret = optionsResolver(req2);
          if (ret && typeof ret.then === "function") {
            ret.then((options) => addCorsHeadersHandler(fastify2, normalizeCorsOptions(options, true), req2, reply2, next2)).catch(next2);
            return;
          }
          next2(new Error("Invalid CORS origin option"));
        });
      }
    }
  }
  function handleCorsOptionsCallbackDelegator(optionsResolver, fastify2, req2, reply2, next) {
    optionsResolver(req2, (err2, options) => {
      if (err2) {
        next(err2);
      } else {
        addCorsHeadersHandler(fastify2, normalizeCorsOptions(options, true), req2, reply2, next);
      }
    });
  }
  function normalizeCorsOptions(opts, dynamic) {
    const corsOptions = { ...defaultOptions, ...opts };
    if (Array.isArray(opts.origin) && opts.origin.indexOf("*") !== -1) {
      corsOptions.origin = "*";
    }
    if (Number.isInteger(corsOptions.cacheControl)) {
      corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
    } else if (typeof corsOptions.cacheControl !== "string") {
      corsOptions.cacheControl = null;
    }
    corsOptions.dynamic = dynamic || false;
    return corsOptions;
  }
  function addCorsHeadersHandler(fastify2, globalOptions, req2, reply2, next) {
    const options = { ...globalOptions, ...req2.routeOptions.config?.cors };
    if (typeof options.origin !== "string" && options.origin !== false || options.dynamic) {
      addOriginToVaryHeader(reply2);
    }
    const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify2, options.origin) : (_, cb) => cb(null, options.origin);
    resolveOriginOption(req2, (error2, resolvedOriginOption) => {
      if (error2 !== null) {
        return next(error2);
      }
      if (resolvedOriginOption === false) {
        return next();
      }
      if (req2.routeOptions.config?.cors === false) {
        return next();
      }
      if (!resolvedOriginOption) {
        return next(new Error("Invalid CORS origin option"));
      }
      addCorsHeaders(req2, reply2, resolvedOriginOption, options);
      if (req2.raw.method === "OPTIONS" && options.preflight === true) {
        if (options.strictPreflight === true && (!req2.headers.origin || !req2.headers["access-control-request-method"])) {
          reply2.status(400).type("text/plain").send("Invalid Preflight Request");
          return;
        }
        req2.corsPreflightEnabled = true;
        addPreflightHeaders(req2, reply2, options);
        if (!options.preflightContinue) {
          reply2.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
          return;
        }
      }
      return next();
    });
  }
  function addCorsHeaders(req2, reply2, originOption, corsOptions) {
    const origin = getAccessControlAllowOriginHeader(req2.headers.origin, originOption);
    if (origin) {
      reply2.header("Access-Control-Allow-Origin", origin);
    }
    if (corsOptions.credentials) {
      reply2.header("Access-Control-Allow-Credentials", "true");
    }
    if (corsOptions.exposedHeaders !== null) {
      reply2.header(
        "Access-Control-Expose-Headers",
        Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders
      );
    }
  }
  function addPreflightHeaders(req2, reply2, corsOptions) {
    reply2.header(
      "Access-Control-Allow-Methods",
      Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods
    );
    if (corsOptions.allowedHeaders === null) {
      addAccessControlRequestHeadersToVaryHeader(reply2);
      const reqAllowedHeaders = req2.headers["access-control-request-headers"];
      if (reqAllowedHeaders !== void 0) {
        reply2.header("Access-Control-Allow-Headers", reqAllowedHeaders);
      }
    } else {
      reply2.header(
        "Access-Control-Allow-Headers",
        Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders
      );
    }
    if (corsOptions.maxAge !== null) {
      reply2.header("Access-Control-Max-Age", String(corsOptions.maxAge));
    }
    if (corsOptions.cacheControl) {
      reply2.header("Cache-Control", corsOptions.cacheControl);
    }
  }
  function resolveOriginWrapper(fastify2, origin) {
    return function(req2, cb) {
      const result = origin.call(fastify2, req2.headers.origin, cb);
      if (result && typeof result.then === "function") {
        result.then((res2) => cb(null, res2), cb);
      }
    };
  }
  function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
    if (typeof originOption === "string") {
      return originOption;
    }
    return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
  }
  function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (let i = 0; i < allowedOrigin.length; ++i) {
        if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (typeof allowedOrigin === "string") {
      return reqOrigin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      allowedOrigin.lastIndex = 0;
      return allowedOrigin.test(reqOrigin);
    } else {
      return !!allowedOrigin;
    }
  }
  const _fastifyCors = fp(fastifyCors, {
    fastify: "5.x",
    name: "@fastify/cors"
  });
  cors$1.exports = _fastifyCors;
  cors$1.exports.fastifyCors = _fastifyCors;
  cors$1.exports.default = _fastifyCors;
  return cors$1.exports;
}
var corsExports = requireCors();
const cors = /* @__PURE__ */ getDefaultExportFromCjs(corsExports);
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer2(inst, def);
    const proto2 = _.prototype;
    const keys = Object.keys(proto2);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto2[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values2 = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values2;
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject$1(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject$1(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject$1(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit$1(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const e164 = /^\+[1-9]\d{6,14}$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?$/;
const boolean$1 = /^(?:true|false)$/i;
const _null$2 = /^null$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern2 = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern2;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
}
const version = {
  major: 4,
  minor: 3,
  patch: 6
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse$1(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null$2;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject$1;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id2 = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id2} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject$1;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values2 = getEnumValues(def.entries);
  const valuesSet = new Set(values2);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values2.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: values2,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var _a;
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta2 = _meta[0];
    this._map.set(schema, meta2);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.set(meta2.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta2 = this._map.get(schema);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.delete(meta2.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class, params) {
  return new Class({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null$1(Class, params) {
  return new Class({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern2, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern: pattern2
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class, fn, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process$1(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process$1(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      const existing = idToSchema.get(id2);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id2, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id3) => id3);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id2;
      return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref: ref2, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref2;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref2 = seen.ref;
    seen.ref = null;
    if (ref2) {
      flattenRef(ref2);
      const refSeen = ctx.seen.get(ref2);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref2;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref2) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") ;
  else ;
  if (ctx.external?.uri) {
    const id2 = ctx.external.registry.get(schema)?.id;
    if (!id2)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id2);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) ;
  else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process$1(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process$1(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
const formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
const stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format: format2, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format2) {
    json.format = formatMap[format2] ?? format2;
    if (json.format === "")
      delete json.format;
    if (format2 === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
const numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format: format2, multipleOf: multipleOf2, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format2 === "string" && format2.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf2 === "number")
    json.multipleOf = multipleOf2;
};
const booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
const nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0") {
    json.type = "string";
    json.nullable = true;
    json.enum = [null];
  } else {
    json.type = "null";
  }
};
const neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
};
const unknownProcessor = (_schema, _ctx, _json, _params) => {
};
const enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values2 = getEnumValues(def.entries);
  if (values2.every((v) => typeof v === "number"))
    json.type = "number";
  if (values2.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values2;
};
const customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
const transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
const arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process$1(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
const objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process$1(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process$1(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
const unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process$1(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options;
  } else {
    json.anyOf = options;
  }
};
const intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process$1(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process$1(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf2 = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf2;
};
const nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process$1(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
};
const optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var errorExports = requireError$1();
const createError = /* @__PURE__ */ getDefaultExportFromCjs(errorExports);
const InvalidSchemaError = createError("FST_ERR_INVALID_SCHEMA", "Invalid schema passed: %s", 500);
const ZodFastifySchemaValidationErrorSymbol = /* @__PURE__ */ Symbol.for("ZodFastifySchemaValidationError");
const ResponseSerializationBase = createError(
  "FST_ERR_RESPONSE_SERIALIZATION",
  "Response doesn't match the schema",
  500
);
class ResponseSerializationError extends ResponseSerializationBase {
  constructor(method, url, options) {
    super({ cause: options.cause });
    this.method = method;
    this.url = url;
    this.cause = options.cause;
  }
  cause;
}
function omit(obj, keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
function createValidationError(error2) {
  return error2.issues.map((issue2) => {
    return {
      [ZodFastifySchemaValidationErrorSymbol]: true,
      keyword: issue2.code,
      instancePath: `/${issue2.path.join("/")}`,
      schemaPath: `#/${issue2.path.join("/")}/${issue2.code}`,
      message: issue2.message,
      params: {
        ...omit(issue2, ["path", "code", "message"])
      }
    };
  });
}
const validatorCompiler = ({ schema }) => (data) => {
  const result = safeParse$1(schema, data);
  if (result.error) {
    return { error: createValidationError(result.error) };
  }
  return { value: result.data };
};
function resolveSchema(maybeSchema) {
  if (maybeSchema instanceof $ZodType) {
    return maybeSchema;
  }
  if ("properties" in maybeSchema && maybeSchema.properties instanceof $ZodType) {
    return maybeSchema.properties;
  }
  throw new InvalidSchemaError(JSON.stringify(maybeSchema));
}
const createSerializerCompiler = (options) => ({ schema: maybeSchema, method, url }) => (data) => {
  const schema = resolveSchema(maybeSchema);
  const result = safeParse$1(schema, data);
  if (result.error) {
    throw new ResponseSerializationError(method, url, {
      cause: result.error
    });
  }
  return JSON.stringify(result.data, options?.replacer);
};
const serializerCompiler = createSerializerCompiler({});
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return /* @__PURE__ */ _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date(params) {
  return /* @__PURE__ */ _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return /* @__PURE__ */ _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return /* @__PURE__ */ _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode(inst, data, params);
  inst.decode = (data, params) => decode(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(/* @__PURE__ */ _overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description2) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description: description2 });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(/* @__PURE__ */ _regex(...args));
  inst.includes = (...args) => inst.check(/* @__PURE__ */ _includes(...args));
  inst.startsWith = (...args) => inst.check(/* @__PURE__ */ _startsWith(...args));
  inst.endsWith = (...args) => inst.check(/* @__PURE__ */ _endsWith(...args));
  inst.min = (...args) => inst.check(/* @__PURE__ */ _minLength(...args));
  inst.max = (...args) => inst.check(/* @__PURE__ */ _maxLength(...args));
  inst.length = (...args) => inst.check(/* @__PURE__ */ _length(...args));
  inst.nonempty = (...args) => inst.check(/* @__PURE__ */ _minLength(1, ...args));
  inst.lowercase = (params) => inst.check(/* @__PURE__ */ _lowercase(params));
  inst.uppercase = (params) => inst.check(/* @__PURE__ */ _uppercase(params));
  inst.trim = () => inst.check(/* @__PURE__ */ _trim());
  inst.normalize = (...args) => inst.check(/* @__PURE__ */ _normalize(...args));
  inst.toLowerCase = () => inst.check(/* @__PURE__ */ _toLowerCase());
  inst.toUpperCase = () => inst.check(/* @__PURE__ */ _toUpperCase());
  inst.slugify = () => inst.check(/* @__PURE__ */ _slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(/* @__PURE__ */ _email(ZodEmail, params));
  inst.url = (params) => inst.check(/* @__PURE__ */ _url(ZodURL, params));
  inst.jwt = (params) => inst.check(/* @__PURE__ */ _jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(/* @__PURE__ */ _emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(/* @__PURE__ */ _guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(/* @__PURE__ */ _uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(/* @__PURE__ */ _uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(/* @__PURE__ */ _uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(/* @__PURE__ */ _uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(/* @__PURE__ */ _nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(/* @__PURE__ */ _guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(/* @__PURE__ */ _cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(/* @__PURE__ */ _cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(/* @__PURE__ */ _ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(/* @__PURE__ */ _base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(/* @__PURE__ */ _base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(/* @__PURE__ */ _xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(/* @__PURE__ */ _ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(/* @__PURE__ */ _ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(/* @__PURE__ */ _ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(/* @__PURE__ */ _cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(/* @__PURE__ */ _cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(/* @__PURE__ */ _e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return /* @__PURE__ */ _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json);
  inst.gt = (value, params) => inst.check(/* @__PURE__ */ _gt(value, params));
  inst.gte = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.min = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.lt = (value, params) => inst.check(/* @__PURE__ */ _lt(value, params));
  inst.lte = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.max = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(/* @__PURE__ */ _gt(0, params));
  inst.nonnegative = (params) => inst.check(/* @__PURE__ */ _gte(0, params));
  inst.negative = (params) => inst.check(/* @__PURE__ */ _lt(0, params));
  inst.nonpositive = (params) => inst.check(/* @__PURE__ */ _lte(0, params));
  inst.multipleOf = (value, params) => inst.check(/* @__PURE__ */ _multipleOf(value, params));
  inst.step = (value, params) => inst.check(/* @__PURE__ */ _multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return /* @__PURE__ */ _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return /* @__PURE__ */ _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json);
});
function boolean(params) {
  return /* @__PURE__ */ _boolean(ZodBoolean, params);
}
const ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json);
});
function _null(params) {
  return /* @__PURE__ */ _null$1(ZodNull, params);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor();
});
function unknown() {
  return /* @__PURE__ */ _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json);
});
function never(params) {
  return /* @__PURE__ */ _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(/* @__PURE__ */ _minLength(minLength, params));
  inst.nonempty = (params) => inst.check(/* @__PURE__ */ _minLength(1, params));
  inst.max = (maxLength, params) => inst.check(/* @__PURE__ */ _maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(/* @__PURE__ */ _length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return /* @__PURE__ */ _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
  defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit$1(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values2, params) => {
    const newEntries = {};
    for (const value of values2) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values2, params) => {
    const newEntries = { ...def.entries };
    for (const value of values2) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx);
});
function refine(fn, _params = {}) {
  return /* @__PURE__ */ _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return /* @__PURE__ */ _superRefine(fn);
}
_enum(["mm", "m"]);
const WindowItemSchema = object({
  id: string().uuid().optional(),
  drawingId: string().uuid().optional(),
  // 关联图纸 ID
  name: string().min(1, "名称不能为空"),
  category: string().default("默认"),
  shapeType: string(),
  width: number(),
  height: number(),
  area: number(),
  glassArea: number().optional(),
  perimeter: number().optional(),
  frameWeight: number().optional(),
  points: array(object({ x: number(), y: number() })),
  createdAt: string().optional()
});
const DrawingSchema = object({
  id: string().uuid().optional(),
  title: string(),
  fileName: string(),
  windowCount: number(),
  totalArea: number(),
  createdAt: string().optional()
});
const WindowResponseSchema = object({
  success: boolean(),
  data: union([array(WindowItemSchema), WindowItemSchema, _null()]).optional(),
  error: string().optional()
});
const DrawingResponseSchema = object({
  success: boolean(),
  data: union([array(DrawingSchema), DrawingSchema, _null()]).optional(),
  error: string().optional()
});
function isUndefined(obj) {
  return typeof obj === "undefined" || obj === void 0;
}
function isString(obj) {
  return typeof obj === "string";
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop(obj) {
  return obj;
}
const AlterTableNode = freeze({
  is(node2) {
    return node2.kind === "AlterTableNode";
  },
  create(table) {
    return freeze({
      kind: "AlterTableNode",
      table
    });
  },
  cloneWithTableProps(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  },
  cloneWithColumnAlteration(node2, columnAlteration) {
    return freeze({
      ...node2,
      columnAlterations: node2.columnAlterations ? [...node2.columnAlterations, columnAlteration] : [columnAlteration]
    });
  }
});
const IdentifierNode = freeze({
  is(node2) {
    return node2.kind === "IdentifierNode";
  },
  create(name) {
    return freeze({
      kind: "IdentifierNode",
      name
    });
  }
});
const CreateIndexNode = freeze({
  is(node2) {
    return node2.kind === "CreateIndexNode";
  },
  create(name) {
    return freeze({
      kind: "CreateIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  },
  cloneWithColumns(node2, columns) {
    return freeze({
      ...node2,
      columns: [...node2.columns || [], ...columns]
    });
  }
});
const CreateSchemaNode = freeze({
  is(node2) {
    return node2.kind === "CreateSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "CreateSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(createSchema, params) {
    return freeze({
      ...createSchema,
      ...params
    });
  }
});
const ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
const CreateTableNode = freeze({
  is(node2) {
    return node2.kind === "CreateTableNode";
  },
  create(table) {
    return freeze({
      kind: "CreateTableNode",
      table,
      columns: freeze([])
    });
  },
  cloneWithColumn(createTable, column) {
    return freeze({
      ...createTable,
      columns: freeze([...createTable.columns, column])
    });
  },
  cloneWithConstraint(createTable, constraint) {
    return freeze({
      ...createTable,
      constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
    });
  },
  cloneWithFrontModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWith(createTable, params) {
    return freeze({
      ...createTable,
      ...params
    });
  }
});
const SchemableIdentifierNode = freeze({
  is(node2) {
    return node2.kind === "SchemableIdentifierNode";
  },
  create(identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      identifier: IdentifierNode.create(identifier)
    });
  },
  createWithSchema(schema, identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      schema: IdentifierNode.create(schema),
      identifier: IdentifierNode.create(identifier)
    });
  }
});
const DropIndexNode = freeze({
  is(node2) {
    return node2.kind === "DropIndexNode";
  },
  create(name, params) {
    return freeze({
      kind: "DropIndexNode",
      name: SchemableIdentifierNode.create(name),
      ...params
    });
  },
  cloneWith(dropIndex, props) {
    return freeze({
      ...dropIndex,
      ...props
    });
  }
});
const DropSchemaNode = freeze({
  is(node2) {
    return node2.kind === "DropSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "DropSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(dropSchema, params) {
    return freeze({
      ...dropSchema,
      ...params
    });
  }
});
const DropTableNode = freeze({
  is(node2) {
    return node2.kind === "DropTableNode";
  },
  create(table, params) {
    return freeze({
      kind: "DropTableNode",
      table,
      ...params
    });
  },
  cloneWith(dropIndex, params) {
    return freeze({
      ...dropIndex,
      ...params
    });
  }
});
const AliasNode = freeze({
  is(node2) {
    return node2.kind === "AliasNode";
  },
  create(node2, alias) {
    return freeze({
      kind: "AliasNode",
      node: node2,
      alias
    });
  }
});
const TableNode = freeze({
  is(node2) {
    return node2.kind === "TableNode";
  },
  create(table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.create(table)
    });
  },
  createWithSchema(schema, table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.createWithSchema(schema, table)
    });
  }
});
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction(obj.toOperationNode);
}
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString(obj.alias) && isOperationNodeSource(obj);
}
const SelectModifierNode = freeze({
  is(node2) {
    return node2.kind === "SelectModifierNode";
  },
  create(modifier, of) {
    return freeze({
      kind: "SelectModifierNode",
      modifier,
      of
    });
  },
  createWithExpression(modifier) {
    return freeze({
      kind: "SelectModifierNode",
      rawModifier: modifier
    });
  }
});
const AndNode = freeze({
  is(node2) {
    return node2.kind === "AndNode";
  },
  create(left, right) {
    return freeze({
      kind: "AndNode",
      left,
      right
    });
  }
});
const OrNode = freeze({
  is(node2) {
    return node2.kind === "OrNode";
  },
  create(left, right) {
    return freeze({
      kind: "OrNode",
      left,
      right
    });
  }
});
const OnNode = freeze({
  is(node2) {
    return node2.kind === "OnNode";
  },
  create(filter) {
    return freeze({
      kind: "OnNode",
      on: filter
    });
  },
  cloneWithOperation(onNode, operator, operation) {
    return freeze({
      ...onNode,
      on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
    });
  }
});
const JoinNode = freeze({
  is(node2) {
    return node2.kind === "JoinNode";
  },
  create(joinType, table) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: void 0
    });
  },
  createWithOn(joinType, table, on) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: OnNode.create(on)
    });
  },
  cloneWithOn(joinNode, operation) {
    return freeze({
      ...joinNode,
      on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
    });
  }
});
const BinaryOperationNode = freeze({
  is(node2) {
    return node2.kind === "BinaryOperationNode";
  },
  create(leftOperand, operator, rightOperand) {
    return freeze({
      kind: "BinaryOperationNode",
      leftOperand,
      operator,
      rightOperand
    });
  }
});
const COMPARISON_OPERATORS = [
  "=",
  "==",
  "!=",
  "<>",
  ">",
  ">=",
  "<",
  "<=",
  "in",
  "not in",
  "is",
  "is not",
  "like",
  "not like",
  "match",
  "ilike",
  "not ilike",
  "@>",
  "<@",
  "^@",
  "&&",
  "?",
  "?&",
  "?|",
  "!<",
  "!>",
  "<=>",
  "!~",
  "~",
  "~*",
  "!~*",
  "@@",
  "@@@",
  "!!",
  "<->",
  "regexp",
  "is distinct from",
  "is not distinct from"
];
const ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "&",
  "|",
  "#",
  "<<",
  ">>"
];
const JSON_OPERATORS = ["->", "->>"];
const BINARY_OPERATORS = [
  ...COMPARISON_OPERATORS,
  ...ARITHMETIC_OPERATORS,
  "&&",
  "||"
];
const UNARY_FILTER_OPERATORS = ["exists", "not exists"];
const UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
const OPERATORS = [
  ...BINARY_OPERATORS,
  ...JSON_OPERATORS,
  ...UNARY_OPERATORS,
  "between",
  "between symmetric"
];
const OperatorNode = freeze({
  is(node2) {
    return node2.kind === "OperatorNode";
  },
  create(operator) {
    return freeze({
      kind: "OperatorNode",
      operator
    });
  }
});
function isJSONOperator(op) {
  return isString(op) && JSON_OPERATORS.includes(op);
}
const ColumnNode = freeze({
  is(node2) {
    return node2.kind === "ColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ColumnNode",
      column: IdentifierNode.create(column)
    });
  }
});
const SelectAllNode = freeze({
  is(node2) {
    return node2.kind === "SelectAllNode";
  },
  create() {
    return freeze({
      kind: "SelectAllNode"
    });
  }
});
const ReferenceNode = freeze({
  is(node2) {
    return node2.kind === "ReferenceNode";
  },
  create(column, table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column
    });
  },
  createSelectAll(table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column: SelectAllNode.create()
    });
  }
});
class DynamicReferenceBuilder {
  #dynamicReference;
  get dynamicReference() {
    return this.#dynamicReference;
  }
  /**
   * @private
   *
   * This needs to be here just so that the typings work. Without this
   * the generated .d.ts file contains no reference to the type param R
   * which causes this type to be equal to DynamicReferenceBuilder with
   * any R.
   */
  get refType() {
    return void 0;
  }
  constructor(reference) {
    this.#dynamicReference = reference;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(this.#dynamicReference);
  }
}
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.dynamicReference);
}
const OrderByItemNode = freeze({
  is(node2) {
    return node2.kind === "OrderByItemNode";
  },
  create(orderBy, direction) {
    return freeze({
      kind: "OrderByItemNode",
      orderBy,
      direction
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  }
});
const RawNode = freeze({
  is(node2) {
    return node2.kind === "RawNode";
  },
  create(sqlFragments, parameters) {
    return freeze({
      kind: "RawNode",
      sqlFragments: freeze(sqlFragments),
      parameters: freeze(parameters)
    });
  },
  createWithSql(sql2) {
    return RawNode.create([sql2], []);
  },
  createWithChild(child) {
    return RawNode.create(["", ""], [child]);
  },
  createWithChildren(children) {
    return RawNode.create(new Array(children.length + 1).fill(""), children);
  }
});
const CollateNode = freeze({
  is(node2) {
    return node2.kind === "CollateNode";
  },
  create(collation) {
    return freeze({
      kind: "CollateNode",
      collation: IdentifierNode.create(collation)
    });
  }
});
class OrderByItemBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds `desc` to the `order by` item.
   *
   * See {@link asc} for the opposite.
   */
  desc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("desc")
      })
    });
  }
  /**
   * Adds `asc` to the `order by` item.
   *
   * See {@link desc} for the opposite.
   */
  asc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("asc")
      })
    });
  }
  /**
   * Adds `nulls last` to the `order by` item.
   *
   * This is only supported by some dialects like PostgreSQL and SQLite.
   *
   * See {@link nullsFirst} for the opposite.
   */
  nullsLast() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "last" })
    });
  }
  /**
   * Adds `nulls first` to the `order by` item.
   *
   * This is only supported by some dialects like PostgreSQL and SQLite.
   *
   * See {@link nullsLast} for the opposite.
   */
  nullsFirst() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "first" })
    });
  }
  /**
   * Adds `collate <collationName>` to the `order by` item.
   */
  collate(collation) {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        collation: CollateNode.create(collation)
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
const LOGGED_MESSAGES = /* @__PURE__ */ new Set();
function logOnce(message) {
  if (LOGGED_MESSAGES.has(message)) {
    return;
  }
  LOGGED_MESSAGES.add(message);
  console.log(message);
}
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      logOnce("orderBy(array) is deprecated, use multiple orderBy calls instead.");
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(expr, modifiers) {
  const parsedRef = parseOrderByExpression(expr);
  if (OrderByItemNode.is(parsedRef)) {
    if (modifiers) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return parseOrderByWithModifiers(parsedRef, modifiers);
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref2, direction] = expr.split(" ");
  if (direction) {
    logOnce("`orderBy('column asc')` is deprecated. Use `orderBy('column', 'asc')` instead.");
    return parseOrderByWithModifiers(parseStringReference(ref2), direction);
  }
  return parseStringReference(expr);
}
function parseOrderByWithModifiers(expr, modifiers) {
  if (typeof modifiers === "string") {
    if (!isOrderByDirection(modifiers)) {
      throw new Error(`Invalid order by direction: ${modifiers}`);
    }
    return OrderByItemNode.create(expr, RawNode.createWithSql(modifiers));
  }
  if (isExpression(modifiers)) {
    logOnce("`orderBy(..., expr)` is deprecated. Use `orderBy(..., 'asc')` or `orderBy(..., (ob) => ...)` instead.");
    return OrderByItemNode.create(expr, modifiers.toOperationNode());
  }
  const node2 = OrderByItemNode.create(expr);
  if (!modifiers) {
    return node2;
  }
  return modifiers(new OrderByItemBuilder({ node: node2 })).toOperationNode();
}
const JSONReferenceNode = freeze({
  is(node2) {
    return node2.kind === "JSONReferenceNode";
  },
  create(reference, traversal) {
    return freeze({
      kind: "JSONReferenceNode",
      reference,
      traversal
    });
  },
  cloneWithTraversal(node2, traversal) {
    return freeze({
      ...node2,
      traversal
    });
  }
});
const JSONOperatorChainNode = freeze({
  is(node2) {
    return node2.kind === "JSONOperatorChainNode";
  },
  create(operator) {
    return freeze({
      kind: "JSONOperatorChainNode",
      operator,
      values: freeze([])
    });
  },
  cloneWithValue(node2, value) {
    return freeze({
      ...node2,
      values: freeze([...node2.values, value])
    });
  }
});
const JSONPathNode = freeze({
  is(node2) {
    return node2.kind === "JSONPathNode";
  },
  create(inOperator) {
    return freeze({
      kind: "JSONPathNode",
      inOperator,
      pathLegs: freeze([])
    });
  },
  cloneWithLeg(jsonPathNode, pathLeg) {
    return freeze({
      ...jsonPathNode,
      pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
    });
  }
});
function parseSimpleReferenceExpression(exp) {
  if (isString(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref2, op) {
  const referenceNode = parseStringReference(ref2);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref2) {
  const COLUMN_SEPARATOR = ".";
  if (!ref2.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref2));
  }
  const parts = ref2.split(COLUMN_SEPARATOR).map(trim$2);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref2}`);
}
function parseAliasedStringReference(ref2) {
  const ALIAS_SEPARATOR = " as ";
  if (ref2.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref2.split(ALIAS_SEPARATOR).map(trim$2);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref2);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim$2);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim$2(str) {
  return str.trim();
}
const PrimitiveValueListNode = freeze({
  is(node2) {
    return node2.kind === "PrimitiveValueListNode";
  },
  create(values2) {
    return freeze({
      kind: "PrimitiveValueListNode",
      values: freeze([...values2])
    });
  }
});
const ValueListNode = freeze({
  is(node2) {
    return node2.kind === "ValueListNode";
  },
  create(values2) {
    return freeze({
      kind: "ValueListNode",
      values: freeze(values2)
    });
  }
});
const ValueNode = freeze({
  is(node2) {
    return node2.kind === "ValueNode";
  },
  create(value) {
    return freeze({
      kind: "ValueNode",
      value
    });
  },
  createImmediate(value) {
    return freeze({
      kind: "ValueNode",
      value,
      immediate: true
    });
  }
});
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}
const ParensNode = freeze({
  is(node2) {
    return node2.kind === "ParensNode";
  },
  create(node2) {
    return freeze({
      kind: "ParensNode",
      node: node2
    });
  }
});
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v]) => !isUndefined(v)).map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? "is" : "=", v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node2 = toOperationNode(list[0]);
  for (let i = 1; i < list.length; ++i) {
    node2 = combine(node2, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node2);
  }
  return node2;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
  if (isString(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}
const OrderByNode = freeze({
  is(node2) {
    return node2.kind === "OrderByNode";
  },
  create(items2) {
    return freeze({
      kind: "OrderByNode",
      items: freeze([...items2])
    });
  },
  cloneWithItems(orderBy, items2) {
    return freeze({
      ...orderBy,
      items: freeze([...orderBy.items, ...items2])
    });
  }
});
const PartitionByNode = freeze({
  is(node2) {
    return node2.kind === "PartitionByNode";
  },
  create(items2) {
    return freeze({
      kind: "PartitionByNode",
      items: freeze(items2)
    });
  },
  cloneWithItems(partitionBy, items2) {
    return freeze({
      ...partitionBy,
      items: freeze([...partitionBy.items, ...items2])
    });
  }
});
const OverNode = freeze({
  is(node2) {
    return node2.kind === "OverNode";
  },
  create() {
    return freeze({
      kind: "OverNode"
    });
  },
  cloneWithOrderByItems(overNode, items2) {
    return freeze({
      ...overNode,
      orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items2) : OrderByNode.create(items2)
    });
  },
  cloneWithPartitionByItems(overNode, items2) {
    return freeze({
      ...overNode,
      partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items2) : PartitionByNode.create(items2)
    });
  }
});
const FromNode = freeze({
  is(node2) {
    return node2.kind === "FromNode";
  },
  create(froms) {
    return freeze({
      kind: "FromNode",
      froms: freeze(froms)
    });
  },
  cloneWithFroms(from, froms) {
    return freeze({
      ...from,
      froms: freeze([...from.froms, ...froms])
    });
  }
});
const GroupByNode = freeze({
  is(node2) {
    return node2.kind === "GroupByNode";
  },
  create(items2) {
    return freeze({
      kind: "GroupByNode",
      items: freeze(items2)
    });
  },
  cloneWithItems(groupBy, items2) {
    return freeze({
      ...groupBy,
      items: freeze([...groupBy.items, ...items2])
    });
  }
});
const HavingNode = freeze({
  is(node2) {
    return node2.kind === "HavingNode";
  },
  create(filter) {
    return freeze({
      kind: "HavingNode",
      having: filter
    });
  },
  cloneWithOperation(havingNode, operator, operation) {
    return freeze({
      ...havingNode,
      having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
    });
  }
});
const InsertQueryNode = freeze({
  is(node2) {
    return node2.kind === "InsertQueryNode";
  },
  create(into, withNode, replace) {
    return freeze({
      kind: "InsertQueryNode",
      into,
      ...withNode && { with: withNode },
      replace
    });
  },
  createWithoutInto() {
    return freeze({
      kind: "InsertQueryNode"
    });
  },
  cloneWith(insertQuery, props) {
    return freeze({
      ...insertQuery,
      ...props
    });
  }
});
const ListNode = freeze({
  is(node2) {
    return node2.kind === "ListNode";
  },
  create(items2) {
    return freeze({
      kind: "ListNode",
      items: freeze(items2)
    });
  }
});
const UpdateQueryNode = freeze({
  is(node2) {
    return node2.kind === "UpdateQueryNode";
  },
  create(tables, withNode) {
    return freeze({
      kind: "UpdateQueryNode",
      // For backwards compatibility, use the raw table node when there's only one table
      // and don't rename the property to something like `tables`.
      table: tables.length === 1 ? tables[0] : ListNode.create(tables),
      ...withNode && { with: withNode }
    });
  },
  createWithoutTable() {
    return freeze({
      kind: "UpdateQueryNode"
    });
  },
  cloneWithFromItems(updateQuery, fromItems) {
    return freeze({
      ...updateQuery,
      from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
    });
  },
  cloneWithUpdates(updateQuery, updates) {
    return freeze({
      ...updateQuery,
      updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
    });
  },
  cloneWithLimit(updateQuery, limit2) {
    return freeze({
      ...updateQuery,
      limit: limit2
    });
  }
});
const UsingNode = freeze({
  is(node2) {
    return node2.kind === "UsingNode";
  },
  create(tables) {
    return freeze({
      kind: "UsingNode",
      tables: freeze(tables)
    });
  },
  cloneWithTables(using, tables) {
    return freeze({
      ...using,
      tables: freeze([...using.tables, ...tables])
    });
  }
});
const DeleteQueryNode = freeze({
  is(node2) {
    return node2.kind === "DeleteQueryNode";
  },
  create(fromItems, withNode) {
    return freeze({
      kind: "DeleteQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithOrderByItems: (node2, items2) => QueryNode.cloneWithOrderByItems(node2, items2),
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithoutOrderBy: (node2) => QueryNode.cloneWithoutOrderBy(node2),
  cloneWithLimit(deleteNode, limit2) {
    return freeze({
      ...deleteNode,
      limit: limit2
    });
  },
  cloneWithoutLimit(deleteNode) {
    return freeze({
      ...deleteNode,
      limit: void 0
    });
  },
  cloneWithUsing(deleteNode, tables) {
    return freeze({
      ...deleteNode,
      using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
    });
  }
});
const WhereNode = freeze({
  is(node2) {
    return node2.kind === "WhereNode";
  },
  create(filter) {
    return freeze({
      kind: "WhereNode",
      where: filter
    });
  },
  cloneWithOperation(whereNode, operator, operation) {
    return freeze({
      ...whereNode,
      where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
    });
  }
});
const ReturningNode = freeze({
  is(node2) {
    return node2.kind === "ReturningNode";
  },
  create(selections) {
    return freeze({
      kind: "ReturningNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(returning, selections) {
    return freeze({
      ...returning,
      selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
    });
  }
});
const ExplainNode = freeze({
  is(node2) {
    return node2.kind === "ExplainNode";
  },
  create(format2, options) {
    return freeze({
      kind: "ExplainNode",
      format: format2,
      options
    });
  }
});
const WhenNode = freeze({
  is(node2) {
    return node2.kind === "WhenNode";
  },
  create(condition) {
    return freeze({
      kind: "WhenNode",
      condition
    });
  },
  cloneWithResult(whenNode, result) {
    return freeze({
      ...whenNode,
      result
    });
  }
});
const MergeQueryNode = freeze({
  is(node2) {
    return node2.kind === "MergeQueryNode";
  },
  create(into, withNode) {
    return freeze({
      kind: "MergeQueryNode",
      into,
      ...withNode && { with: withNode }
    });
  },
  cloneWithUsing(mergeNode, using) {
    return freeze({
      ...mergeNode,
      using
    });
  },
  cloneWithWhen(mergeNode, when) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
    });
  },
  cloneWithThen(mergeNode, then) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([
        ...mergeNode.whens.slice(0, -1),
        WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
      ]) : void 0
    });
  }
});
const OutputNode = freeze({
  is(node2) {
    return node2.kind === "OutputNode";
  },
  create(selections) {
    return freeze({
      kind: "OutputNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(output, selections) {
    return freeze({
      ...output,
      selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
    });
  }
});
const QueryNode = freeze({
  is(node2) {
    return SelectQueryNode.is(node2) || InsertQueryNode.is(node2) || UpdateQueryNode.is(node2) || DeleteQueryNode.is(node2) || MergeQueryNode.is(node2);
  },
  cloneWithEndModifier(node2, modifier) {
    return freeze({
      ...node2,
      endModifiers: node2.endModifiers ? freeze([...node2.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithWhere(node2, operation) {
    return freeze({
      ...node2,
      where: node2.where ? WhereNode.cloneWithOperation(node2.where, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithJoin(node2, join) {
    return freeze({
      ...node2,
      joins: node2.joins ? freeze([...node2.joins, join]) : freeze([join])
    });
  },
  cloneWithReturning(node2, selections) {
    return freeze({
      ...node2,
      returning: node2.returning ? ReturningNode.cloneWithSelections(node2.returning, selections) : ReturningNode.create(selections)
    });
  },
  cloneWithoutReturning(node2) {
    return freeze({
      ...node2,
      returning: void 0
    });
  },
  cloneWithoutWhere(node2) {
    return freeze({
      ...node2,
      where: void 0
    });
  },
  cloneWithExplain(node2, format2, options) {
    return freeze({
      ...node2,
      explain: ExplainNode.create(format2, options?.toOperationNode())
    });
  },
  cloneWithTop(node2, top) {
    return freeze({
      ...node2,
      top
    });
  },
  cloneWithOutput(node2, selections) {
    return freeze({
      ...node2,
      output: node2.output ? OutputNode.cloneWithSelections(node2.output, selections) : OutputNode.create(selections)
    });
  },
  cloneWithOrderByItems(node2, items2) {
    return freeze({
      ...node2,
      orderBy: node2.orderBy ? OrderByNode.cloneWithItems(node2.orderBy, items2) : OrderByNode.create(items2)
    });
  },
  cloneWithoutOrderBy(node2) {
    return freeze({
      ...node2,
      orderBy: void 0
    });
  }
});
const SelectQueryNode = freeze({
  is(node2) {
    return node2.kind === "SelectQueryNode";
  },
  create(withNode) {
    return freeze({
      kind: "SelectQueryNode",
      ...withNode && { with: withNode }
    });
  },
  createFrom(fromItems, withNode) {
    return freeze({
      kind: "SelectQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithSelections(select, selections) {
    return freeze({
      ...select,
      selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
    });
  },
  cloneWithDistinctOn(select, expressions) {
    return freeze({
      ...select,
      distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
    });
  },
  cloneWithFrontModifier(select, modifier) {
    return freeze({
      ...select,
      frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithOrderByItems: (node2, items2) => QueryNode.cloneWithOrderByItems(node2, items2),
  cloneWithGroupByItems(selectNode, items2) {
    return freeze({
      ...selectNode,
      groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items2) : GroupByNode.create(items2)
    });
  },
  cloneWithLimit(selectNode, limit2) {
    return freeze({
      ...selectNode,
      limit: limit2
    });
  },
  cloneWithOffset(selectNode, offset) {
    return freeze({
      ...selectNode,
      offset
    });
  },
  cloneWithFetch(selectNode, fetch) {
    return freeze({
      ...selectNode,
      fetch
    });
  },
  cloneWithHaving(selectNode, operation) {
    return freeze({
      ...selectNode,
      having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
    });
  },
  cloneWithSetOperations(selectNode, setOperations) {
    return freeze({
      ...selectNode,
      setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
    });
  },
  cloneWithoutSelections(select) {
    return freeze({
      ...select,
      selections: []
    });
  },
  cloneWithoutLimit(select) {
    return freeze({
      ...select,
      limit: void 0
    });
  },
  cloneWithoutOffset(select) {
    return freeze({
      ...select,
      offset: void 0
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithoutOrderBy: (node2) => QueryNode.cloneWithoutOrderBy(node2),
  cloneWithoutGroupBy(select) {
    return freeze({
      ...select,
      groupBy: void 0
    });
  }
});
class JoinBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(...args) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Just like {@link WhereInterface.whereRef} but adds an item to the join's
   * `on` clause instead.
   *
   * See {@link WhereInterface.whereRef} for documentation and examples.
   */
  onRef(lhs, op, rhs) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds `on true`.
   */
  onTrue() {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.joinNode;
  }
}
const PartitionByItemNode = freeze({
  is(node2) {
    return node2.kind === "PartitionByItemNode";
  },
  create(partitionBy) {
    return freeze({
      kind: "PartitionByItemNode",
      partitionBy
    });
  }
});
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}
class OverBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  orderBy(...args) {
    return new OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new OverBuilder({
      overNode: QueryNode.cloneWithoutOrderBy(this.#props.overNode)
    });
  }
  partitionBy(partitionBy) {
    return new OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.overNode;
  }
}
const SelectionNode = freeze({
  is(node2) {
    return node2.kind === "SelectionNode";
  },
  create(selection) {
    return freeze({
      kind: "SelectionNode",
      selection
    });
  },
  createSelectAll() {
    return freeze({
      kind: "SelectionNode",
      selection: SelectAllNode.create()
    });
  },
  createSelectAllFromTable(table) {
    return freeze({
      kind: "SelectionNode",
      selection: ReferenceNode.createSelectAll(table)
    });
  }
});
function parseSelectArg(selection) {
  if (isFunction(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}
const ValuesNode = freeze({
  is(node2) {
    return node2.kind === "ValuesNode";
  },
  create(values2) {
    return freeze({
      kind: "ValuesNode",
      values: freeze(values2)
    });
  }
});
const DefaultInsertValueNode = freeze({
  is(node2) {
    return node2.kind === "DefaultInsertValueNode";
  },
  create() {
    return freeze({
      kind: "DefaultInsertValueNode"
    });
  }
});
function parseInsertExpression(arg) {
  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== void 0) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}
const ColumnUpdateNode = freeze({
  is(node2) {
    return node2.kind === "ColumnUpdateNode";
  },
  create(column, value) {
    return freeze({
      kind: "ColumnUpdateNode",
      column,
      value
    });
  }
});
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== void 0).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}
const OnDuplicateKeyNode = freeze({
  is(node2) {
    return node2.kind === "OnDuplicateKeyNode";
  },
  create(updates) {
    return freeze({
      kind: "OnDuplicateKeyNode",
      updates
    });
  }
});
class InsertResult {
  /**
   * The auto incrementing primary key of the inserted row.
   *
   * This property can be undefined when the query contains an `on conflict`
   * clause that makes the query succeed even when nothing gets inserted.
   *
   * This property is always undefined on dialects like PostgreSQL that
   * don't return the inserted id by default. On those dialects you need
   * to use the {@link ReturningInterface.returning | returning} method.
   */
  insertId;
  /**
   * Affected rows count.
   */
  numInsertedOrUpdatedRows;
  constructor(insertId, numInsertedOrUpdatedRows) {
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
}
class NoResultError extends Error {
  /**
   * The operation node tree of the query that was executed.
   */
  node;
  constructor(node2) {
    super("no result");
    this.node = node2;
  }
}
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}
const OnConflictNode = freeze({
  is(node2) {
    return node2.kind === "OnConflictNode";
  },
  create() {
    return freeze({
      kind: "OnConflictNode"
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  },
  cloneWithIndexWhere(node2, operation) {
    return freeze({
      ...node2,
      indexWhere: node2.indexWhere ? WhereNode.cloneWithOperation(node2.indexWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithIndexOrWhere(node2, operation) {
    return freeze({
      ...node2,
      indexWhere: node2.indexWhere ? WhereNode.cloneWithOperation(node2.indexWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateWhere(node2, operation) {
    return freeze({
      ...node2,
      updateWhere: node2.updateWhere ? WhereNode.cloneWithOperation(node2.updateWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateOrWhere(node2, operation) {
    return freeze({
      ...node2,
      updateWhere: node2.updateWhere ? WhereNode.cloneWithOperation(node2.updateWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithoutIndexWhere(node2) {
    return freeze({
      ...node2,
      indexWhere: void 0
    });
  },
  cloneWithoutUpdateWhere(node2) {
    return freeze({
      ...node2,
      updateWhere: void 0
    });
  }
});
class OnConflictBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specify a single column as the conflict target.
   *
   * Also see the {@link columns}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  /**
   * Specify a list of columns as the conflict target.
   *
   * Also see the {@link column}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  /**
   * Specify a specific constraint by name as the conflict target.
   *
   * Also see the {@link column}, {@link columns} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  constraint(constraintName) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  /**
   * Specify an expression as the conflict target.
   *
   * This can be used if the unique index is an expression index.
   *
   * Also see the {@link column}, {@link columns} and {@link constraint}
   * methods for alternative ways to specify the conflict target.
   */
  expression(expression) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Adds the "do nothing" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({ first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id") do nothing
   * ```
   */
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        doNothing: true
      })
    });
  }
  /**
   * Adds the "do update set" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({ first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doUpdateSet({ first_name })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id")
   * do update set "first_name" = $3
   * ```
   *
   * In the next example we use the `ref` method to reference
   * columns of the virtual table `excluded` in a type-safe way
   * to create an upsert operation:
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function upsertPerson(person: NewPerson): Promise<void> {
   *   await db.insertInto('person')
   *     .values(person)
   *     .onConflict((oc) => oc
   *       .column('id')
   *       .doUpdateSet((eb) => ({
   *         first_name: eb.ref('excluded.first_name'),
   *         last_name: eb.ref('excluded.last_name')
   *       })
   *     )
   *   )
   *   .execute()
   * }
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name")
   * values ($1, $2)
   * on conflict ("id")
   * do update set
   *  "first_name" = excluded."first_name",
   *  "last_name" = excluded."last_name"
   * ```
   */
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
}
class OnConflictDoNothingBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}
class OnConflictUpdateBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Specify a where condition for the update operation.
   *
   * See {@link WhereInterface.whereRef} for more info.
   */
  whereRef(lhs, op, rhs) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}
const TopNode = freeze({
  is(node2) {
    return node2.kind === "TopNode";
  },
  create(expression, modifiers) {
    return freeze({
      kind: "TopNode",
      expression,
      modifiers
    });
  }
});
function parseTop(expression, modifiers) {
  if (!isNumber(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}
const OrActionNode = freeze({
  is(node2) {
    return node2.kind === "OrActionNode";
  },
  create(action) {
    return freeze({
      kind: "OrActionNode",
      action
    });
  }
});
class InsertQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
   *
   * This method takes an object whose keys are column names and values are
   * values to insert. In addition to the column's type, the values can be
   * raw {@link sql} snippets or select queries.
   *
   * You must provide all fields you haven't explicitly marked as nullable
   * or optional using {@link Generated} or {@link ColumnType}.
   *
   * The return value of an `insert` query is an instance of {@link InsertResult}. The
   * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
   * key if the database returned one.
   *
   * On PostgreSQL and some other dialects, you need to call `returning` to get
   * something out of the query.
   *
   * Also see the {@link expression} method for inserting the result of a select
   * query or any other expression.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Single row", 10) -->
   *
   * Insert a single row:
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40
   *   })
   *   .executeTakeFirst()
   *
   * // `insertId` is only available on dialects that
   * // automatically return the id of the inserted row
   * // such as MySQL and SQLite. On PostgreSQL, for example,
   * // you need to add a `returning` clause to the query to
   * // get anything out. See the "returning data" example.
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
   * ```
   *
   * <!-- siteExample("insert", "Multiple rows", 20) -->
   *
   * On dialects that support it (for example PostgreSQL) you can insert multiple
   * rows by providing an array. Note that the return value is once again very
   * dialect-specific. Some databases may only return the id of the *last* inserted
   * row and some return nothing at all unless you call `returning`.
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values([{
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   }, {
   *     first_name: 'Arnold',
   *     last_name: 'Schwarzenegger',
   *     age: 70,
   *   }])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
   * ```
   *
   * <!-- siteExample("insert", "Returning data", 30) -->
   *
   * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
   * the inserted row's columns (or any other expression) as the return value. `returning`
   * works just like `select`. Refer to `select` method's examples and documentation for
   * more info.
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   })
   *   .returning(['id', 'first_name as name'])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
   * ```
   *
   * <!-- siteExample("insert", "Complex values", 40) -->
   *
   * In addition to primitives, the values can also be arbitrary expressions.
   * You can build the expressions by using a callback and calling the methods
   * on the expression builder passed to it:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const ani = "Ani"
   * const ston = "ston"
   *
   * const result = await db
   *   .insertInto('person')
   *   .values(({ ref, selectFrom, fn }) => ({
   *     first_name: 'Jennifer',
   *     last_name: sql<string>`concat(${ani}, ${ston})`,
   *     middle_name: ref('first_name'),
   *     age: selectFrom('person')
   *       .select(fn.avg<number>('age').as('avg_age')),
   *   }))
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" (
   *   "first_name",
   *   "last_name",
   *   "middle_name",
   *   "age"
   * )
   * values (
   *   $1,
   *   concat($2, $3),
   *   "first_name",
   *   (select avg("age") as "avg_age" from "person")
   * )
   * ```
   *
   * You can also use the callback version of subqueries or raw expressions:
   *
   * ```ts
   * await db.with('jennifer', (db) => db
   *   .selectFrom('person')
   *   .where('first_name', '=', 'Jennifer')
   *   .select(['id', 'first_name', 'gender'])
   *   .limit(1)
   * ).insertInto('pet').values((eb) => ({
   *   owner_id: eb.selectFrom('jennifer').select('id'),
   *   name: eb.selectFrom('jennifer').select('first_name'),
   *   species: 'cat',
   * }))
   * .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * with "jennifer" as (
   *   select "id", "first_name", "gender"
   *   from "person"
   *   where "first_name" = $1
   *   limit $2
   * )
   * insert into "pet" ("owner_id", "name", "species")
   * values (
   *  (select "id" from "jennifer"),
   *  (select "first_name" from "jennifer"),
   *  $3
   * )
   * ```
   */
  values(insert) {
    const [columns, values2] = parseInsertExpression(insert);
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns,
        values: values2
      })
    });
  }
  /**
   * Sets the columns to insert.
   *
   * The {@link values} method sets both the columns and the values and this method
   * is not needed. But if you are using the {@link expression} method, you can use
   * this method to set the columns to insert.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .columns(['first_name'])
   *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name")
   * select "pet"."name" from "pet"
   * ```
   */
  columns(columns) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  /**
   * Insert an arbitrary expression. For example the result of a select query.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Insert subquery", 50) -->
   *
   * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
   * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
   * remember. The reasons for this design stem from implementation difficulties.
   *
   * ```ts
   * const result = await db.insertInto('person')
   *   .columns(['first_name', 'last_name', 'age'])
   *   .expression((eb) => eb
   *     .selectFrom('pet')
   *     .select((eb) => [
   *       'pet.name',
   *       eb.val('Petson').as('last_name'),
   *       eb.lit(7).as('age'),
   *     ])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age")
   * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
   * ```
   */
  expression(expression) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  /**
   * Creates an `insert into "person" default values` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .defaultValues()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" default values
   * ```
   */
  defaultValues() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        defaultValues: true
      })
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` ("first_name", "last_name", "gender")
   * values (?, ?, ?) -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes an `insert into` query to an `insert ignore into` query.
   *
   * This is only supported by some dialects like MySQL.
   *
   * To avoid a footgun, when invoked with the SQLite dialect, this method will
   * be handled like {@link orIgnore}. See also, {@link orAbort}, {@link orFail},
   * {@link orReplace}, and {@link orRollback}.
   *
   * If you use the ignore modifier, ignorable errors that occur while executing the
   * insert statement are ignored. For example, without ignore, a row that duplicates
   * an existing unique index or primary key value in the table causes a duplicate-key
   * error and the statement is aborted. With ignore, the row is discarded and no error
   * occurs.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .ignore()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert ignore into `person` (`first_name`, `last_name`, `gender`) values (?, ?, ?)
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or ignore into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  ignore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or ignore into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * To avoid a footgun, when invoked with the MySQL dialect, this method will
   * be handled like {@link ignore}.
   *
   * See also, {@link orAbort}, {@link orFail}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orIgnore()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or ignore into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert ignore into `person` (`first_name`, `last_name`, `gender`) values (?, ?, ?)
   * ```
   */
  orIgnore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or abort into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orFail}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orAbort()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or abort into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orAbort() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("abort")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or fail into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orFail()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or fail into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orFail() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("fail")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or replace into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * You can also use {@link Kysely.replaceInto} to achieve the same result.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orFail}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orReplace()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or replace into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orReplace() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("replace")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or rollback into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orFail}, and {@link orReplace}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orRollback()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or rollback into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orRollback() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("rollback")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Insert the first 5 rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(5)
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   *
   * Insert the first 50 percent of rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(50, 'percent')
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   */
  top(expression, modifiers) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds an `on conflict` clause to the query.
   *
   * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
   * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * ```
   *
   * You can provide the name of the constraint instead of a column name:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .constraint('pet_name_key')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict on constraint "pet_name_key"
   * do update set "species" = $4
   * ```
   *
   * You can also specify an expression as the conflict target in case
   * the unique index is an expression index:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .expression(sql<string>`lower(name)`)
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict (lower(name))
   * do update set "species" = $4
   * ```
   *
   * You can add a filter for the update statement like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *     .where('excluded.name', '!=', 'Catto')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * where "excluded"."name" != $5
   * ```
   *
   * You can create an `on conflict do nothing` clauses like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name") do nothing
   * ```
   *
   * You can refer to the columns of the virtual `excluded` table
   * in a type-safe way using a callback and the `ref` method of
   * `ExpressionBuilder`:
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onConflict(oc => oc
   *     .column('id')
   *     .doUpdateSet({
   *       first_name: (eb) => eb.ref('excluded.first_name'),
   *       last_name: (eb) => eb.ref('excluded.last_name')
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("id", "first_name", "last_name", "gender")
   * values ($1, $2, $3, $4)
   * on conflict ("id")
   * do update set
   *  "first_name" = "excluded"."first_name",
   *  "last_name" = "excluded"."last_name"
   * ```
   */
  onConflict(callback) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  /**
   * Adds `on duplicate key update` to the query.
   *
   * If you specify `on duplicate key update`, and a row is inserted that would cause
   * a duplicate value in a unique index or primary key, an update of the old row occurs.
   *
   * This is only implemented by some dialects like MySQL. On most dialects you should
   * use {@link onConflict} instead.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onDuplicateKeyUpdate({ updated_at: new Date().toISOString() })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`id`, `first_name`, `last_name`, `gender`)
   * values (?, ?, ?, ?)
   * on duplicate key update `updated_at` = ?
   * ```
   */
  onDuplicateKeyUpdate(update) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({ first_name: 'James', last_name: 'Smith', gender: 'male' })
   *   .returning(['first_name'])
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "gender") values ($1, $2, $3)
   * ```
   */
  clearReturning() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.insertInto('person')
   *   .values({ first_name: 'John', last_name: 'Doe', gender: 'male' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function insertPerson(values: NewPerson, returnLastName: boolean) {
   *   return await db
   *     .insertInto('person')
   *     .values(values)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `insertPerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new InsertQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `InsertQueryBuilder` with a new output type.
   */
  $castTo() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link values} input
   * when using {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson, NewPet, Species } from 'type-editor' // imaginary module
   *
   * async function insertPersonAndPet(person: NewPerson, pet: Omit<NewPet, 'owner_id'>) {
   *   return await db
   *     .with('new_person', (qb) => qb
   *       .insertInto('person')
   *       .values(person)
   *       .returning('id')
   *       .$assertType<{ id: number }>()
   *     )
   *     .with('new_pet', (qb) => qb
   *       .insertInto('pet')
   *       .values((eb) => ({
   *         owner_id: eb.selectFrom('new_person').select('id'),
   *         ...pet
   *       }))
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['new_person', 'new_pet'])
   *     .selectAll()
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   */
  $assertType() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new InsertQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new InsertResult(result.insertId, result.numAffectedRows ?? BigInt(0))
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
class DeleteResult {
  numDeletedRows;
  constructor(numDeletedRows) {
    this.numDeletedRows = numDeletedRows;
  }
}
const LimitNode = freeze({
  is(node2) {
    return node2.kind === "LimitNode";
  },
  create(limit2) {
    return freeze({
      kind: "LimitNode",
      limit: limit2
    });
  }
});
class DeleteQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes a `delete from` query into a `delete top from` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Delete the first 5 rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(5)
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(5) from "person" where "age" > @1
   * ```
   *
   * Delete the first 50% of rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(50, 'percent')
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(50) percent from "person" where "age" > @1
   * ```
   */
  top(expression, modifiers) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  returning(selection) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max"
   * ```
   */
  clearReturning() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Clears the `limit` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .limit(5)
   *   .clearLimit()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearLimit() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  orderBy(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  /**
   * Adds a limit clause to the query.
   *
   * A limit clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `pet` order by `created_at` limit ?
   * ```
   */
  limit(limit2) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit2)))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.deleteFrom('person')
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `person`
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.deleteFrom('person')
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function deletePerson(id: number, returnLastName: boolean) {
   *   return await db
   *     .deleteFrom('person')
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `deletePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new DeleteQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `DeleteQueryBuilder` with a new output type.
   */
  $castTo() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { Species } from 'type-editor' // imaginary module
   *
   * async function deletePersonAndPets(personId: number) {
   *   return await db
   *     .with('deleted_person', (qb) => qb
   *        .deleteFrom('person')
   *        .where('id', '=', personId)
   *        .returning('first_name')
   *        .$assertType<{ first_name: string }>()
   *     )
   *     .with('deleted_pets', (qb) => qb
   *       .deleteFrom('pet')
   *       .where('owner_id', '=', personId)
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['deleted_person', 'deleted_pets'])
   *     .selectAll()
   *     .execute()
   * }
   * ```
   */
  $assertType() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new DeleteQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new DeleteResult(result.numAffectedRows ?? BigInt(0))];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
class UpdateResult {
  /**
   * The number of rows the update query updated (even if not changed).
   */
  numUpdatedRows;
  /**
   * The number of rows the update query changed.
   *
   * This is **optional** and only supported in dialects such as MySQL.
   * You would probably use {@link numUpdatedRows} in most cases.
   */
  numChangedRows;
  constructor(numUpdatedRows, numChangedRows) {
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
}
class UpdateQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes an `update` query into a `update top` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Update the first row:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(1)
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(1) "person" set "first_name" = @1 where "age" > @2
   * ```
   *
   * Update the 50% first rows:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(50, 'percent')
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(50) percent "person" set "first_name" = @1 where "age" > @2
   * ```
   */
  top(expression, modifiers) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  /**
   * Adds a limit clause to the update query for supported databases, such as MySQL.
   *
   * ### Examples
   *
   * Update the first 2 rows in the 'person' table:
   *
   * ```ts
   * await db
   *   .updateTable('person')
   *   .set({ first_name: 'Foo' })
   *   .limit(2)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person` set `first_name` = ? limit ?
   * ```
   */
  limit(limit2) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit2)))
    });
  }
  set(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.updateTable('person')
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql.raw('-- This is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person`
   * set `age` = 39
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.updateTable('person')
   *   .returningAll()
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * update "person" set "age" = 39 where "first_name" = "John"
   * ```
   */
  clearReturning() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * const values = {
   *   first_name: 'John',
   * } satisfies PersonUpdate
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new UpdateQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `UpdateQueryBuilder` with a new output type.
   */
  $castTo() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link set} input
   * when using {@link where} and/or {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ deleted_at: Date; nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate, PetUpdate, Species } from 'type-editor' // imaginary module
   *
   * const person = {
   *   id: 1,
   *   gender: 'other',
   * } satisfies PersonUpdate
   *
   * const pet = {
   *   name: 'Fluffy',
   * } satisfies PetUpdate
   *
   * const result = await db
   *   .with('updated_person', (qb) => qb
   *     .updateTable('person')
   *     .set(person)
   *     .where('id', '=', person.id)
   *     .returning('first_name')
   *     .$assertType<{ first_name: string }>()
   *   )
   *   .with('updated_pet', (qb) => qb
   *     .updateTable('pet')
   *     .set(pet)
   *     .where('owner_id', '=', person.id)
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['updated_person', 'updated_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new UpdateQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new UpdateResult(result.numAffectedRows ?? BigInt(0), result.numChangedRows)
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
const CommonTableExpressionNameNode = freeze({
  is(node2) {
    return node2.kind === "CommonTableExpressionNameNode";
  },
  create(tableName, columnNames) {
    return freeze({
      kind: "CommonTableExpressionNameNode",
      table: TableNode.create(tableName),
      columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0
    });
  }
});
const CommonTableExpressionNode = freeze({
  is(node2) {
    return node2.kind === "CommonTableExpressionNode";
  },
  create(name, expression) {
    return freeze({
      kind: "CommonTableExpressionNode",
      name,
      expression
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  }
});
class CTEBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the common table expression materialized.
   */
  materialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Makes the common table expression not materialized.
   */
  notMaterialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}
const WithNode = freeze({
  is(node2) {
    return node2.kind === "WithNode";
  },
  create(expression, params) {
    return freeze({
      kind: "WithNode",
      expressions: freeze([expression]),
      ...params
    });
  },
  cloneWithExpression(withNode, expression) {
    return freeze({
      ...withNode,
      expressions: freeze([...withNode.expressions, expression])
    });
  }
});
const CHARS = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
function randomString(length) {
  let chars = "";
  for (let i = 0; i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}
function createQueryId() {
  return new LazyQueryId();
}
class LazyQueryId {
  #queryId;
  get queryId() {
    if (this.#queryId === void 0) {
      this.#queryId = randomString(8);
    }
    return this.#queryId;
  }
}
function requireAllProps(obj) {
  return obj;
}
class OperationNodeTransformer {
  nodeStack = [];
  #transformers = freeze({
    AliasNode: this.transformAlias.bind(this),
    ColumnNode: this.transformColumn.bind(this),
    IdentifierNode: this.transformIdentifier.bind(this),
    SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
    RawNode: this.transformRaw.bind(this),
    ReferenceNode: this.transformReference.bind(this),
    SelectQueryNode: this.transformSelectQuery.bind(this),
    SelectionNode: this.transformSelection.bind(this),
    TableNode: this.transformTable.bind(this),
    FromNode: this.transformFrom.bind(this),
    SelectAllNode: this.transformSelectAll.bind(this),
    AndNode: this.transformAnd.bind(this),
    OrNode: this.transformOr.bind(this),
    ValueNode: this.transformValue.bind(this),
    ValueListNode: this.transformValueList.bind(this),
    PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
    ParensNode: this.transformParens.bind(this),
    JoinNode: this.transformJoin.bind(this),
    OperatorNode: this.transformOperator.bind(this),
    WhereNode: this.transformWhere.bind(this),
    InsertQueryNode: this.transformInsertQuery.bind(this),
    DeleteQueryNode: this.transformDeleteQuery.bind(this),
    ReturningNode: this.transformReturning.bind(this),
    CreateTableNode: this.transformCreateTable.bind(this),
    AddColumnNode: this.transformAddColumn.bind(this),
    ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
    DropTableNode: this.transformDropTable.bind(this),
    DataTypeNode: this.transformDataType.bind(this),
    OrderByNode: this.transformOrderBy.bind(this),
    OrderByItemNode: this.transformOrderByItem.bind(this),
    GroupByNode: this.transformGroupBy.bind(this),
    GroupByItemNode: this.transformGroupByItem.bind(this),
    UpdateQueryNode: this.transformUpdateQuery.bind(this),
    ColumnUpdateNode: this.transformColumnUpdate.bind(this),
    LimitNode: this.transformLimit.bind(this),
    OffsetNode: this.transformOffset.bind(this),
    OnConflictNode: this.transformOnConflict.bind(this),
    OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
    CreateIndexNode: this.transformCreateIndex.bind(this),
    DropIndexNode: this.transformDropIndex.bind(this),
    ListNode: this.transformList.bind(this),
    PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
    ReferencesNode: this.transformReferences.bind(this),
    CheckConstraintNode: this.transformCheckConstraint.bind(this),
    WithNode: this.transformWith.bind(this),
    CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
    HavingNode: this.transformHaving.bind(this),
    CreateSchemaNode: this.transformCreateSchema.bind(this),
    DropSchemaNode: this.transformDropSchema.bind(this),
    AlterTableNode: this.transformAlterTable.bind(this),
    DropColumnNode: this.transformDropColumn.bind(this),
    RenameColumnNode: this.transformRenameColumn.bind(this),
    AlterColumnNode: this.transformAlterColumn.bind(this),
    ModifyColumnNode: this.transformModifyColumn.bind(this),
    AddConstraintNode: this.transformAddConstraint.bind(this),
    DropConstraintNode: this.transformDropConstraint.bind(this),
    RenameConstraintNode: this.transformRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
    CreateViewNode: this.transformCreateView.bind(this),
    RefreshMaterializedViewNode: this.transformRefreshMaterializedView.bind(this),
    DropViewNode: this.transformDropView.bind(this),
    GeneratedNode: this.transformGenerated.bind(this),
    DefaultValueNode: this.transformDefaultValue.bind(this),
    OnNode: this.transformOn.bind(this),
    ValuesNode: this.transformValues.bind(this),
    SelectModifierNode: this.transformSelectModifier.bind(this),
    CreateTypeNode: this.transformCreateType.bind(this),
    DropTypeNode: this.transformDropType.bind(this),
    ExplainNode: this.transformExplain.bind(this),
    DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.transformAggregateFunction.bind(this),
    OverNode: this.transformOver.bind(this),
    PartitionByNode: this.transformPartitionBy.bind(this),
    PartitionByItemNode: this.transformPartitionByItem.bind(this),
    SetOperationNode: this.transformSetOperation.bind(this),
    BinaryOperationNode: this.transformBinaryOperation.bind(this),
    UnaryOperationNode: this.transformUnaryOperation.bind(this),
    UsingNode: this.transformUsing.bind(this),
    FunctionNode: this.transformFunction.bind(this),
    CaseNode: this.transformCase.bind(this),
    WhenNode: this.transformWhen.bind(this),
    JSONReferenceNode: this.transformJSONReference.bind(this),
    JSONPathNode: this.transformJSONPath.bind(this),
    JSONPathLegNode: this.transformJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
    TupleNode: this.transformTuple.bind(this),
    MergeQueryNode: this.transformMergeQuery.bind(this),
    MatchedNode: this.transformMatched.bind(this),
    AddIndexNode: this.transformAddIndex.bind(this),
    CastNode: this.transformCast.bind(this),
    FetchNode: this.transformFetch.bind(this),
    TopNode: this.transformTop.bind(this),
    OutputNode: this.transformOutput.bind(this),
    OrActionNode: this.transformOrAction.bind(this),
    CollateNode: this.transformCollate.bind(this)
  });
  transformNode(node2, queryId) {
    if (!node2) {
      return node2;
    }
    this.nodeStack.push(node2);
    const out = this.transformNodeImpl(node2, queryId);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node2, queryId) {
    return this.#transformers[node2.kind](node2, queryId);
  }
  transformNodeList(list, queryId) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node2) => this.transformNode(node2, queryId)));
  }
  transformSelectQuery(node2, queryId) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node2.from, queryId),
      selections: this.transformNodeList(node2.selections, queryId),
      distinctOn: this.transformNodeList(node2.distinctOn, queryId),
      joins: this.transformNodeList(node2.joins, queryId),
      groupBy: this.transformNode(node2.groupBy, queryId),
      orderBy: this.transformNode(node2.orderBy, queryId),
      where: this.transformNode(node2.where, queryId),
      frontModifiers: this.transformNodeList(node2.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      limit: this.transformNode(node2.limit, queryId),
      offset: this.transformNode(node2.offset, queryId),
      with: this.transformNode(node2.with, queryId),
      having: this.transformNode(node2.having, queryId),
      explain: this.transformNode(node2.explain, queryId),
      setOperations: this.transformNodeList(node2.setOperations, queryId),
      fetch: this.transformNode(node2.fetch, queryId),
      top: this.transformNode(node2.top, queryId)
    });
  }
  transformSelection(node2, queryId) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node2.selection, queryId)
    });
  }
  transformColumn(node2, queryId) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node2.column, queryId)
    });
  }
  transformAlias(node2, queryId) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node2.node, queryId),
      alias: this.transformNode(node2.alias, queryId)
    });
  }
  transformTable(node2, queryId) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node2.table, queryId)
    });
  }
  transformFrom(node2, queryId) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node2.froms, queryId)
    });
  }
  transformReference(node2, queryId) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node2.column, queryId),
      table: this.transformNode(node2.table, queryId)
    });
  }
  transformAnd(node2, queryId) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node2.left, queryId),
      right: this.transformNode(node2.right, queryId)
    });
  }
  transformOr(node2, queryId) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node2.left, queryId),
      right: this.transformNode(node2.right, queryId)
    });
  }
  transformValueList(node2, queryId) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node2.values, queryId)
    });
  }
  transformParens(node2, queryId) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node2.node, queryId)
    });
  }
  transformJoin(node2, queryId) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node2.joinType,
      table: this.transformNode(node2.table, queryId),
      on: this.transformNode(node2.on, queryId)
    });
  }
  transformRaw(node2, queryId) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node2.sqlFragments]),
      parameters: this.transformNodeList(node2.parameters, queryId)
    });
  }
  transformWhere(node2, queryId) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node2.where, queryId)
    });
  }
  transformInsertQuery(node2, queryId) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node2.into, queryId),
      columns: this.transformNodeList(node2.columns, queryId),
      values: this.transformNode(node2.values, queryId),
      returning: this.transformNode(node2.returning, queryId),
      onConflict: this.transformNode(node2.onConflict, queryId),
      onDuplicateKey: this.transformNode(node2.onDuplicateKey, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      with: this.transformNode(node2.with, queryId),
      ignore: node2.ignore,
      orAction: this.transformNode(node2.orAction, queryId),
      replace: node2.replace,
      explain: this.transformNode(node2.explain, queryId),
      defaultValues: node2.defaultValues,
      top: this.transformNode(node2.top, queryId),
      output: this.transformNode(node2.output, queryId)
    });
  }
  transformValues(node2, queryId) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node2.values, queryId)
    });
  }
  transformDeleteQuery(node2, queryId) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node2.from, queryId),
      using: this.transformNode(node2.using, queryId),
      joins: this.transformNodeList(node2.joins, queryId),
      where: this.transformNode(node2.where, queryId),
      returning: this.transformNode(node2.returning, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      with: this.transformNode(node2.with, queryId),
      orderBy: this.transformNode(node2.orderBy, queryId),
      limit: this.transformNode(node2.limit, queryId),
      explain: this.transformNode(node2.explain, queryId),
      top: this.transformNode(node2.top, queryId),
      output: this.transformNode(node2.output, queryId)
    });
  }
  transformReturning(node2, queryId) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node2.selections, queryId)
    });
  }
  transformCreateTable(node2, queryId) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node2.table, queryId),
      columns: this.transformNodeList(node2.columns, queryId),
      constraints: this.transformNodeList(node2.constraints, queryId),
      temporary: node2.temporary,
      ifNotExists: node2.ifNotExists,
      onCommit: node2.onCommit,
      frontModifiers: this.transformNodeList(node2.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      selectQuery: this.transformNode(node2.selectQuery, queryId)
    });
  }
  transformColumnDefinition(node2, queryId) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node2.column, queryId),
      dataType: this.transformNode(node2.dataType, queryId),
      references: this.transformNode(node2.references, queryId),
      primaryKey: node2.primaryKey,
      autoIncrement: node2.autoIncrement,
      unique: node2.unique,
      notNull: node2.notNull,
      unsigned: node2.unsigned,
      defaultTo: this.transformNode(node2.defaultTo, queryId),
      check: this.transformNode(node2.check, queryId),
      generated: this.transformNode(node2.generated, queryId),
      frontModifiers: this.transformNodeList(node2.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      nullsNotDistinct: node2.nullsNotDistinct,
      identity: node2.identity,
      ifNotExists: node2.ifNotExists
    });
  }
  transformAddColumn(node2, queryId) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node2.column, queryId)
    });
  }
  transformDropTable(node2, queryId) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node2.table, queryId),
      ifExists: node2.ifExists,
      cascade: node2.cascade
    });
  }
  transformOrderBy(node2, queryId) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node2.items, queryId)
    });
  }
  transformOrderByItem(node2, queryId) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node2.orderBy, queryId),
      direction: this.transformNode(node2.direction, queryId),
      collation: this.transformNode(node2.collation, queryId),
      nulls: node2.nulls
    });
  }
  transformGroupBy(node2, queryId) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node2.items, queryId)
    });
  }
  transformGroupByItem(node2, queryId) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node2.groupBy, queryId)
    });
  }
  transformUpdateQuery(node2, queryId) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node2.table, queryId),
      from: this.transformNode(node2.from, queryId),
      joins: this.transformNodeList(node2.joins, queryId),
      where: this.transformNode(node2.where, queryId),
      updates: this.transformNodeList(node2.updates, queryId),
      returning: this.transformNode(node2.returning, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      with: this.transformNode(node2.with, queryId),
      explain: this.transformNode(node2.explain, queryId),
      limit: this.transformNode(node2.limit, queryId),
      top: this.transformNode(node2.top, queryId),
      output: this.transformNode(node2.output, queryId),
      orderBy: this.transformNode(node2.orderBy, queryId)
    });
  }
  transformColumnUpdate(node2, queryId) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node2.column, queryId),
      value: this.transformNode(node2.value, queryId)
    });
  }
  transformLimit(node2, queryId) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node2.limit, queryId)
    });
  }
  transformOffset(node2, queryId) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node2.offset, queryId)
    });
  }
  transformOnConflict(node2, queryId) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node2.columns, queryId),
      constraint: this.transformNode(node2.constraint, queryId),
      indexExpression: this.transformNode(node2.indexExpression, queryId),
      indexWhere: this.transformNode(node2.indexWhere, queryId),
      updates: this.transformNodeList(node2.updates, queryId),
      updateWhere: this.transformNode(node2.updateWhere, queryId),
      doNothing: node2.doNothing
    });
  }
  transformOnDuplicateKey(node2, queryId) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node2.updates, queryId)
    });
  }
  transformCreateIndex(node2, queryId) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node2.name, queryId),
      table: this.transformNode(node2.table, queryId),
      columns: this.transformNodeList(node2.columns, queryId),
      unique: node2.unique,
      using: this.transformNode(node2.using, queryId),
      ifNotExists: node2.ifNotExists,
      where: this.transformNode(node2.where, queryId),
      nullsNotDistinct: node2.nullsNotDistinct
    });
  }
  transformList(node2, queryId) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node2.items, queryId)
    });
  }
  transformDropIndex(node2, queryId) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node2.name, queryId),
      table: this.transformNode(node2.table, queryId),
      ifExists: node2.ifExists,
      cascade: node2.cascade
    });
  }
  transformPrimaryKeyConstraint(node2, queryId) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node2.columns, queryId),
      name: this.transformNode(node2.name, queryId),
      deferrable: node2.deferrable,
      initiallyDeferred: node2.initiallyDeferred
    });
  }
  transformUniqueConstraint(node2, queryId) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node2.columns, queryId),
      name: this.transformNode(node2.name, queryId),
      nullsNotDistinct: node2.nullsNotDistinct,
      deferrable: node2.deferrable,
      initiallyDeferred: node2.initiallyDeferred
    });
  }
  transformForeignKeyConstraint(node2, queryId) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node2.columns, queryId),
      references: this.transformNode(node2.references, queryId),
      name: this.transformNode(node2.name, queryId),
      onDelete: node2.onDelete,
      onUpdate: node2.onUpdate,
      deferrable: node2.deferrable,
      initiallyDeferred: node2.initiallyDeferred
    });
  }
  transformSetOperation(node2, queryId) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node2.operator,
      expression: this.transformNode(node2.expression, queryId),
      all: node2.all
    });
  }
  transformReferences(node2, queryId) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node2.table, queryId),
      columns: this.transformNodeList(node2.columns, queryId),
      onDelete: node2.onDelete,
      onUpdate: node2.onUpdate
    });
  }
  transformCheckConstraint(node2, queryId) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node2.expression, queryId),
      name: this.transformNode(node2.name, queryId)
    });
  }
  transformWith(node2, queryId) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node2.expressions, queryId),
      recursive: node2.recursive
    });
  }
  transformCommonTableExpression(node2, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node2.name, queryId),
      materialized: node2.materialized,
      expression: this.transformNode(node2.expression, queryId)
    });
  }
  transformCommonTableExpressionName(node2, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node2.table, queryId),
      columns: this.transformNodeList(node2.columns, queryId)
    });
  }
  transformHaving(node2, queryId) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node2.having, queryId)
    });
  }
  transformCreateSchema(node2, queryId) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node2.schema, queryId),
      ifNotExists: node2.ifNotExists
    });
  }
  transformDropSchema(node2, queryId) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node2.schema, queryId),
      ifExists: node2.ifExists,
      cascade: node2.cascade
    });
  }
  transformAlterTable(node2, queryId) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node2.table, queryId),
      renameTo: this.transformNode(node2.renameTo, queryId),
      setSchema: this.transformNode(node2.setSchema, queryId),
      columnAlterations: this.transformNodeList(node2.columnAlterations, queryId),
      addConstraint: this.transformNode(node2.addConstraint, queryId),
      dropConstraint: this.transformNode(node2.dropConstraint, queryId),
      renameConstraint: this.transformNode(node2.renameConstraint, queryId),
      addIndex: this.transformNode(node2.addIndex, queryId),
      dropIndex: this.transformNode(node2.dropIndex, queryId)
    });
  }
  transformDropColumn(node2, queryId) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node2.column, queryId)
    });
  }
  transformRenameColumn(node2, queryId) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node2.column, queryId),
      renameTo: this.transformNode(node2.renameTo, queryId)
    });
  }
  transformAlterColumn(node2, queryId) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node2.column, queryId),
      dataType: this.transformNode(node2.dataType, queryId),
      dataTypeExpression: this.transformNode(node2.dataTypeExpression, queryId),
      setDefault: this.transformNode(node2.setDefault, queryId),
      dropDefault: node2.dropDefault,
      setNotNull: node2.setNotNull,
      dropNotNull: node2.dropNotNull
    });
  }
  transformModifyColumn(node2, queryId) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node2.column, queryId)
    });
  }
  transformAddConstraint(node2, queryId) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node2.constraint, queryId)
    });
  }
  transformDropConstraint(node2, queryId) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node2.constraintName, queryId),
      ifExists: node2.ifExists,
      modifier: node2.modifier
    });
  }
  transformRenameConstraint(node2, queryId) {
    return requireAllProps({
      kind: "RenameConstraintNode",
      oldName: this.transformNode(node2.oldName, queryId),
      newName: this.transformNode(node2.newName, queryId)
    });
  }
  transformCreateView(node2, queryId) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node2.name, queryId),
      temporary: node2.temporary,
      orReplace: node2.orReplace,
      ifNotExists: node2.ifNotExists,
      materialized: node2.materialized,
      columns: this.transformNodeList(node2.columns, queryId),
      as: this.transformNode(node2.as, queryId)
    });
  }
  transformRefreshMaterializedView(node2, queryId) {
    return requireAllProps({
      kind: "RefreshMaterializedViewNode",
      name: this.transformNode(node2.name, queryId),
      concurrently: node2.concurrently,
      withNoData: node2.withNoData
    });
  }
  transformDropView(node2, queryId) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node2.name, queryId),
      ifExists: node2.ifExists,
      materialized: node2.materialized,
      cascade: node2.cascade
    });
  }
  transformGenerated(node2, queryId) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node2.byDefault,
      always: node2.always,
      identity: node2.identity,
      stored: node2.stored,
      expression: this.transformNode(node2.expression, queryId)
    });
  }
  transformDefaultValue(node2, queryId) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node2.defaultValue, queryId)
    });
  }
  transformOn(node2, queryId) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node2.on, queryId)
    });
  }
  transformSelectModifier(node2, queryId) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node2.modifier,
      rawModifier: this.transformNode(node2.rawModifier, queryId),
      of: this.transformNodeList(node2.of, queryId)
    });
  }
  transformCreateType(node2, queryId) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node2.name, queryId),
      enum: this.transformNode(node2.enum, queryId)
    });
  }
  transformDropType(node2, queryId) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node2.name, queryId),
      ifExists: node2.ifExists
    });
  }
  transformExplain(node2, queryId) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node2.format,
      options: this.transformNode(node2.options, queryId)
    });
  }
  transformSchemableIdentifier(node2, queryId) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node2.schema, queryId),
      identifier: this.transformNode(node2.identifier, queryId)
    });
  }
  transformAggregateFunction(node2, queryId) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      func: node2.func,
      aggregated: this.transformNodeList(node2.aggregated, queryId),
      distinct: node2.distinct,
      orderBy: this.transformNode(node2.orderBy, queryId),
      withinGroup: this.transformNode(node2.withinGroup, queryId),
      filter: this.transformNode(node2.filter, queryId),
      over: this.transformNode(node2.over, queryId)
    });
  }
  transformOver(node2, queryId) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node2.orderBy, queryId),
      partitionBy: this.transformNode(node2.partitionBy, queryId)
    });
  }
  transformPartitionBy(node2, queryId) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node2.items, queryId)
    });
  }
  transformPartitionByItem(node2, queryId) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node2.partitionBy, queryId)
    });
  }
  transformBinaryOperation(node2, queryId) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node2.leftOperand, queryId),
      operator: this.transformNode(node2.operator, queryId),
      rightOperand: this.transformNode(node2.rightOperand, queryId)
    });
  }
  transformUnaryOperation(node2, queryId) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node2.operator, queryId),
      operand: this.transformNode(node2.operand, queryId)
    });
  }
  transformUsing(node2, queryId) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node2.tables, queryId)
    });
  }
  transformFunction(node2, queryId) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node2.func,
      arguments: this.transformNodeList(node2.arguments, queryId)
    });
  }
  transformCase(node2, queryId) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node2.value, queryId),
      when: this.transformNodeList(node2.when, queryId),
      else: this.transformNode(node2.else, queryId),
      isStatement: node2.isStatement
    });
  }
  transformWhen(node2, queryId) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node2.condition, queryId),
      result: this.transformNode(node2.result, queryId)
    });
  }
  transformJSONReference(node2, queryId) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node2.reference, queryId),
      traversal: this.transformNode(node2.traversal, queryId)
    });
  }
  transformJSONPath(node2, queryId) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node2.inOperator, queryId),
      pathLegs: this.transformNodeList(node2.pathLegs, queryId)
    });
  }
  transformJSONPathLeg(node2, _queryId) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node2.type,
      value: node2.value
    });
  }
  transformJSONOperatorChain(node2, queryId) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node2.operator, queryId),
      values: this.transformNodeList(node2.values, queryId)
    });
  }
  transformTuple(node2, queryId) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node2.values, queryId)
    });
  }
  transformMergeQuery(node2, queryId) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node2.into, queryId),
      using: this.transformNode(node2.using, queryId),
      whens: this.transformNodeList(node2.whens, queryId),
      with: this.transformNode(node2.with, queryId),
      top: this.transformNode(node2.top, queryId),
      endModifiers: this.transformNodeList(node2.endModifiers, queryId),
      output: this.transformNode(node2.output, queryId),
      returning: this.transformNode(node2.returning, queryId)
    });
  }
  transformMatched(node2, _queryId) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node2.not,
      bySource: node2.bySource
    });
  }
  transformAddIndex(node2, queryId) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node2.name, queryId),
      columns: this.transformNodeList(node2.columns, queryId),
      unique: node2.unique,
      using: this.transformNode(node2.using, queryId),
      ifNotExists: node2.ifNotExists
    });
  }
  transformCast(node2, queryId) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node2.expression, queryId),
      dataType: this.transformNode(node2.dataType, queryId)
    });
  }
  transformFetch(node2, queryId) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node2.rowCount, queryId),
      modifier: node2.modifier
    });
  }
  transformTop(node2, _queryId) {
    return requireAllProps({
      kind: "TopNode",
      expression: node2.expression,
      modifiers: node2.modifiers
    });
  }
  transformOutput(node2, queryId) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node2.selections, queryId)
    });
  }
  transformDataType(node2, _queryId) {
    return node2;
  }
  transformSelectAll(node2, _queryId) {
    return node2;
  }
  transformIdentifier(node2, _queryId) {
    return node2;
  }
  transformValue(node2, _queryId) {
    return node2;
  }
  transformPrimitiveValueList(node2, _queryId) {
    return node2;
  }
  transformOperator(node2, _queryId) {
    return node2;
  }
  transformDefaultInsertValue(node2, _queryId) {
    return node2;
  }
  transformOrAction(node2, _queryId) {
    return node2;
  }
  transformCollate(node2, _queryId) {
    return node2;
  }
}
const ROOT_OPERATION_NODES = freeze({
  AlterTableNode: true,
  CreateIndexNode: true,
  CreateSchemaNode: true,
  CreateTableNode: true,
  CreateTypeNode: true,
  CreateViewNode: true,
  RefreshMaterializedViewNode: true,
  DeleteQueryNode: true,
  DropIndexNode: true,
  DropSchemaNode: true,
  DropTableNode: true,
  DropTypeNode: true,
  DropViewNode: true,
  InsertQueryNode: true,
  RawNode: true,
  SelectQueryNode: true,
  UpdateQueryNode: true,
  MergeQueryNode: true
});
const SCHEMALESS_FUNCTIONS = {
  json_agg: true,
  to_json: true
};
class WithSchemaTransformer extends OperationNodeTransformer {
  #schema;
  #schemableIds = /* @__PURE__ */ new Set();
  #ctes = /* @__PURE__ */ new Set();
  constructor(schema) {
    super();
    this.#schema = schema;
  }
  transformNodeImpl(node2, queryId) {
    if (!this.#isRootOperationNode(node2)) {
      return super.transformNodeImpl(node2, queryId);
    }
    const ctes = this.#collectCTEs(node2);
    for (const cte of ctes) {
      this.#ctes.add(cte);
    }
    const tables = this.#collectSchemableIds(node2);
    for (const table of tables) {
      this.#schemableIds.add(table);
    }
    const transformed = super.transformNodeImpl(node2, queryId);
    for (const table of tables) {
      this.#schemableIds.delete(table);
    }
    for (const cte of ctes) {
      this.#ctes.delete(cte);
    }
    return transformed;
  }
  transformSchemableIdentifier(node2, queryId) {
    const transformed = super.transformSchemableIdentifier(node2, queryId);
    if (transformed.schema || !this.#schemableIds.has(node2.identifier.name)) {
      return transformed;
    }
    return {
      ...transformed,
      schema: IdentifierNode.create(this.#schema)
    };
  }
  transformReferences(node2, queryId) {
    const transformed = super.transformReferences(node2, queryId);
    if (transformed.table.table.schema) {
      return transformed;
    }
    return {
      ...transformed,
      table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
    };
  }
  transformAggregateFunction(node2, queryId) {
    return {
      ...super.transformAggregateFunction({ ...node2, aggregated: [] }, queryId),
      aggregated: this.#transformTableArgsWithoutSchemas(node2, queryId, "aggregated")
    };
  }
  transformFunction(node2, queryId) {
    return {
      ...super.transformFunction({ ...node2, arguments: [] }, queryId),
      arguments: this.#transformTableArgsWithoutSchemas(node2, queryId, "arguments")
    };
  }
  transformSelectModifier(node2, queryId) {
    return {
      ...super.transformSelectModifier({ ...node2, of: void 0 }, queryId),
      of: node2.of?.map((item) => TableNode.is(item) && !item.table.schema ? {
        ...item,
        table: this.transformIdentifier(item.table.identifier, queryId)
      } : this.transformNode(item, queryId))
    };
  }
  #transformTableArgsWithoutSchemas(node2, queryId, argsKey) {
    return SCHEMALESS_FUNCTIONS[node2.func] ? node2[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg, queryId) : {
      ...arg,
      table: this.transformIdentifier(arg.table.identifier, queryId)
    }) : this.transformNodeList(node2[argsKey], queryId);
  }
  #isRootOperationNode(node2) {
    return node2.kind in ROOT_OPERATION_NODES;
  }
  #collectSchemableIds(node2) {
    const schemableIds = /* @__PURE__ */ new Set();
    if ("name" in node2 && node2.name && SchemableIdentifierNode.is(node2.name)) {
      this.#collectSchemableId(node2.name, schemableIds);
    }
    if ("from" in node2 && node2.from) {
      for (const from of node2.from.froms) {
        this.#collectSchemableIdsFromTableExpr(from, schemableIds);
      }
    }
    if ("into" in node2 && node2.into) {
      this.#collectSchemableIdsFromTableExpr(node2.into, schemableIds);
    }
    if ("table" in node2 && node2.table) {
      this.#collectSchemableIdsFromTableExpr(node2.table, schemableIds);
    }
    if ("joins" in node2 && node2.joins) {
      for (const join of node2.joins) {
        this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
      }
    }
    if ("using" in node2 && node2.using) {
      if (JoinNode.is(node2.using)) {
        this.#collectSchemableIdsFromTableExpr(node2.using.table, schemableIds);
      } else {
        this.#collectSchemableIdsFromTableExpr(node2.using, schemableIds);
      }
    }
    return schemableIds;
  }
  #collectCTEs(node2) {
    const ctes = /* @__PURE__ */ new Set();
    if ("with" in node2 && node2.with) {
      this.#collectCTEIds(node2.with, ctes);
    }
    return ctes;
  }
  #collectSchemableIdsFromTableExpr(node2, schemableIds) {
    if (TableNode.is(node2)) {
      return this.#collectSchemableId(node2.table, schemableIds);
    }
    if (AliasNode.is(node2) && TableNode.is(node2.node)) {
      return this.#collectSchemableId(node2.node.table, schemableIds);
    }
    if (ListNode.is(node2)) {
      for (const table of node2.items) {
        this.#collectSchemableIdsFromTableExpr(table, schemableIds);
      }
      return;
    }
    if (UsingNode.is(node2)) {
      for (const table of node2.tables) {
        this.#collectSchemableIdsFromTableExpr(table, schemableIds);
      }
      return;
    }
  }
  #collectSchemableId(node2, schemableIds) {
    const id2 = node2.identifier.name;
    if (!this.#schemableIds.has(id2) && !this.#ctes.has(id2)) {
      schemableIds.add(id2);
    }
  }
  #collectCTEIds(node2, ctes) {
    for (const expr of node2.expressions) {
      const cteId = expr.name.table.table.identifier.name;
      if (!this.#ctes.has(cteId)) {
        ctes.add(cteId);
      }
    }
  }
}
class WithSchemaPlugin {
  #transformer;
  constructor(schema) {
    this.#transformer = new WithSchemaTransformer(schema);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    return args.result;
  }
}
const MatchedNode = freeze({
  is(node2) {
    return node2.kind === "MatchedNode";
  },
  create(not2, bySource = false) {
    return freeze({
      kind: "MatchedNode",
      not: not2,
      bySource
    });
  }
});
function parseMergeWhen(type2, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type2.isMatched, type2.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}
class Deferred {
  #promise;
  #resolve;
  #reject;
  constructor() {
    this.#promise = new Promise((resolve2, reject) => {
      this.#reject = reject;
      this.#resolve = resolve2;
    });
  }
  get promise() {
    return this.#promise;
  }
  resolve = (value) => {
    if (this.#resolve) {
      this.#resolve(value);
    }
  };
  reject = (reason) => {
    if (this.#reject) {
      this.#reject(reason);
    }
  };
}
async function provideControlledConnection(connectionProvider) {
  const connectionDefer = new Deferred();
  const connectionReleaseDefer = new Deferred();
  connectionProvider.provideConnection(async (connection) => {
    connectionDefer.resolve(connection);
    return await connectionReleaseDefer.promise;
  }).catch((ex) => connectionDefer.reject(ex));
  return freeze({
    connection: await connectionDefer.promise,
    release: connectionReleaseDefer.resolve
  });
}
const NO_PLUGINS = freeze([]);
class QueryExecutorBase {
  #plugins;
  constructor(plugins = NO_PLUGINS) {
    this.#plugins = plugins;
  }
  get plugins() {
    return this.#plugins;
  }
  transformQuery(node2, queryId) {
    for (const plugin2 of this.#plugins) {
      const transformedNode = plugin2.transformQuery({ node: node2, queryId });
      if (transformedNode.kind === node2.kind) {
        node2 = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node2.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node2;
  }
  async executeQuery(compiledQuery) {
    return await this.provideConnection(async (connection) => {
      const result = await connection.executeQuery(compiledQuery);
      if ("numUpdatedOrDeletedRows" in result) {
        logOnce("kysely:warning: outdated driver/plugin detected! `QueryResult.numUpdatedOrDeletedRows` has been replaced with `QueryResult.numAffectedRows`.");
      }
      return await this.#transformResult(result, compiledQuery.queryId);
    });
  }
  async *stream(compiledQuery, chunkSize) {
    const { connection, release } = await provideControlledConnection(this);
    try {
      for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
        yield await this.#transformResult(result, compiledQuery.queryId);
      }
    } finally {
      release();
    }
  }
  async #transformResult(result, queryId) {
    for (const plugin2 of this.#plugins) {
      result = await plugin2.transformResult({ result, queryId });
    }
    return result;
  }
}
class NoopQueryExecutor extends QueryExecutorBase {
  get adapter() {
    throw new Error("this query cannot be compiled to SQL");
  }
  compileQuery() {
    throw new Error("this query cannot be compiled to SQL");
  }
  provideConnection() {
    throw new Error("this query cannot be executed");
  }
  withConnectionProvider() {
    throw new Error("this query cannot have a connection provider");
  }
  withPlugin(plugin2) {
    return new NoopQueryExecutor([...this.plugins, plugin2]);
  }
  withPlugins(plugins) {
    return new NoopQueryExecutor([...this.plugins, ...plugins]);
  }
  withPluginAtFront(plugin2) {
    return new NoopQueryExecutor([plugin2, ...this.plugins]);
  }
  withoutPlugins() {
    return new NoopQueryExecutor([]);
  }
}
const NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();
class MergeResult {
  numChangedRows;
  constructor(numChangedRows) {
    this.numChangedRows = numChangedRows;
  }
}
class MergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes a `merge into` query to an `merge top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Affect 5 matched rows at most:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(5)
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(5) into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   *
   * Affect 50% of matched rows:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(50, 'percent')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(50) percent into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  top(expression, modifiers) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
    });
  }
  returning(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
}
class WheneableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * See {@link MergeQueryBuilder.top}.
   */
  top(expression, modifiers) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds a simple `when matched` clause to the query.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * For a simple `when not matched` clause, see {@link whenNotMatched}.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  whenMatched() {
    return this.#whenMatched([]);
  }
  whenMatchedAnd(...args) {
    return this.#whenMatched(args);
  }
  /**
   * Adds the `when matched` clause to the query with an `and` condition. But unlike
   * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenMatchedAndRef(lhs, op, rhs) {
    return this.#whenMatched([lhs, op, rhs], true);
  }
  #whenMatched(args, refRight) {
    return new MatchedThenableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
    });
  }
  /**
   * Adds a simple `when not matched` clause to the query.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * For a simple `when matched` clause, see {@link whenMatched}.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenInsertValues({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   insert ("first_name", "last_name") values ($1, $2)
   * ```
   */
  whenNotMatched() {
    return this.#whenNotMatched([]);
  }
  whenNotMatchedAnd(...args) {
    return this.#whenNotMatched(args);
  }
  /**
   * Adds the `when not matched` clause to the query with an `and` condition. But unlike
   * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenNotMatchedAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true);
  }
  /**
   * Adds a simple `when not matched by source` clause to the query.
   *
   * Supported in MS SQL Server.
   *
   * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySource() {
    return this.#whenNotMatched([], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return this.#whenNotMatched(args, false, true);
  }
  /**
   * Adds the `when not matched by source` clause to the query with an `and` condition.
   *
   * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
   * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true, true);
  }
  returning(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  #whenNotMatched(args, refRight = false, bySource = false) {
    const props = {
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
    };
    const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
    return new Builder(props);
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.updateTable('person')
   *   .set({ first_name: 'John' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new WheneableMergeQueryBuilder({
      ...this.#props
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new MergeResult(result.numAffectedRows)];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
}
class MatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `delete` action.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
    });
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  /**
   * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
   * This is handy when multiple `set` invocations are needed.
   *
   * For a shorthand version of this method, see {@link thenUpdateSet}.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenUpdate((ub) => ub
   *     .set(sql`metadata['has_pets']`, 'Y')
   *     .set({
   *       updated_at: new Date().toISOString(),
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   update set metadata['has_pets'] = $1, "updated_at" = $2
   * ```
   */
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: this.#props.queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
}
class NotMatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `insert` action, see {@link thenInsertValues}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values2] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values: values2
      })))
    });
  }
}
class QueryCreator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Creates a `select` query builder for the given table or tables.
   *
   * The tables passed to this method are built as the query's `from` clause.
   *
   * ### Examples
   *
   * Create a select query for one table:
   *
   * ```ts
   * db.selectFrom('person').selectAll()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "person"
   * ```
   *
   * Create a select query for one table with an alias:
   *
   * ```ts
   * const persons = await db.selectFrom('person as p')
   *   .select(['p.id', 'first_name'])
   *   .execute()
   *
   * console.log(persons[0].id)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."id", "first_name" from "person" as "p"
   * ```
   *
   * Create a select query from a subquery:
   *
   * ```ts
   * const persons = await db.selectFrom(
   *     (eb) => eb.selectFrom('person').select('person.id as identifier').as('p')
   *   )
   *   .select('p.identifier')
   *   .execute()
   *
   * console.log(persons[0].identifier)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."identifier",
   * from (
   *   select "person"."id" as "identifier" from "person"
   * ) as p
   * ```
   *
   * Create a select query from raw sql:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const items = await db
   *   .selectFrom(sql<{ one: number }>`(select 1 as one)`.as('q'))
   *   .select('q.one')
   *   .execute()
   *
   * console.log(items[0].one)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "q"."one",
   * from (
   *   select 1 as one
   * ) as q
   * ```
   *
   * When you use the `sql` tag you need to also provide the result type of the
   * raw snippet / query so that Kysely can figure out what columns are
   * available for the rest of the query.
   *
   * The `selectFrom` method also accepts an array for multiple tables. All
   * the above examples can also be used in an array.
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const items = await db.selectFrom([
   *     'person as p',
   *     db.selectFrom('pet').select('pet.species').as('a'),
   *     sql<{ one: number }>`(select 1 as one)`.as('q')
   *   ])
   *   .select(['p.id', 'a.species', 'q.one'])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p".id, "a"."species", "q"."one"
   * from
   *   "person" as "p",
   *   (select "pet"."species" from "pet") as a,
   *   (select 1 as one) as "q"
   * ```
   */
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
    });
  }
  /**
   * Creates an insert query.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
   * the {@link ReturningInterface.returning | returning} method for a way to return columns
   * on supported databases like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   *
   * Some databases like PostgreSQL support the `returning` method:
   *
   * ```ts
   * const { id } = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .returning('id')
   *   .executeTakeFirstOrThrow()
   * ```
   */
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
    });
  }
  /**
   * Creates a "replace into" query.
   *
   * This is only supported by some dialects like MySQL or SQLite.
   *
   * Similar to MySQL's {@link InsertQueryBuilder.onDuplicateKeyUpdate} that deletes
   * and inserts values on collision instead of updating existing rows.
   *
   * An alias of SQLite's {@link InsertQueryBuilder.orReplace}.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .replaceInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirstOrThrow()
   *
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * replace into `person` (`first_name`, `last_name`) values (?, ?)
   * ```
   */
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
    });
  }
  /**
   * Creates a delete query.
   *
   * See the {@link DeleteQueryBuilder.where} method for examples on how to specify
   * a where clause for the delete operation.
   *
   * The return value of the query is an instance of {@link DeleteResult}.
   *
   * ### Examples
   *
   * <!-- siteExample("delete", "Single row", 10) -->
   *
   * Delete a single row:
   *
   * ```ts
   * const result = await db
   *   .deleteFrom('person')
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   *
   * console.log(result.numDeletedRows)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * delete from "person" where "person"."id" = $1
   * ```
   *
   * Some databases such as MySQL support deleting from multiple tables:
   *
   * ```ts
   * const result = await db
   *   .deleteFrom(['person', 'pet'])
   *   .using('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `person`, `pet`
   * using `person`
   * inner join `pet` on `pet`.`owner_id` = `person`.`id`
   * where `person`.`id` = ?
   * ```
   */
  deleteFrom(from) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  /**
   * Creates an update query.
   *
   * See the {@link UpdateQueryBuilder.where} method for examples on how to specify
   * a where clause for the update operation.
   *
   * See the {@link UpdateQueryBuilder.set} method for examples on how to
   * specify the updates.
   *
   * The return value of the query is an {@link UpdateResult}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .updateTable('person')
   *   .set({ first_name: 'Jennifer' })
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   *
   * console.log(result.numUpdatedRows)
   * ```
   */
  updateTable(tables) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: UpdateQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
    });
  }
  /**
   * Creates a merge query.
   *
   * The return value of the query is a {@link MergeResult}.
   *
   * See the {@link MergeQueryBuilder.using} method for examples on how to specify
   * the other table.
   *
   * ### Examples
   *
   * <!-- siteExample("merge", "Source row existence", 10) -->
   *
   * Update a target column based on the existence of a source row:
   *
   * ```ts
   * const result = await db
   *   .mergeInto('person as target')
   *   .using('pet as source', 'source.owner_id', 'target.id')
   *   .whenMatchedAnd('target.has_pets', '!=', 'Y')
   *   .thenUpdateSet({ has_pets: 'Y' })
   *   .whenNotMatchedBySourceAnd('target.has_pets', '=', 'Y')
   *   .thenUpdateSet({ has_pets: 'N' })
   *   .executeTakeFirstOrThrow()
   *
   * console.log(result.numChangedRows)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet"
   * on "pet"."owner_id" = "person"."id"
   * when matched and "has_pets" != $1
   * then update set "has_pets" = $2
   * when not matched by source and "has_pets" = $3
   * then update set "has_pets" = $4
   * ```
   *
   * <!-- siteExample("merge", "Temporary changes table", 20) -->
   *
   * Merge new entries from a temporary changes table:
   *
   * ```ts
   * const result = await db
   *   .mergeInto('wine as target')
   *   .using(
   *     'wine_stock_change as source',
   *     'source.wine_name',
   *     'target.name',
   *   )
   *   .whenNotMatchedAnd('source.stock_delta', '>', 0)
   *   .thenInsertValues(({ ref }) => ({
   *     name: ref('source.wine_name'),
   *     stock: ref('source.stock_delta'),
   *   }))
   *   .whenMatchedAnd(
   *     (eb) => eb('target.stock', '+', eb.ref('source.stock_delta')),
   *     '>',
   *     0,
   *   )
   *   .thenUpdateSet('stock', (eb) =>
   *     eb('target.stock', '+', eb.ref('source.stock_delta')),
   *   )
   *   .whenMatched()
   *   .thenDelete()
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "wine" as "target"
   * using "wine_stock_change" as "source"
   * on "source"."wine_name" = "target"."name"
   * when not matched and "source"."stock_delta" > $1
   * then insert ("name", "stock") values ("source"."wine_name", "source"."stock_delta")
   * when matched and "target"."stock" + "source"."stock_delta" > $2
   * then update set "stock" = "target"."stock" + "source"."stock_delta"
   * when matched
   * then delete
   * ```
   */
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
    });
  }
  /**
   * Creates a `with` query (Common Table Expression).
   *
   * ### Examples
   *
   * <!-- siteExample("cte", "Simple selects", 10) -->
   *
   * Common table expressions (CTE) are a great way to modularize complex queries.
   * Essentially they allow you to run multiple separate queries within a
   * single roundtrip to the DB.
   *
   * Since CTEs are a part of the main query, query optimizers inside DB
   * engines are able to optimize the overall query. For example, postgres
   * is able to inline the CTEs inside the using queries if it decides it's
   * faster.
   *
   * ```ts
   * const result = await db
   *   // Create a CTE called `jennifers` that selects all
   *   // persons named 'Jennifer'.
   *   .with('jennifers', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     .select(['id', 'age'])
   *   )
   *   // Select all rows from the `jennifers` CTE and
   *   // further filter it.
   *   .with('adult_jennifers', (db) => db
   *     .selectFrom('jennifers')
   *     .where('age', '>', 18)
   *     .select(['id', 'age'])
   *   )
   *   // Finally select all adult jennifers that are
   *   // also younger than 60.
   *   .selectFrom('adult_jennifers')
   *   .where('age', '<', 60)
   *   .selectAll()
   *   .execute()
   * ```
   *
   * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
   *
   * Some databases like postgres also allow you to run other queries than selects
   * in CTEs. On these databases CTEs are extremely powerful:
   *
   * ```ts
   * const result = await db
   *   .with('new_person', (db) => db
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       age: 35,
   *     })
   *     .returning('id')
   *   )
   *   .with('new_pet', (db) => db
   *     .insertInto('pet')
   *     .values({
   *       name: 'Doggo',
   *       species: 'dog',
   *       is_favorite: true,
   *       // Use the id of the person we just inserted.
   *       owner_id: db
   *         .selectFrom('new_person')
   *         .select('id')
   *     })
   *     .returning('id')
   *   )
   *   .selectFrom(['new_person', 'new_pet'])
   *   .select([
   *     'new_person.id as person_id',
   *     'new_pet.id as pet_id'
   *   ])
   *   .execute()
   * ```
   *
   * The CTE name can optionally specify column names in addition to
   * a name. In that case Kysely requires the expression to retun
   * rows with the same columns.
   *
   * ```ts
   * await db
   *   .with('jennifers(id, age)', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     // This is ok since we return columns with the same
   *     // names as specified by `jennifers(id, age)`.
   *     .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   *
   * The first argument can also be a callback. The callback is passed
   * a `CTEBuilder` instance that can be used to configure the CTE:
   *
   * ```ts
   * await db
   *   .with(
   *     (cte) => cte('jennifers').materialized(),
   *     (db) => db
   *       .selectFrom('person')
   *       .where('first_name', '=', 'Jennifer')
   *       .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   */
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
    });
  }
  /**
   * Creates a recursive `with` query (Common Table Expression).
   *
   * Note that recursiveness is a property of the whole `with` statement.
   * You cannot have recursive and non-recursive CTEs in a same `with` statement.
   * Therefore the recursiveness is determined by the **first** `with` or
   * `withRecusive` call you make.
   *
   * See the {@link with} method for examples and more documentation.
   */
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  /**
   * Returns a copy of this query creator instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  /**
   * Returns a copy of this query creator instance without any plugins.
   */
  withoutPlugins() {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * Sets the schema to be used for all table references that don't explicitly
   * specify a schema.
   *
   * This only affects the query created through the builder returned from
   * this method and doesn't modify the `db` instance.
   *
   * See [this recipe](https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md)
   * for a more detailed explanation.
   *
   * ### Examples
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet')
   *   .selectAll()
   *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "mammals"."pet"
   * inner join "public"."person"
   * on "public"."person"."id" = "mammals"."pet"."owner_id"
   * ```
   *
   * `withSchema` is smart enough to not add schema for aliases,
   * common table expressions or other places where the schema
   * doesn't belong to:
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet as p')
   *   .select('p.name')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."name" from "mammals"."pet" as "p"
   * ```
   */
  withSchema(schema) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
}
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else if (args.length === 1) {
    return parseOnlessJoin(joinType, args[0]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}
function parseOnlessJoin(joinType, from) {
  return JoinNode.create(joinType, parseTableExpression(from));
}
const OffsetNode = freeze({
  is(node2) {
    return node2.kind === "OffsetNode";
  },
  create(offset) {
    return freeze({
      kind: "OffsetNode",
      offset
    });
  }
});
const GroupByItemNode = freeze({
  is(node2) {
    return node2.kind === "GroupByItemNode";
  },
  create(groupBy) {
    return freeze({
      kind: "GroupByItemNode",
      groupBy
    });
  }
});
function parseGroupBy(groupBy) {
  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}
const SetOperationNode = freeze({
  is(node2) {
    return node2.kind === "SetOperationNode";
  },
  create(operator, expression, all) {
    return freeze({
      kind: "SetOperationNode",
      operator,
      expression,
      all
    });
  }
});
function parseSetOperations(operator, expression, all) {
  if (isFunction(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));
}
class ExpressionWrapper {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `ExpressionWrapper` with a new output type.
   */
  $castTo() {
    return new ExpressionWrapper(this.#node);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new ExpressionWrapper(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}
class AliasedExpressionWrapper {
  #expr;
  #alias;
  constructor(expr, alias) {
    this.#expr = expr;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#expr;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
class OrWrapper {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `OrWrapper` with a new output type.
   */
  $castTo() {
    return new OrWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}
class AndWrapper {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AndWrapper` with a new output type.
   */
  $castTo() {
    return new AndWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}
const FetchNode = freeze({
  is(node2) {
    return node2.kind === "FetchNode";
  },
  create(rowCount, modifier) {
    return {
      kind: "FetchNode",
      rowCount: ValueNode.create(rowCount),
      modifier
    };
  }
});
function parseFetch(rowCount, modifier) {
  if (!isNumber(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}
class SelectQueryBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forKeyShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forNoKeyUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  skipLocked() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  crossJoin(...args) {
    return this.#join("CrossJoin", args);
  }
  innerJoinLateral(...args) {
    return this.#join("LateralInnerJoin", args);
  }
  leftJoinLateral(...args) {
    return this.#join("LateralLeftJoin", args);
  }
  crossJoinLateral(...args) {
    return this.#join("LateralCrossJoin", args);
  }
  crossApply(...args) {
    return this.#join("CrossApply", args);
  }
  outerApply(...args) {
    return this.#join("OuterApply", args);
  }
  #join(joinType, args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit2) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit2)))
    });
  }
  offset(offset) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias) {
    return new AliasedSelectQueryBuilderImpl(this, alias);
  }
  clearSelect() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
    });
  }
  clearWhere() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  clearOffset() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
    });
  }
  clearOrderBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  clearGroupBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new SelectQueryBuilderImpl({
      ...this.#props
    });
  }
  $castTo() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $narrowType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $assertType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  $asScalar() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin2) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery);
    return result.rows;
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}
class AliasedSelectQueryBuilderImpl {
  #queryBuilder;
  #alias;
  constructor(queryBuilder, alias) {
    this.#queryBuilder = queryBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#queryBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
const AggregateFunctionNode = freeze({
  is(node2) {
    return node2.kind === "AggregateFunctionNode";
  },
  create(aggregateFunction, aggregated = []) {
    return freeze({
      kind: "AggregateFunctionNode",
      func: aggregateFunction,
      aggregated
    });
  },
  cloneWithDistinct(aggregateFunctionNode) {
    return freeze({
      ...aggregateFunctionNode,
      distinct: true
    });
  },
  cloneWithOrderBy(aggregateFunctionNode, orderItems, withinGroup = false) {
    const prop = withinGroup ? "withinGroup" : "orderBy";
    return freeze({
      ...aggregateFunctionNode,
      [prop]: aggregateFunctionNode[prop] ? OrderByNode.cloneWithItems(aggregateFunctionNode[prop], orderItems) : OrderByNode.create(orderItems)
    });
  },
  cloneWithFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOrFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOver(aggregateFunctionNode, over) {
    return freeze({
      ...aggregateFunctionNode,
      over
    });
  }
});
const FunctionNode = freeze({
  is(node2) {
    return node2.kind === "FunctionNode";
  },
  create(func, args) {
    return freeze({
      kind: "FunctionNode",
      func,
      arguments: args
    });
  }
});
class AggregateFunctionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  /**
   * Returns an aliased version of the function.
   *
   * In addition to slapping `as "the_alias"` to the end of the SQL,
   * this method also provides strict typing:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.count<number>('id').as('person_count')
   *   )
   *   .executeTakeFirstOrThrow()
   *
   * // `person_count: number` field exists in the result type.
   * console.log(result.person_count)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count("id") as "person_count"
   * from "person"
   * ```
   */
  as(alias) {
    return new AliasedAggregateFunctionBuilder(this, alias);
  }
  /**
   * Adds a `distinct` clause inside the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) =>
   *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
   *   )
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count(distinct "first_name") as "first_name_count"
   * from "person"
   * ```
   */
  distinct() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
    });
  }
  orderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithOrderByItems(this.#props.aggregateFunctionNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithoutOrderBy(this.#props.aggregateFunctionNode)
    });
  }
  withinGroupOrderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy(args), true)
    });
  }
  filterWhere(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Adds a `filter` clause with a nested `where` clause after the function, where
   * both sides of the operator are references to columns.
   *
   * Similar to {@link WhereInterface}'s `whereRef` method.
   *
   * ### Examples
   *
   * Count people with same first and last names versus general public:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) => [
   *     eb.fn
   *       .count<number>('id')
   *       .filterWhereRef('first_name', '=', 'last_name')
   *       .as('repeat_name_count'),
   *     eb.fn.count<number>('id').as('total_count'),
   *   ])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select
   *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
   *   count("id") as "total_count"
   * from "person"
   * ```
   */
  filterWhereRef(lhs, op, rhs) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds an `over` clause (window functions) after the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over() as "average_age"
   * from "person"
   * ```
   *
   * Also supports passing a callback that returns an over builder,
   * allowing to add partition by and sort by clauses inside over.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
   * from "person"
   * ```
   */
  over(over) {
    const builder = createOverBuilder();
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  /**
   * Casts the expression to the given type.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AggregateFunctionBuilder` with a new output type.
   */
  $castTo() {
    return new AggregateFunctionBuilder(this.#props);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new AggregateFunctionBuilder(this.#props);
  }
  toOperationNode() {
    return this.#props.aggregateFunctionNode;
  }
}
class AliasedAggregateFunctionBuilder {
  #aggregateFunctionBuilder;
  #alias;
  constructor(aggregateFunctionBuilder, alias) {
    this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#aggregateFunctionBuilder;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
function createFunctionModule() {
  const fn = (name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
  };
  const agg = (name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : void 0)
    });
  };
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values2) {
      return fn("coalesce", values2);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}
const UnaryOperationNode = freeze({
  is(node2) {
    return node2.kind === "UnaryOperationNode";
  },
  create(operator, operand) {
    return freeze({
      kind: "UnaryOperationNode",
      operator,
      operand
    });
  }
});
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}
const CaseNode = freeze({
  is(node2) {
    return node2.kind === "CaseNode";
  },
  create(value) {
    return freeze({
      kind: "CaseNode",
      value
    });
  },
  cloneWithWhen(caseNode, when) {
    return freeze({
      ...caseNode,
      when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
    });
  },
  cloneWithThen(caseNode, then) {
    return freeze({
      ...caseNode,
      when: caseNode.when ? freeze([
        ...caseNode.when.slice(0, -1),
        WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
      ]) : void 0
    });
  },
  cloneWith(caseNode, props) {
    return freeze({
      ...caseNode,
      ...props
    });
  }
});
class CaseBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
}
class CaseThenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
}
class CaseWhenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...this.#props,
      node: CaseNode.cloneWith(this.#props.node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}
class CaseEndBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}
const JSONPathLegNode = freeze({
  is(node2) {
    return node2.kind === "JSONPathLegNode";
  },
  create(type2, value) {
    return freeze({
      kind: "JSONPathLegNode",
      type: type2,
      value
    });
  }
});
class JSONPathBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /**
   * Access an element of a JSON array in a specific location.
   *
   * Since there's no guarantee an element exists in the given array location, the
   * resulting type is always nullable. If you're sure the element exists, you
   * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
   *
   * See also {@link key} to access properties of JSON objects.
   *
   * ### Examples
   *
   * ```ts
   * await db.selectFrom('person')
   *   .select(eb =>
   *     eb.ref('nicknames', '->').at(0).as('primary_nickname')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "nicknames"->0 as "primary_nickname" from "person"
   *```
   *
   * Combined with {@link key}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('experience', '->').at(0).key('role').as('first_role')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "experience"->0->'role' as "first_role" from "person"
   * ```
   *
   * You can use `'last'` to access the last element of the array in MySQL:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `nicknames`->'$[last]' as `last_nickname` from `person`
   * ```
   *
   * Or `'#-1'` in SQLite:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
   * ```
   */
  at(index) {
    return this.#createBuilderWithPathLeg("ArrayLocation", index);
  }
  /**
   * Access a property of a JSON object.
   *
   * If a field is optional, the resulting type will be nullable.
   *
   * See also {@link at} to access elements of JSON arrays.
   *
   * ### Examples
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('address', '->').key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "address"->'city' as "city" from "person"
   * ```
   *
   * Going deeper:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `profile`->'$.website.url' as `website_url` from `person`
   * ```
   *
   * Combined with {@link at}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "profile"->'addresses'->0->'city' as "city" from "person"
   * ```
   */
  key(key) {
    return this.#createBuilderWithPathLeg("Member", key);
  }
  #createBuilderWithPathLeg(legType, value) {
    if (JSONReferenceNode.is(this.#node)) {
      return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
    }
    return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
  }
}
class TraversedJSONPathBuilder extends JSONPathBuilder {
  #node;
  constructor(node2) {
    super(node2);
    this.#node = node2;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedJSONPathBuilder(this, alias);
  }
  /**
   * Change the output type of the json path.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `JSONPathBuilder` with a new output type.
   */
  $castTo() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  $notNull() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}
class AliasedJSONPathBuilder {
  #jsonPath;
  #alias;
  constructor(jsonPath, alias) {
    this.#jsonPath = jsonPath;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#jsonPath;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
const TupleNode = freeze({
  is(node2) {
    return node2.kind === "TupleNode";
  },
  create(values2) {
    return freeze({
      kind: "TupleNode",
      values: freeze(values2)
    });
  }
});
const SIMPLE_COLUMN_DATA_TYPES = [
  "varchar",
  "char",
  "text",
  "integer",
  "int2",
  "int4",
  "int8",
  "smallint",
  "bigint",
  "boolean",
  "real",
  "double precision",
  "float4",
  "float8",
  "decimal",
  "numeric",
  "binary",
  "bytea",
  "date",
  "datetime",
  "time",
  "timetz",
  "timestamp",
  "timestamptz",
  "serial",
  "bigserial",
  "uuid",
  "json",
  "jsonb",
  "blob",
  "varbinary",
  "int4range",
  "int4multirange",
  "int8range",
  "int8multirange",
  "numrange",
  "nummultirange",
  "tsrange",
  "tsmultirange",
  "tstzrange",
  "tstzmultirange",
  "daterange",
  "datemultirange"
];
const COLUMN_DATA_TYPE_REGEX = [
  /^varchar\(\d+\)$/,
  /^char\(\d+\)$/,
  /^decimal\(\d+, \d+\)$/,
  /^numeric\(\d+, \d+\)$/,
  /^binary\(\d+\)$/,
  /^datetime\(\d+\)$/,
  /^time\(\d+\)$/,
  /^timetz\(\d+\)$/,
  /^timestamp\(\d+\)$/,
  /^timestamptz\(\d+\)$/,
  /^varbinary\(\d+\)$/
];
const DataTypeNode = freeze({
  is(node2) {
    return node2.kind === "DataTypeNode";
  },
  create(dataType2) {
    return freeze({
      kind: "DataTypeNode",
      dataType: dataType2
    });
  }
});
function isColumnDataType(dataType2) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType2)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType2))) {
    return true;
  }
  return false;
}
function parseDataTypeExpression(dataType2) {
  if (isOperationNodeSource(dataType2)) {
    return dataType2.toOperationNode();
  }
  if (isColumnDataType(dataType2)) {
    return DataTypeNode.create(dataType2);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType2)}`);
}
const CastNode = freeze({
  is(node2) {
    return node2.kind === "CastNode";
  },
  create(expression, dataType2) {
    return freeze({
      kind: "CastNode",
      expression,
      dataType: dataType2
    });
  }
});
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary, {
    fn: void 0,
    eb: void 0,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined(reference) ? void 0 : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values2) {
      return new ExpressionWrapper(TupleNode.create(values2.map(parseReferenceExpression)));
    },
    tuple(...values2) {
      return new ExpressionWrapper(TupleNode.create(values2.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node2 = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node2)) {
        return new ExpressionWrapper(node2);
      } else {
        return new ExpressionWrapper(ParensNode.create(node2));
      }
    },
    cast(expr, dataType2) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType2)));
    },
    withSchema(schema) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}
class DynamicTableBuilder {
  #table;
  get table() {
    return this.#table;
  }
  constructor(table) {
    this.#table = table;
  }
  as(alias) {
    return new AliasedDynamicTableBuilder(this.#table, alias);
  }
}
class AliasedDynamicTableBuilder {
  #table;
  #alias;
  get table() {
    return this.#table;
  }
  get alias() {
    return this.#alias;
  }
  constructor(table, alias) {
    this.#table = table;
    this.#alias = alias;
  }
  toOperationNode() {
    return AliasNode.create(parseTable(this.#table), IdentifierNode.create(this.#alias));
  }
}
function isAliasedDynamicTableBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.table) && isString(obj.alias);
}
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString(table)) {
    return parseAliasedTable(table);
  } else if (isAliasedDynamicTableBuilder(table)) {
    return table.toOperationNode();
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim$1);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim$1);
    return TableNode.createWithSchema(schema, table);
  } else {
    return TableNode.create(from);
  }
}
function trim$1(str) {
  return str.trim();
}
const AddColumnNode = freeze({
  is(node2) {
    return node2.kind === "AddColumnNode";
  },
  create(column) {
    return freeze({
      kind: "AddColumnNode",
      column
    });
  }
});
const ColumnDefinitionNode = freeze({
  is(node2) {
    return node2.kind === "ColumnDefinitionNode";
  },
  create(column, dataType2) {
    return freeze({
      kind: "ColumnDefinitionNode",
      column: ColumnNode.create(column),
      dataType: dataType2
    });
  },
  cloneWithFrontModifier(node2, modifier) {
    return freeze({
      ...node2,
      frontModifiers: node2.frontModifiers ? freeze([...node2.frontModifiers, modifier]) : [modifier]
    });
  },
  cloneWithEndModifier(node2, modifier) {
    return freeze({
      ...node2,
      endModifiers: node2.endModifiers ? freeze([...node2.endModifiers, modifier]) : [modifier]
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  }
});
const DropColumnNode = freeze({
  is(node2) {
    return node2.kind === "DropColumnNode";
  },
  create(column) {
    return freeze({
      kind: "DropColumnNode",
      column: ColumnNode.create(column)
    });
  }
});
const RenameColumnNode = freeze({
  is(node2) {
    return node2.kind === "RenameColumnNode";
  },
  create(column, newColumn) {
    return freeze({
      kind: "RenameColumnNode",
      column: ColumnNode.create(column),
      renameTo: ColumnNode.create(newColumn)
    });
  }
});
const CheckConstraintNode = freeze({
  is(node2) {
    return node2.kind === "CheckConstraintNode";
  },
  create(expression, constraintName) {
    return freeze({
      kind: "CheckConstraintNode",
      expression,
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});
const ON_MODIFY_FOREIGN_ACTIONS = [
  "no action",
  "restrict",
  "cascade",
  "set null",
  "set default"
];
const ReferencesNode = freeze({
  is(node2) {
    return node2.kind === "ReferencesNode";
  },
  create(table, columns) {
    return freeze({
      kind: "ReferencesNode",
      table,
      columns: freeze([...columns])
    });
  },
  cloneWithOnDelete(references, onDelete) {
    return freeze({
      ...references,
      onDelete
    });
  },
  cloneWithOnUpdate(references, onUpdate) {
    return freeze({
      ...references,
      onUpdate
    });
  }
});
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}
const GeneratedNode = freeze({
  is(node2) {
    return node2.kind === "GeneratedNode";
  },
  create(params) {
    return freeze({
      kind: "GeneratedNode",
      ...params
    });
  },
  createWithExpression(expression) {
    return freeze({
      kind: "GeneratedNode",
      always: true,
      expression
    });
  },
  cloneWith(node2, params) {
    return freeze({
      ...node2,
      ...params
    });
  }
});
const DefaultValueNode = freeze({
  is(node2) {
    return node2.kind === "DefaultValueNode";
  },
  create(defaultValue) {
    return freeze({
      kind: "DefaultValueNode",
      defaultValue
    });
  }
});
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}
class ColumnDefinitionBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /**
   * Adds `auto_increment` or `autoincrement` to the column definition
   * depending on the dialect.
   *
   * Some dialects like PostgreSQL don't support this. On PostgreSQL
   * you can use the `serial` or `bigserial` data type instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.autoIncrement().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key auto_increment
   * )
   * ```
   */
  autoIncrement() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
  }
  /**
   * Makes the column an identity column.
   *
   * This only works on some dialects like MS SQL Server (MSSQL).
   *
   * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.identity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MSSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer identity primary key
   * )
   * ```
   */
  identity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
  }
  /**
   * Makes the column the primary key.
   *
   * If you want to specify a composite primary key use the
   * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key
   * )
   */
  primaryKey() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
  }
  /**
   * Adds a foreign key constraint for the column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer', (col) => col.references('person.id'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id")
   * )
   * ```
   */
  references(ref2) {
    const references = parseStringReference(ref2);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref2}'). The reference must have format table.column or schema.table.column`);
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  /**
   * Adds an `on delete` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on delete cascade
   * )
   * ```
   */
  onDelete(onDelete) {
    if (!this.#node.references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
    }));
  }
  /**
   * Adds an `on update` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onUpdate('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on update cascade
   * )
   * ```
   */
  onUpdate(onUpdate) {
    if (!this.#node.references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  /**
   * Adds a unique constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `email` varchar(255) unique
   * )
   * ```
   */
  unique() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
  }
  /**
   * Adds a `not null` constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(255)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `first_name` varchar(255) not null
   * )
   * ```
   */
  notNull() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
  }
  /**
   * Adds a `unsigned` modifier for the column.
   *
   * This only works on some dialects like MySQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('age', 'integer', col => col.unsigned())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `age` integer unsigned
   * )
   * ```
   */
  unsigned() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
  }
  /**
   * Adds a default value constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer default 4
   * )
   * ```
   *
   * Values passed to `defaultTo` are interpreted as value literals by default. You can define
   * an arbitrary SQL expression using the {@link sql} template tag:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'created_at',
   *     'timestamp',
   *     (col) => col.defaultTo(sql`CURRENT_TIMESTAMP`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `created_at` timestamp default CURRENT_TIMESTAMP
   * )
   * ```
   */
  defaultTo(value) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  /**
   * Adds a check constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) =>
   *     col.check(sql`number_of_legs < 5`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer check (number_of_legs < 5)
   * )
   * ```
   */
  check(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  /**
   * Makes the column a generated column using a `generated always as` statement.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)',
   *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name))
   * )
   * ```
   */
  generatedAlwaysAs(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  /**
   * Adds the `generated always as identity` specifier.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedAlwaysAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated always as identity primary key
   * )
   * ```
   */
  generatedAlwaysAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  /**
   * Adds the `generated by default as identity` specifier on supported dialects.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedByDefaultAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated by default as identity primary key
   * )
   * ```
   */
  generatedByDefaultAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  /**
   * Makes a generated column stored instead of virtual. This method can only
   * be used with {@link generatedAlwaysAs}
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)', (col) => col
   *     .generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *     .stored()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name)) stored
   * )
   * ```
   */
  stored() {
    if (!this.#node.generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.cloneWith(this.#node.generated, {
        stored: true
      })
    }));
  }
  /**
   * This can be used to add any additional SQL right after the column's data type.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'first_name',
   *     'varchar(36)',
   *     (col) => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(36) collate utf8mb4_general_ci not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Adds `nulls not distinct` specifier.
   * Should be used with `unique` constraint.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(30) unique nulls not distinct
   * )
   * ```
   */
  nullsNotDistinct() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  /**
   * Adds `if not exists` specifier. This only works for PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique().ifNotExists())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * alter table "person" add column if not exists "email" varchar(255) unique
   * ```
   */
  ifNotExists() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
  }
  /**
   * This can be used to add any additional SQL to the end of the column definition.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'age',
   *     'integer',
   *     col => col.unsigned()
   *       .notNull()
   *       .modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
   * )
   * ```
   */
  modifyEnd(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const ModifyColumnNode = freeze({
  is(node2) {
    return node2.kind === "ModifyColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ModifyColumnNode",
      column
    });
  }
});
const ForeignKeyConstraintNode = freeze({
  is(node2) {
    return node2.kind === "ForeignKeyConstraintNode";
  },
  create(sourceColumns, targetTable, targetColumns, constraintName) {
    return freeze({
      kind: "ForeignKeyConstraintNode",
      columns: sourceColumns,
      references: ReferencesNode.create(targetTable, targetColumns),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  }
});
class ForeignKeyConstraintBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  onDelete(onDelete) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  deferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const AddConstraintNode = freeze({
  is(node2) {
    return node2.kind === "AddConstraintNode";
  },
  create(constraint) {
    return freeze({
      kind: "AddConstraintNode",
      constraint
    });
  }
});
const UniqueConstraintNode = freeze({
  is(node2) {
    return node2.kind === "UniqueConstraintNode";
  },
  create(columns, constraintName, nullsNotDistinct) {
    return freeze({
      kind: "UniqueConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0,
      nullsNotDistinct
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  }
});
const DropConstraintNode = freeze({
  is(node2) {
    return node2.kind === "DropConstraintNode";
  },
  create(constraintName) {
    return freeze({
      kind: "DropConstraintNode",
      constraintName: IdentifierNode.create(constraintName)
    });
  },
  cloneWith(dropConstraint, props) {
    return freeze({
      ...dropConstraint,
      ...props
    });
  }
});
const AlterColumnNode = freeze({
  is(node2) {
    return node2.kind === "AlterColumnNode";
  },
  create(column, prop, value) {
    return freeze({
      kind: "AlterColumnNode",
      column: ColumnNode.create(column),
      [prop]: value
    });
  }
});
class AlterColumnBuilder {
  #column;
  constructor(column) {
    this.#column = column;
  }
  setDataType(dataType2) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType2)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
}
class AlteredColumnBuilder {
  #alterColumnNode;
  constructor(alterColumnNode) {
    this.#alterColumnNode = alterColumnNode;
  }
  toOperationNode() {
    return this.#alterColumnNode;
  }
}
class AlterTableExecutor {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class AlterTableAddForeignKeyConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  onDelete(onDelete) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
    });
  }
  deferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.deferrable()
    });
  }
  notDeferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.notDeferrable()
    });
  }
  initiallyDeferred() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyDeferred()
    });
  }
  initiallyImmediate() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyImmediate()
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
      addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
    }), this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class AlterTableDropConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const PrimaryKeyConstraintNode = freeze({
  is(node2) {
    return node2.kind === "PrimaryKeyConstraintNode";
  },
  create(columns, constraintName) {
    return freeze({
      kind: "PrimaryKeyConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node2, props) {
    return freeze({ ...node2, ...props });
  }
});
const AddIndexNode = freeze({
  is(node2) {
    return node2.kind === "AddIndexNode";
  },
  create(name) {
    return freeze({
      kind: "AddIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node2, props) {
    return freeze({
      ...node2,
      ...props
    });
  },
  cloneWithColumns(node2, columns) {
    return freeze({
      ...node2,
      columns: [...node2.columns || [], ...columns]
    });
  }
});
class AlterTableAddIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the index unique.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .unique()
   *   .column('email')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_first_name_index` (`email`)
   * ```
   */
  unique() {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          unique: true
        })
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .column('first_name')
   *   .column('age desc')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  column(column) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .columns(['first_name', 'age desc'])
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  columns(columns) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .expression(sql<boolean>`(first_name < 'Sami')`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
   * ```
   */
  expression(expression) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class UniqueConstraintNodeBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /**
   * Adds `nulls not distinct` to the unique constraint definition
   *
   * Supported by PostgreSQL dialect only
   */
  nullsNotDistinct() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  deferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
class PrimaryKeyConstraintBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  deferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
class CheckConstraintBuilder {
  #node;
  constructor(node2) {
    this.#node = node2;
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const RenameConstraintNode = freeze({
  is(node2) {
    return node2.kind === "RenameConstraintNode";
  },
  create(oldName, newName) {
    return freeze({
      kind: "RenameConstraintNode",
      oldName: IdentifierNode.create(oldName),
      newName: IdentifierNode.create(newName)
    });
  }
});
class AlterTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType2, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType2))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType2, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType2))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  /**
   * See {@link CreateTableBuilder.addUniqueConstraint}
   */
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addCheckConstraint}
   */
  addCheckConstraint(constraintName, checkExpression, build = noop) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addForeignKeyConstraint}
   *
   * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
   * the constraint builder and doesn't take a callback as the last argument. This
   * is because you can only add one column per `ALTER TABLE` query.
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
    const constraintBuilder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder
    });
  }
  /**
   * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
   */
  addPrimaryKeyConstraint(constraintName, columns, build = noop) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  renameConstraint(oldName, newName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameConstraint: RenameConstraintNode.create(oldName, newName)
      })
    });
  }
  /**
   * This can be used to add index to table.
   *
   *  ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .addIndex('person_email_index')
   *   .column('email')
   *   .unique()
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_email_index` (`email`)
   * ```
   */
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  /**
   * This can be used to drop index from table.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .dropIndex('person_email_index')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` drop index `test_first_name_index`
   * ```
   */
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * See {@link CreateTableBuilder.$call}
   */
  $call(func) {
    return func(this);
  }
}
class AlterTableColumnAlteringBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType2, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType2))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType2, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType2))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class ImmediateValueTransformer extends OperationNodeTransformer {
  transformPrimitiveValueList(node2) {
    return ValueListNode.create(node2.values.map(ValueNode.createImmediate));
  }
  transformValue(node2) {
    return ValueNode.createImmediate(node2.value);
  }
}
class CreateIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the index already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Makes the index unique.
   */
  unique() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        unique: true
      })
    });
  }
  /**
   * Adds `nulls not distinct` specifier to index.
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createIndex('person_first_name_index')
   *  .on('person')
   *  .column('first_name')
   *  .nullsNotDistinct()
   *  .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index"
   * on "test" ("first_name")
   * nulls not distinct;
   * ```
   */
  nullsNotDistinct() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        nullsNotDistinct: true
      })
    });
  }
  /**
   * Specifies the table for the index.
   */
  on(table) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .column('first_name')
   *         .column('age desc')
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  column(column) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .columns(['first_name', 'age desc'])
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  columns(columns) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createIndex('person_first_name_index')
   *   .on('person')
   *   .expression(sql`first_name COLLATE "fi_FI"`)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
   * ```
   */
  expression(expression) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer();
    return new CreateIndexBuilder({
      ...this.#props,
      node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args), this.#props.queryId))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class CreateSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateSchemaBuilder({
      ...this.#props,
      node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}
class CreateTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary table.
   */
  temporary() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  /**
   * Adds an "on commit" statement.
   *
   * This can be used in conjunction with temporary tables on supported databases
   * like PostgreSQL.
   */
  onCommit(onCommit) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the table already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Adds a column to the table.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())
   *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
   *   .addColumn('last_name', 'varchar(255)')
   *   .addColumn('bank_balance', 'numeric(8, 2)')
   *   // You can specify any data type using the `sql` tag if the types
   *   // don't include it.
   *   .addColumn('data', sql`any_type_here`)
   *   .addColumn('parent_id', 'integer', (col) =>
   *     col.references('person.id').onDelete('cascade')
   *   )
   * ```
   *
   * With this method, it's once again good to remember that Kysely just builds the
   * query and doesn't provide the same API for all databases. For example, some
   * databases like older MySQL don't support the `references` statement in the
   * column definition. Instead foreign key constraints need to be defined in the
   * `create table` query. See the next example:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.primaryKey())
   *   .addColumn('parent_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'person_parent_id_fk',
   *     ['parent_id'],
   *     'person',
   *     ['id'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * Another good example is that PostgreSQL doesn't support the `auto_increment`
   * keyword and you need to define an autoincrementing column for example using
   * `serial`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'serial', (col) => col.primaryKey())
   *   .execute()
   * ```
   */
  addColumn(columnName, dataType2, build = noop) {
    const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType2))));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
    });
  }
  /**
   * Adds a primary key constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  addPrimaryKeyConstraint(constraintName, columns, build = noop) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a unique constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name']
   *   )
   *   .execute()
   * ```
   *
   * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name'],
   *     (cb) => cb.nullsNotDistinct()
   *   )
   *   .execute()
   * ```
   */
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a check constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('animal')
   *   .addColumn('number_of_legs', 'integer')
   *   .addCheckConstraint('check_legs', sql`number_of_legs < 5`)
   *   .execute()
   * ```
   */
  addCheckConstraint(constraintName, checkExpression, build = noop) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a foreign key constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id'],
   *     'person',
   *     ['id'],
   *   )
   *   .execute()
   * ```
   *
   * Add constraint for multiple columns:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id1', 'integer')
   *   .addColumn('owner_id2', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id1', 'owner_id2'],
   *     'person',
   *     ['id1', 'id2'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
    const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
   *
   * Also see {@link temporary}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .modifyFront(sql`global temporary`)
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (Postgres):
   *
   * ```sql
   * create global temporary table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(64) not null,
   *   "last_name" varchar(64) not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * Also see {@link onCommit}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .modifyEnd(sql`collate utf8_unicode_ci`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(64) not null,
   *   `last_name` varchar(64) not null
   * ) collate utf8_unicode_ci
   * ```
   */
  modifyEnd(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * Allows to create table from `select` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('copy')
   *   .temporary()
   *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create temporary table "copy" as
   * select "first_name", "last_name" from "person"
   * ```
   */
  as(expression) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('test')
   *   .$call((builder) => builder.addColumn('id', 'integer'))
   *   .execute()
   * ```
   *
   * This is useful for creating reusable functions that can be called with a builder.
   *
   * ```ts
   * import { type CreateTableBuilder, sql } from 'kysely'
   *
   * const addDefaultColumns = (ctb: CreateTableBuilder<any, any>) => {
   *   return ctb
   *     .addColumn('id', 'integer', (col) => col.notNull())
   *     .addColumn('created_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   *     .addColumn('updated_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   * }
   *
   * await db.schema
   *   .createTable('test')
   *   .$call(addDefaultColumns)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specifies the table the index was created for. This is not needed
   * in all dialects.
   */
  on(table) {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const CreateViewNode = freeze({
  is(node2) {
    return node2.kind === "CreateViewNode";
  },
  create(name) {
    return freeze({
      kind: "CreateViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});
class ImmediateValuePlugin {
  #transformer = new ImmediateValueTransformer();
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
}
class CreateViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary view.
   */
  temporary() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
   */
  ifNotExists() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  /**
   * Sets the select query or a `values` statement that creates the view.
   *
   * WARNING!
   * Some dialects don't support parameterized queries in DDL statements and therefore
   * the query or raw {@link sql } expression passed here is interpolated into a single
   * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
   * into the query or raw expression passed to this method!
   */
  as(query) {
    const queryNode = query.withPlugin(new ImmediateValuePlugin()).toOperationNode();
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        as: queryNode
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const DropViewNode = freeze({
  is(node2) {
    return node2.kind === "DropViewNode";
  },
  create(name) {
    return freeze({
      kind: "DropViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(dropView, params) {
    return freeze({
      ...dropView,
      ...params
    });
  }
});
class DropViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const CreateTypeNode = freeze({
  is(node2) {
    return node2.kind === "CreateTypeNode";
  },
  create(name) {
    return freeze({
      kind: "CreateTypeNode",
      name
    });
  },
  cloneWithEnum(createType, values2) {
    return freeze({
      ...createType,
      enum: ValueListNode.create(values2.map(ValueNode.createImmediate))
    });
  }
});
class CreateTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  /**
   * Creates an anum type.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
   * ```
   */
  asEnum(values2) {
    return new CreateTypeBuilder({
      ...this.#props,
      node: CreateTypeNode.cloneWithEnum(this.#props.node, values2)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const DropTypeNode = freeze({
  is(node2) {
    return node2.kind === "DropTypeNode";
  },
  create(name) {
    return freeze({
      kind: "DropTypeNode",
      name
    });
  },
  cloneWith(dropType, params) {
    return freeze({
      ...dropType,
      ...params
    });
  }
});
class DropTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTypeBuilder({
      ...this.#props,
      node: DropTypeNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
function parseSchemableIdentifier(id2) {
  const SCHEMA_SEPARATOR = ".";
  if (id2.includes(SCHEMA_SEPARATOR)) {
    const parts = id2.split(SCHEMA_SEPARATOR).map(trim);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id2}`);
    }
  } else {
    return SchemableIdentifierNode.create(id2);
  }
}
function trim(str) {
  return str.trim();
}
const RefreshMaterializedViewNode = freeze({
  is(node2) {
    return node2.kind === "RefreshMaterializedViewNode";
  },
  create(name) {
    return freeze({
      kind: "RefreshMaterializedViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});
class RefreshMaterializedViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "concurrently" modifier.
   *
   * Use this to refresh the view without locking out concurrent selects on the materialized view.
   *
   * WARNING!
   * This cannot be used with the "with no data" modifier.
   */
  concurrently() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        concurrently: true,
        withNoData: false
      })
    });
  }
  /**
   * Adds the "with data" modifier.
   *
   * If specified (or defaults) the backing query is executed to provide the new data, and the materialized view is left in a scannable state
   */
  withData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: false
      })
    });
  }
  /**
   * Adds the "with no data" modifier.
   *
   * If specified, no new data is generated and the materialized view is left in an unscannable state.
   *
   * WARNING!
   * This cannot be used with the "concurrently" modifier.
   */
  withNoData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: true,
        concurrently: false
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class SchemaModule {
  #executor;
  constructor(executor) {
    this.#executor = executor;
  }
  /**
   * Create a new table.
   *
   * ### Examples
   *
   * This example creates a new table with columns `id`, `first_name`,
   * `last_name` and `gender`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('first_name', 'varchar', col => col.notNull())
   *   .addColumn('last_name', 'varchar', col => col.notNull())
   *   .addColumn('gender', 'varchar')
   *   .execute()
   * ```
   *
   * This example creates a table with a foreign key. Not all database
   * engines support column-level foreign key constraint definitions.
   * For example if you are using MySQL 5.X see the next example after
   * this one.
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer', col => col
   *     .references('person.id')
   *     .onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * This example adds a foreign key constraint for a columns just
   * like the previous example, but using a table-level statement.
   * On MySQL 5.X you need to define foreign key constraints like
   * this:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
   *     (constraint) => constraint.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTableNode.create(parseTable(table))
    });
  }
  /**
   * Drop a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropTable('person')
   *   .execute()
   * ```
   */
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createIndex('person_full_name_unique_index')
   *   .on('person')
   *   .columns(['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateIndexNode.create(indexName)
    });
  }
  /**
   * Drop an index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropIndex('person_full_name_unique_index')
   *   .execute()
   * ```
   */
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropIndexNode.create(indexName)
    });
  }
  /**
   * Create a new schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createSchema('some_schema')
   *   .execute()
   * ```
   */
  createSchema(schema) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateSchemaNode.create(schema)
    });
  }
  /**
   * Drop a schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropSchema('some_schema')
   *   .execute()
   * ```
   */
  dropSchema(schema) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropSchemaNode.create(schema)
    });
  }
  /**
   * Alter a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
   *   .execute()
   * ```
   */
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: AlterTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createView('dogs')
   *   .orReplace()
   *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
   *   .execute()
   * ```
   */
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateViewNode.create(viewName)
    });
  }
  /**
   * Refresh a materialized view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .refreshMaterializedView('my_view')
   *   .concurrently()
   *   .execute()
   * ```
   */
  refreshMaterializedView(viewName) {
    return new RefreshMaterializedViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: RefreshMaterializedViewNode.create(viewName)
    });
  }
  /**
   * Drop a view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropView('dogs')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropViewNode.create(viewName)
    });
  }
  /**
   * Create a new type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createType('species')
   *   .asEnum(['dog', 'cat', 'frog'])
   *   .execute()
   * ```
   */
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Drop a type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropType('species')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Returns a copy of this schema module with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new SchemaModule(this.#executor.withPlugin(plugin2));
  }
  /**
   * Returns a copy of this schema module  without any plugins.
   */
  withoutPlugins() {
    return new SchemaModule(this.#executor.withoutPlugins());
  }
  /**
   * See {@link QueryCreator.withSchema}
   */
  withSchema(schema) {
    return new SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema)));
  }
}
class DynamicModule {
  /**
   * Creates a dynamic reference to a column that is not know at compile time.
   *
   * Kysely is built in a way that by default you can't refer to tables or columns
   * that are not actually visible in the current query and context. This is all
   * done by TypeScript at compile time, which means that you need to know the
   * columns and tables at compile time. This is not always the case of course.
   *
   * This method is meant to be used in those cases where the column names
   * come from the user input or are not otherwise known at compile time.
   *
   * WARNING! Unlike values, column names are not escaped by the database engine
   * or Kysely and if you pass in unchecked column names using this method, you
   * create an SQL injection vulnerability. Always __always__ validate the user
   * input before passing it to this method.
   *
   * There are couple of examples below for some use cases, but you can pass
   * `ref` to other methods as well. If the types allow you to pass a `ref`
   * value to some place, it should work.
   *
   * ### Examples
   *
   * Filter by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(filterColumn: string, filterValue: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .selectAll()
   *     .where(ref(filterColumn), '=', filterValue)
   *     .execute()
   * }
   *
   * someQuery('first_name', 'Arnold')
   * someQuery('person.last_name', 'Aniston')
   * ```
   *
   * Order by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(orderBy: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .select('person.first_name as fn')
   *     .orderBy(ref(orderBy))
   *     .execute()
   * }
   *
   * someQuery('fn')
   * ```
   *
   * In this example we add selections dynamically:
   *
   * ```ts
   * const { ref } = db.dynamic
   *
   * // Some column name provided by the user. Value not known at compile time.
   * const columnFromUserInput: PossibleColumns = 'birthdate';
   *
   * // A type that lists all possible values `columnFromUserInput` can have.
   * // You can use `keyof Person` if any column of an interface is allowed.
   * type PossibleColumns = 'last_name' | 'first_name' | 'birthdate'
   *
   * const [person] = await db.selectFrom('person')
   *   .select([
   *     ref<PossibleColumns>(columnFromUserInput),
   *     'id'
   *   ])
   *   .execute()
   *
   * // The resulting type contains all `PossibleColumns` as optional fields
   * // because we cannot know which field was actually selected before
   * // running the code.
   * const lastName: string | null | undefined = person?.last_name
   * const firstName: string | undefined = person?.first_name
   * const birthDate: Date | null | undefined = person?.birthdate
   *
   * // The result type also contains the compile time selection `id`.
   * person?.id
   * ```
   */
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
  /**
   * Creates a table reference to a table that's not fully known at compile time.
   *
   * The type `T` is allowed to be a union of multiple tables.
   *
   * <!-- siteExample("select", "Generic find query", 130) -->
   *
   * A generic type-safe helper function for finding a row by a column value:
   *
   * ```ts
   * import { SelectType } from 'kysely'
   * import { Database } from 'type-editor'
   *
   * async function getRowByColumn<
   *   T extends keyof Database,
   *   C extends keyof Database[T] & string,
   *   V extends SelectType<Database[T][C]>,
   * >(t: T, c: C, v: V) {
   *   // We need to use the dynamic module since the table name
   *   // is not known at compile time.
   *   const { table, ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom(table(t).as('t'))
   *     .selectAll()
   *     .where(ref(c), '=', v)
   *     .orderBy('t.id')
   *     .executeTakeFirstOrThrow()
   * }
   *
   * const person = await getRowByColumn('person', 'first_name', 'Arnold')
   * ```
   */
  table(table) {
    return new DynamicTableBuilder(table);
  }
}
class DefaultConnectionProvider {
  #driver;
  constructor(driver) {
    this.#driver = driver;
  }
  async provideConnection(consumer) {
    const connection = await this.#driver.acquireConnection();
    try {
      return await consumer(connection);
    } finally {
      await this.#driver.releaseConnection(connection);
    }
  }
}
class DefaultQueryExecutor extends QueryExecutorBase {
  #compiler;
  #adapter;
  #connectionProvider;
  constructor(compiler, adapter, connectionProvider, plugins = []) {
    super(plugins);
    this.#compiler = compiler;
    this.#adapter = adapter;
    this.#connectionProvider = connectionProvider;
  }
  get adapter() {
    return this.#adapter;
  }
  compileQuery(node2, queryId) {
    return this.#compiler.compileQuery(node2, queryId);
  }
  provideConnection(consumer) {
    return this.#connectionProvider.provideConnection(consumer);
  }
  withPlugins(plugins) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
  }
  withPlugin(plugin2) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin2]);
  }
  withPluginAtFront(plugin2) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin2, ...this.plugins]);
  }
  withConnectionProvider(connectionProvider) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
  }
  withoutPlugins() {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
  }
}
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}
class RuntimeDriver {
  #driver;
  #log;
  #initPromise;
  #initDone;
  #destroyPromise;
  #connections = /* @__PURE__ */ new WeakSet();
  constructor(driver, log2) {
    this.#initDone = false;
    this.#driver = driver;
    this.#log = log2;
  }
  async init() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initPromise) {
      this.#initPromise = this.#driver.init().then(() => {
        this.#initDone = true;
      }).catch((err2) => {
        this.#initPromise = void 0;
        return Promise.reject(err2);
      });
    }
    await this.#initPromise;
  }
  async acquireConnection() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initDone) {
      await this.init();
    }
    const connection = await this.#driver.acquireConnection();
    if (!this.#connections.has(connection)) {
      if (this.#needsLogging()) {
        this.#addLogging(connection);
      }
      this.#connections.add(connection);
    }
    return connection;
  }
  async releaseConnection(connection) {
    await this.#driver.releaseConnection(connection);
  }
  beginTransaction(connection, settings) {
    return this.#driver.beginTransaction(connection, settings);
  }
  commitTransaction(connection) {
    return this.#driver.commitTransaction(connection);
  }
  rollbackTransaction(connection) {
    return this.#driver.rollbackTransaction(connection);
  }
  savepoint(connection, savepointName, compileQuery) {
    if (this.#driver.savepoint) {
      return this.#driver.savepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `savepoint` method is not supported by this driver");
  }
  rollbackToSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.rollbackToSavepoint) {
      return this.#driver.rollbackToSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `rollbackToSavepoint` method is not supported by this driver");
  }
  releaseSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.releaseSavepoint) {
      return this.#driver.releaseSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `releaseSavepoint` method is not supported by this driver");
  }
  async destroy() {
    if (!this.#initPromise) {
      return;
    }
    await this.#initPromise;
    if (!this.#destroyPromise) {
      this.#destroyPromise = this.#driver.destroy().catch((err2) => {
        this.#destroyPromise = void 0;
        return Promise.reject(err2);
      });
    }
    await this.#destroyPromise;
  }
  #needsLogging() {
    return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
  }
  // This method monkey patches the database connection's executeQuery method
  // by adding logging code around it. Monkey patching is not pretty, but it's
  // the best option in this case.
  #addLogging(connection) {
    const executeQuery = connection.executeQuery;
    const streamQuery = connection.streamQuery;
    const dis = this;
    connection.executeQuery = async (compiledQuery) => {
      let caughtError;
      const startTime = performanceNow();
      try {
        return await executeQuery.call(connection, compiledQuery);
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime);
        }
      }
    };
    connection.streamQuery = async function* (compiledQuery, chunkSize) {
      let caughtError;
      const startTime = performanceNow();
      try {
        for await (const result of streamQuery.call(connection, compiledQuery, chunkSize)) {
          yield result;
        }
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime, true);
        }
      }
    };
  }
  async #logError(error2, compiledQuery, startTime) {
    await this.#log.error(() => ({
      level: "error",
      error: error2,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  async #logQuery(compiledQuery, startTime, isStream = false) {
    await this.#log.query(() => ({
      level: "query",
      isStream,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  #calculateDurationMillis(startTime) {
    return performanceNow() - startTime;
  }
}
const ignoreError = () => {
};
class SingleConnectionProvider {
  #connection;
  #runningPromise;
  constructor(connection) {
    this.#connection = connection;
  }
  async provideConnection(consumer) {
    while (this.#runningPromise) {
      await this.#runningPromise.catch(ignoreError);
    }
    this.#runningPromise = this.#run(consumer).finally(() => {
      this.#runningPromise = void 0;
    });
    return this.#runningPromise;
  }
  // Run the runner in an async function to make sure it doesn't
  // throw synchronous errors.
  async #run(runner) {
    return await runner(this.#connection);
  }
}
const TRANSACTION_ACCESS_MODES = ["read only", "read write"];
const TRANSACTION_ISOLATION_LEVELS = [
  "read uncommitted",
  "read committed",
  "repeatable read",
  "serializable",
  "snapshot"
];
function validateTransactionSettings(settings) {
  if (settings.accessMode && !TRANSACTION_ACCESS_MODES.includes(settings.accessMode)) {
    throw new Error(`invalid transaction access mode ${settings.accessMode}`);
  }
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}
const logLevels = ["query", "error"];
freeze(logLevels);
class Log {
  #levels;
  #logger;
  constructor(config2) {
    if (isFunction(config2)) {
      this.#logger = config2;
      this.#levels = freeze({
        query: true,
        error: true
      });
    } else {
      this.#logger = defaultLogger;
      this.#levels = freeze({
        query: config2.includes("query"),
        error: config2.includes("error")
      });
    }
  }
  isLevelEnabled(level) {
    return this.#levels[level];
  }
  async query(getEvent) {
    if (this.#levels.query) {
      await this.#logger(getEvent());
    }
  }
  async error(getEvent) {
    if (this.#levels.error) {
      await this.#logger(getEvent());
    }
  }
}
function defaultLogger(event) {
  if (event.level === "query") {
    const prefix = `kysely:query:${event.isStream ? "stream:" : ""}`;
    console.log(`${prefix} ${event.query.sql}`);
    console.log(`${prefix} duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}
function isCompilable(value) {
  return isObject(value) && isFunction(value.compile);
}
Symbol.asyncDispose ??= /* @__PURE__ */ Symbol("Symbol.asyncDispose");
class Kysely extends QueryCreator {
  #props;
  constructor(args) {
    let superProps;
    let props;
    if (isKyselyProps(args)) {
      superProps = { executor: args.executor };
      props = { ...args };
    } else {
      const dialect = args.dialect;
      const driver = dialect.createDriver();
      const compiler = dialect.createQueryCompiler();
      const adapter = dialect.createAdapter();
      const log2 = new Log(args.log ?? []);
      const runtimeDriver = new RuntimeDriver(driver, log2);
      const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
      const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
      superProps = { executor };
      props = {
        config: args,
        executor,
        dialect,
        driver: runtimeDriver
      };
    }
    super(superProps);
    this.#props = freeze(props);
  }
  /**
   * Returns the {@link SchemaModule} module for building database schema.
   */
  get schema() {
    return new SchemaModule(this.#props.executor);
  }
  /**
   * Returns a the {@link DynamicModule} module.
   *
   * The {@link DynamicModule} module can be used to bypass strict typing and
   * passing in dynamic values for the queries.
   */
  get dynamic() {
    return new DynamicModule();
  }
  /**
   * Returns a {@link DatabaseIntrospector | database introspector}.
   */
  get introspection() {
    return this.#props.dialect.createIntrospector(this.withoutPlugins());
  }
  case(value) {
    return new CaseBuilder({
      node: CaseNode.create(isUndefined(value) ? void 0 : parseExpression(value))
    });
  }
  /**
   * Returns a {@link FunctionModule} that can be used to write somewhat type-safe function
   * calls.
   *
   * ```ts
   * const { count } = db.fn
   *
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select([
   *     'id',
   *     count('pet.id').as('person_count'),
   *   ])
   *   .groupBy('person.id')
   *   .having(count('pet.id'), '>', 10)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "person"."id", count("pet"."id") as "person_count"
   * from "person"
   * inner join "pet" on "pet"."owner_id" = "person"."id"
   * group by "person"."id"
   * having count("pet"."id") > $1
   * ```
   *
   * Why "somewhat" type-safe? Because the function calls are not bound to the
   * current query context. They allow you to reference columns and tables that
   * are not in the current query. E.g. remove the `innerJoin` from the previous
   * query and TypeScript won't even complain.
   *
   * If you want to make the function calls fully type-safe, you can use the
   * {@link ExpressionBuilder.fn} getter for a query context-aware, stricter {@link FunctionModule}.
   *
   * ```ts
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select((eb) => [
   *     'person.id',
   *     eb.fn.count('pet.id').as('pet_count')
   *   ])
   *   .groupBy('person.id')
   *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
   *   .execute()
   * ```
   */
  get fn() {
    return createFunctionModule();
  }
  /**
   * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
   *
   * The returned {@link TransactionBuilder} can be used to configure the transaction. The
   * {@link TransactionBuilder.execute} method can then be called to run the transaction.
   * {@link TransactionBuilder.execute} takes a function that is run inside the
   * transaction. If the function throws an exception,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * The callback function passed to the {@link TransactionBuilder.execute | execute}
   * method gets the transaction object as its only argument. The transaction is
   * of type {@link Transaction} which inherits {@link Kysely}. Any query
   * started through the transaction object is executed inside the transaction.
   *
   * To run a controlled transaction, allowing you to commit and rollback manually,
   * use {@link startTransaction} instead.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Simple transaction", 10) -->
   *
   * This example inserts two rows in a transaction. If an exception is thrown inside
   * the callback passed to the `execute` method,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * ```ts
   * const catto = await db.transaction().execute(async (trx) => {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   return await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirst()
   * })
   * ```
   *
   * Setting the isolation level:
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   *
   * await db
   *   .transaction()
   *   .setIsolationLevel('serializable')
   *   .execute(async (trx) => {
   *     await doStuff(trx)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  transaction() {
    return new TransactionBuilder({ ...this.#props });
  }
  /**
   * Creates a {@link ControlledTransactionBuilder} that can be used to run queries inside a controlled transaction.
   *
   * The returned {@link ControlledTransactionBuilder} can be used to configure the transaction.
   * The {@link ControlledTransactionBuilder.execute} method can then be called
   * to start the transaction and return a {@link ControlledTransaction}.
   *
   * A {@link ControlledTransaction} allows you to commit and rollback manually,
   * execute savepoint commands. It extends {@link Transaction} which extends {@link Kysely},
   * so you can run queries inside the transaction. Once the transaction is committed,
   * or rolled back, it can't be used anymore - all queries will throw an error.
   * This is to prevent accidentally running queries outside the transaction - where
   * atomicity is not guaranteed anymore.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Controlled transaction", 11) -->
   *
   * A controlled transaction allows you to commit and rollback manually, execute
   * savepoint commands, and queries in general.
   *
   * In this example we start a transaction, use it to insert two rows and then commit
   * the transaction. If an error is thrown, we catch it and rollback the transaction.
   *
   * ```ts
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   const catto = await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirstOrThrow()
   *
   *   await trx.commit().execute()
   *
   *   // ...
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   * ```
   *
   * <!-- siteExample("transactions", "Controlled transaction /w savepoints", 12) -->
   *
   * A controlled transaction allows you to commit and rollback manually, execute
   * savepoint commands, and queries in general.
   *
   * In this example we start a transaction, insert a person, create a savepoint,
   * try inserting a toy and a pet, and if an error is thrown, we rollback to the
   * savepoint. Eventually we release the savepoint, insert an audit record and
   * commit the transaction. If an error is thrown, we catch it and rollback the
   * transaction.
   *
   * ```ts
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   const jennifer = await trx
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   *   try {
   *     const catto = await trxAfterJennifer
   *       .insertInto('pet')
   *       .values({
   *         owner_id: jennifer.id,
   *         name: 'Catto',
   *         species: 'cat',
   *       })
   *       .returning('id')
   *       .executeTakeFirstOrThrow()
   *
   *     await trxAfterJennifer
   *       .insertInto('toy')
   *       .values({ name: 'Bone', price: 1.99, pet_id: catto.id })
   *       .execute()
   *   } catch (error) {
   *     await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   *   }
   *
   *   await trxAfterJennifer.releaseSavepoint('after_jennifer').execute()
   *
   *   await trx.insertInto('audit').values({ action: 'added Jennifer' }).execute()
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   * ```
   */
  startTransaction() {
    return new ControlledTransactionBuilder({ ...this.#props });
  }
  /**
   * Provides a kysely instance bound to a single database connection.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .connection()
   *   .execute(async (db) => {
   *     // `db` is an instance of `Kysely` that's bound to a single
   *     // database connection. All queries executed through `db` use
   *     // the same connection.
   *     await doStuff(db)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  connection() {
    return new ConnectionBuilder({ ...this.#props });
  }
  /**
   * Returns a copy of this Kysely instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  /**
   * Returns a copy of this Kysely instance without any plugins.
   */
  withoutPlugins() {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * @override
   */
  withSchema(schema) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  /**
   * Returns a copy of this Kysely instance with tables added to its
   * database type.
   *
   * This method only modifies the types and doesn't affect any of the
   * executed queries in any way.
   *
   * ### Examples
   *
   * The following example adds and uses a temporary table:
   *
   * ```ts
   * await db.schema
   *   .createTable('temp_table')
   *   .temporary()
   *   .addColumn('some_column', 'integer')
   *   .execute()
   *
   * const tempDb = db.withTables<{
   *   temp_table: {
   *     some_column: number
   *   }
   * }>()
   *
   * await tempDb
   *   .insertInto('temp_table')
   *   .values({ some_column: 100 })
   *   .execute()
   * ```
   */
  withTables() {
    return new Kysely({ ...this.#props });
  }
  /**
   * Releases all resources and disconnects from the database.
   *
   * You need to call this when you are done using the `Kysely` instance.
   */
  async destroy() {
    await this.#props.driver.destroy();
  }
  /**
   * Returns true if this `Kysely` instance is a transaction.
   *
   * You can also use `db instanceof Transaction`.
   */
  get isTransaction() {
    return false;
  }
  /**
   * @internal
   * @private
   */
  getExecutor() {
    return this.#props.executor;
  }
  /**
   * Executes a given compiled query or query builder.
   *
   * See {@link https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
   */
  executeQuery(query, queryId) {
    if (queryId !== void 0) {
      logOnce("Passing `queryId` in `db.executeQuery` is deprecated and will result in a compile-time error in the future.");
    }
    const compiledQuery = isCompilable(query) ? query.compile() : query;
    return this.getExecutor().executeQuery(compiledQuery);
  }
  async [Symbol.asyncDispose]() {
    await this.destroy();
  }
}
class Transaction extends Kysely {
  #props;
  constructor(props) {
    super(props);
    this.#props = props;
  }
  // The return type is `true` instead of `boolean` to make Kysely<DB>
  // unassignable to Transaction<DB> while allowing assignment the
  // other way around.
  get isTransaction() {
    return true;
  }
  transaction() {
    throw new Error("calling the transaction method for a Transaction is not supported");
  }
  connection() {
    throw new Error("calling the connection method for a Transaction is not supported");
  }
  async destroy() {
    throw new Error("calling the destroy method for a Transaction is not supported");
  }
  withPlugin(plugin2) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  withoutPlugins() {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new Transaction({ ...this.#props });
  }
}
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}
class ConnectionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async execute(callback) {
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const db2 = new Kysely({
        ...this.#props,
        executor
      });
      return await callback(db2);
    });
  }
}
class TransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new TransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new TransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, accessMode, ...kyselyProps } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    return this.#props.executor.provideConnection(async (connection) => {
      const state = { isCommitted: false, isRolledBack: false };
      const executor = new NotCommittedOrRolledBackAssertingExecutor(this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection)), state);
      const transaction = new Transaction({
        ...kyselyProps,
        executor
      });
      let transactionBegun = false;
      try {
        await this.#props.driver.beginTransaction(connection, settings);
        transactionBegun = true;
        const result = await callback(transaction);
        await this.#props.driver.commitTransaction(connection);
        state.isCommitted = true;
        return result;
      } catch (error2) {
        if (transactionBegun) {
          await this.#props.driver.rollbackTransaction(connection);
          state.isRolledBack = true;
        }
        throw error2;
      }
    });
  }
}
class ControlledTransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute() {
    const { isolationLevel, accessMode, ...props } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    const connection = await provideControlledConnection(this.#props.executor);
    await this.#props.driver.beginTransaction(connection.connection, settings);
    return new ControlledTransaction({
      ...props,
      connection,
      executor: this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection.connection))
    });
  }
}
class ControlledTransaction extends Transaction {
  #props;
  #compileQuery;
  #state;
  constructor(props) {
    const state = { isCommitted: false, isRolledBack: false };
    props = {
      ...props,
      executor: new NotCommittedOrRolledBackAssertingExecutor(props.executor, state)
    };
    const { connection, ...transactionProps } = props;
    super(transactionProps);
    this.#props = freeze(props);
    this.#state = state;
    const queryId = createQueryId();
    this.#compileQuery = (node2) => props.executor.compileQuery(node2, queryId);
  }
  get isCommitted() {
    return this.#state.isCommitted;
  }
  get isRolledBack() {
    return this.#state.isRolledBack;
  }
  /**
   * Commits the transaction.
   *
   * See {@link rollback}.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   await doSomething(trx)
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   *
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  commit() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.commitTransaction(this.#props.connection.connection);
      this.#state.isCommitted = true;
      this.#props.connection.release();
    });
  }
  /**
   * Rolls back the transaction.
   *
   * See {@link commit} and {@link rollbackToSavepoint}.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   await doSomething(trx)
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   *
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  rollback() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackTransaction(this.#props.connection.connection);
      this.#state.isRolledBack = true;
      this.#props.connection.release();
    });
  }
  /**
   * Creates a savepoint with a given name.
   *
   * See {@link rollbackToSavepoint} and {@link releaseSavepoint}.
   *
   * For a type-safe experience, you should use the returned instance from now on.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  savepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.savepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  /**
   * Rolls back to a savepoint with a given name.
   *
   * See {@link savepoint} and {@link releaseSavepoint}.
   *
   * You must use the same instance returned by {@link savepoint}, or
   * escape the type-check by using `as any`.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  rollbackToSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackToSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  /**
   * Releases a savepoint with a given name.
   *
   * See {@link savepoint} and {@link rollbackToSavepoint}.
   *
   * You must use the same instance returned by {@link savepoint}, or
   * escape the type-check by using `as any`.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * await trxAfterJennifer.releaseSavepoint('after_jennifer').execute()
   *
   * await doSomethingElse(trx)
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * async function doSomethingElse(kysely: Kysely<Database>) {}
   * ```
   */
  releaseSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.releaseSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  withPlugin(plugin2) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  withoutPlugins() {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new ControlledTransaction({ ...this.#props });
  }
}
class Command {
  #cb;
  constructor(cb) {
    this.#cb = cb;
  }
  /**
   * Executes the command.
   */
  async execute() {
    return await this.#cb();
  }
}
function assertNotCommittedOrRolledBack(state) {
  if (state.isCommitted) {
    throw new Error("Transaction is already committed");
  }
  if (state.isRolledBack) {
    throw new Error("Transaction is already rolled back");
  }
}
class NotCommittedOrRolledBackAssertingExecutor {
  #executor;
  #state;
  constructor(executor, state) {
    if (executor instanceof NotCommittedOrRolledBackAssertingExecutor) {
      this.#executor = executor.#executor;
    } else {
      this.#executor = executor;
    }
    this.#state = state;
  }
  get adapter() {
    return this.#executor.adapter;
  }
  get plugins() {
    return this.#executor.plugins;
  }
  transformQuery(node2, queryId) {
    return this.#executor.transformQuery(node2, queryId);
  }
  compileQuery(node2, queryId) {
    return this.#executor.compileQuery(node2, queryId);
  }
  provideConnection(consumer) {
    return this.#executor.provideConnection(consumer);
  }
  executeQuery(compiledQuery) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.executeQuery(compiledQuery);
  }
  stream(compiledQuery, chunkSize) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.stream(compiledQuery, chunkSize);
  }
  withConnectionProvider(connectionProvider) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withConnectionProvider(connectionProvider), this.#state);
  }
  withPlugin(plugin2) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugin(plugin2), this.#state);
  }
  withPlugins(plugins) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugins(plugins), this.#state);
  }
  withPluginAtFront(plugin2) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPluginAtFront(plugin2), this.#state);
  }
  withoutPlugins() {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withoutPlugins(), this.#state);
  }
}
class RawBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias) {
    return new AliasedRawBuilderImpl(this, alias);
  }
  $castTo() {
    return new RawBuilderImpl({ ...this.#props });
  }
  $notNull() {
    return new RawBuilderImpl(this.#props);
  }
  withPlugin(plugin2) {
    return new RawBuilderImpl({
      ...this.#props,
      plugins: this.#props.plugins !== void 0 ? freeze([...this.#props.plugins, plugin2]) : freeze([plugin2])
    });
  }
  toOperationNode() {
    return this.#toOperationNode(this.#getExecutor());
  }
  compile(executorProvider) {
    return this.#compile(this.#getExecutor(executorProvider));
  }
  async execute(executorProvider) {
    const executor = this.#getExecutor(executorProvider);
    return executor.executeQuery(this.#compile(executor));
  }
  #getExecutor(executorProvider) {
    const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
    return this.#props.plugins !== void 0 ? executor.withPlugins(this.#props.plugins) : executor;
  }
  #toOperationNode(executor) {
    return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
  }
  #compile(executor) {
    return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
  }
}
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}
class AliasedRawBuilderImpl {
  #rawBuilder;
  #alias;
  constructor(rawBuilder, alias) {
    this.#rawBuilder = rawBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#rawBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get rawBuilder() {
    return this.#rawBuilder;
  }
  toOperationNode() {
    return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
const sql = Object.assign((sqlFragments, ...parameters) => {
  return createRawBuilder({
    queryId: createQueryId(),
    rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])
  });
}, {
  ref(columnReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseStringReference(columnReference))
    });
  },
  val(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseValueExpression(value))
    });
  },
  value(value) {
    return this.val(value);
  },
  table(tableReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseTable(tableReference))
    });
  },
  id(...ids) {
    const fragments = new Array(ids.length + 1).fill(".");
    fragments[0] = "";
    fragments[fragments.length - 1] = "";
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
    });
  },
  lit(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
    });
  },
  literal(value) {
    return this.lit(value);
  },
  raw(sql2) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithSql(sql2)
    });
  },
  join(array2, separator = sql`, `) {
    const nodes = new Array(Math.max(2 * array2.length - 1, 0));
    const sep = separator.toOperationNode();
    for (let i = 0; i < array2.length; ++i) {
      nodes[2 * i] = parseParameter(array2[i]);
      if (i !== array2.length - 1) {
        nodes[2 * i + 1] = sep;
      }
    }
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChildren(nodes)
    });
  }
});
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}
class OperationNodeVisitor {
  nodeStack = [];
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
  #visitors = freeze({
    AliasNode: this.visitAlias.bind(this),
    ColumnNode: this.visitColumn.bind(this),
    IdentifierNode: this.visitIdentifier.bind(this),
    SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
    RawNode: this.visitRaw.bind(this),
    ReferenceNode: this.visitReference.bind(this),
    SelectQueryNode: this.visitSelectQuery.bind(this),
    SelectionNode: this.visitSelection.bind(this),
    TableNode: this.visitTable.bind(this),
    FromNode: this.visitFrom.bind(this),
    SelectAllNode: this.visitSelectAll.bind(this),
    AndNode: this.visitAnd.bind(this),
    OrNode: this.visitOr.bind(this),
    ValueNode: this.visitValue.bind(this),
    ValueListNode: this.visitValueList.bind(this),
    PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
    ParensNode: this.visitParens.bind(this),
    JoinNode: this.visitJoin.bind(this),
    OperatorNode: this.visitOperator.bind(this),
    WhereNode: this.visitWhere.bind(this),
    InsertQueryNode: this.visitInsertQuery.bind(this),
    DeleteQueryNode: this.visitDeleteQuery.bind(this),
    ReturningNode: this.visitReturning.bind(this),
    CreateTableNode: this.visitCreateTable.bind(this),
    AddColumnNode: this.visitAddColumn.bind(this),
    ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
    DropTableNode: this.visitDropTable.bind(this),
    DataTypeNode: this.visitDataType.bind(this),
    OrderByNode: this.visitOrderBy.bind(this),
    OrderByItemNode: this.visitOrderByItem.bind(this),
    GroupByNode: this.visitGroupBy.bind(this),
    GroupByItemNode: this.visitGroupByItem.bind(this),
    UpdateQueryNode: this.visitUpdateQuery.bind(this),
    ColumnUpdateNode: this.visitColumnUpdate.bind(this),
    LimitNode: this.visitLimit.bind(this),
    OffsetNode: this.visitOffset.bind(this),
    OnConflictNode: this.visitOnConflict.bind(this),
    OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
    CreateIndexNode: this.visitCreateIndex.bind(this),
    DropIndexNode: this.visitDropIndex.bind(this),
    ListNode: this.visitList.bind(this),
    PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
    ReferencesNode: this.visitReferences.bind(this),
    CheckConstraintNode: this.visitCheckConstraint.bind(this),
    WithNode: this.visitWith.bind(this),
    CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
    HavingNode: this.visitHaving.bind(this),
    CreateSchemaNode: this.visitCreateSchema.bind(this),
    DropSchemaNode: this.visitDropSchema.bind(this),
    AlterTableNode: this.visitAlterTable.bind(this),
    DropColumnNode: this.visitDropColumn.bind(this),
    RenameColumnNode: this.visitRenameColumn.bind(this),
    AlterColumnNode: this.visitAlterColumn.bind(this),
    ModifyColumnNode: this.visitModifyColumn.bind(this),
    AddConstraintNode: this.visitAddConstraint.bind(this),
    DropConstraintNode: this.visitDropConstraint.bind(this),
    RenameConstraintNode: this.visitRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
    CreateViewNode: this.visitCreateView.bind(this),
    RefreshMaterializedViewNode: this.visitRefreshMaterializedView.bind(this),
    DropViewNode: this.visitDropView.bind(this),
    GeneratedNode: this.visitGenerated.bind(this),
    DefaultValueNode: this.visitDefaultValue.bind(this),
    OnNode: this.visitOn.bind(this),
    ValuesNode: this.visitValues.bind(this),
    SelectModifierNode: this.visitSelectModifier.bind(this),
    CreateTypeNode: this.visitCreateType.bind(this),
    DropTypeNode: this.visitDropType.bind(this),
    ExplainNode: this.visitExplain.bind(this),
    DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.visitAggregateFunction.bind(this),
    OverNode: this.visitOver.bind(this),
    PartitionByNode: this.visitPartitionBy.bind(this),
    PartitionByItemNode: this.visitPartitionByItem.bind(this),
    SetOperationNode: this.visitSetOperation.bind(this),
    BinaryOperationNode: this.visitBinaryOperation.bind(this),
    UnaryOperationNode: this.visitUnaryOperation.bind(this),
    UsingNode: this.visitUsing.bind(this),
    FunctionNode: this.visitFunction.bind(this),
    CaseNode: this.visitCase.bind(this),
    WhenNode: this.visitWhen.bind(this),
    JSONReferenceNode: this.visitJSONReference.bind(this),
    JSONPathNode: this.visitJSONPath.bind(this),
    JSONPathLegNode: this.visitJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
    TupleNode: this.visitTuple.bind(this),
    MergeQueryNode: this.visitMergeQuery.bind(this),
    MatchedNode: this.visitMatched.bind(this),
    AddIndexNode: this.visitAddIndex.bind(this),
    CastNode: this.visitCast.bind(this),
    FetchNode: this.visitFetch.bind(this),
    TopNode: this.visitTop.bind(this),
    OutputNode: this.visitOutput.bind(this),
    OrActionNode: this.visitOrAction.bind(this),
    CollateNode: this.visitCollate.bind(this)
  });
  visitNode = (node2) => {
    this.nodeStack.push(node2);
    this.#visitors[node2.kind](node2);
    this.nodeStack.pop();
  };
}
const LIT_WRAP_REGEX = /'/g;
class DefaultQueryCompiler extends OperationNodeVisitor {
  #sql = "";
  #parameters = [];
  get numParameters() {
    return this.#parameters.length;
  }
  compileQuery(node2, queryId) {
    this.#sql = "";
    this.#parameters = [];
    this.nodeStack.splice(0, this.nodeStack.length);
    this.visitNode(node2);
    return freeze({
      query: node2,
      queryId,
      sql: this.getSql(),
      parameters: [...this.#parameters]
    });
  }
  getSql() {
    return this.#sql;
  }
  visitSelectQuery(node2) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
    if (this.parentNode === void 0 && node2.explain) {
      this.visitNode(node2.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node2.with) {
      this.visitNode(node2.with);
      this.append(" ");
    }
    this.append("select");
    if (node2.distinctOn) {
      this.append(" ");
      this.compileDistinctOn(node2.distinctOn);
    }
    if (node2.frontModifiers?.length) {
      this.append(" ");
      this.compileList(node2.frontModifiers, " ");
    }
    if (node2.top) {
      this.append(" ");
      this.visitNode(node2.top);
    }
    if (node2.selections) {
      this.append(" ");
      this.compileList(node2.selections);
    }
    if (node2.from) {
      this.append(" ");
      this.visitNode(node2.from);
    }
    if (node2.joins) {
      this.append(" ");
      this.compileList(node2.joins, " ");
    }
    if (node2.where) {
      this.append(" ");
      this.visitNode(node2.where);
    }
    if (node2.groupBy) {
      this.append(" ");
      this.visitNode(node2.groupBy);
    }
    if (node2.having) {
      this.append(" ");
      this.visitNode(node2.having);
    }
    if (node2.setOperations) {
      this.append(" ");
      this.compileList(node2.setOperations, " ");
    }
    if (node2.orderBy) {
      this.append(" ");
      this.visitNode(node2.orderBy);
    }
    if (node2.limit) {
      this.append(" ");
      this.visitNode(node2.limit);
    }
    if (node2.offset) {
      this.append(" ");
      this.visitNode(node2.offset);
    }
    if (node2.fetch) {
      this.append(" ");
      this.visitNode(node2.fetch);
    }
    if (node2.endModifiers?.length) {
      this.append(" ");
      this.compileList(this.sortSelectModifiers([...node2.endModifiers]), " ");
    }
    if (wrapInParens) {
      this.append(")");
    }
  }
  visitFrom(node2) {
    this.append("from ");
    this.compileList(node2.froms);
  }
  visitSelection(node2) {
    this.visitNode(node2.selection);
  }
  visitColumn(node2) {
    this.visitNode(node2.column);
  }
  compileDistinctOn(expressions) {
    this.append("distinct on (");
    this.compileList(expressions);
    this.append(")");
  }
  compileList(nodes, separator = ", ") {
    const lastIndex = nodes.length - 1;
    for (let i = 0; i <= lastIndex; i++) {
      this.visitNode(nodes[i]);
      if (i < lastIndex) {
        this.append(separator);
      }
    }
  }
  visitWhere(node2) {
    this.append("where ");
    this.visitNode(node2.where);
  }
  visitHaving(node2) {
    this.append("having ");
    this.visitNode(node2.having);
  }
  visitInsertQuery(node2) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode) && !WhenNode.is(this.parentNode);
    if (this.parentNode === void 0 && node2.explain) {
      this.visitNode(node2.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node2.with) {
      this.visitNode(node2.with);
      this.append(" ");
    }
    this.append(node2.replace ? "replace" : "insert");
    if (node2.ignore) {
      logOnce("`InsertQueryNode.ignore` is deprecated. Use `InsertQueryNode.orAction` instead.");
      this.append(" ignore");
    }
    if (node2.orAction) {
      this.append(" ");
      this.visitNode(node2.orAction);
    }
    if (node2.top) {
      this.append(" ");
      this.visitNode(node2.top);
    }
    if (node2.into) {
      this.append(" into ");
      this.visitNode(node2.into);
    }
    if (node2.columns) {
      this.append(" (");
      this.compileList(node2.columns);
      this.append(")");
    }
    if (node2.output) {
      this.append(" ");
      this.visitNode(node2.output);
    }
    if (node2.values) {
      this.append(" ");
      this.visitNode(node2.values);
    }
    if (node2.defaultValues) {
      this.append(" ");
      this.append("default values");
    }
    if (node2.onConflict) {
      this.append(" ");
      this.visitNode(node2.onConflict);
    }
    if (node2.onDuplicateKey) {
      this.append(" ");
      this.visitNode(node2.onDuplicateKey);
    }
    if (node2.returning) {
      this.append(" ");
      this.visitNode(node2.returning);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node2.endModifiers?.length) {
      this.append(" ");
      this.compileList(node2.endModifiers, " ");
    }
  }
  visitValues(node2) {
    this.append("values ");
    this.compileList(node2.values);
  }
  visitDeleteQuery(node2) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode);
    if (this.parentNode === void 0 && node2.explain) {
      this.visitNode(node2.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node2.with) {
      this.visitNode(node2.with);
      this.append(" ");
    }
    this.append("delete ");
    if (node2.top) {
      this.visitNode(node2.top);
      this.append(" ");
    }
    this.visitNode(node2.from);
    if (node2.output) {
      this.append(" ");
      this.visitNode(node2.output);
    }
    if (node2.using) {
      this.append(" ");
      this.visitNode(node2.using);
    }
    if (node2.joins) {
      this.append(" ");
      this.compileList(node2.joins, " ");
    }
    if (node2.where) {
      this.append(" ");
      this.visitNode(node2.where);
    }
    if (node2.orderBy) {
      this.append(" ");
      this.visitNode(node2.orderBy);
    }
    if (node2.limit) {
      this.append(" ");
      this.visitNode(node2.limit);
    }
    if (node2.returning) {
      this.append(" ");
      this.visitNode(node2.returning);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node2.endModifiers?.length) {
      this.append(" ");
      this.compileList(node2.endModifiers, " ");
    }
  }
  visitReturning(node2) {
    this.append("returning ");
    this.compileList(node2.selections);
  }
  visitAlias(node2) {
    this.visitNode(node2.node);
    this.append(" as ");
    this.visitNode(node2.alias);
  }
  visitReference(node2) {
    if (node2.table) {
      this.visitNode(node2.table);
      this.append(".");
    }
    this.visitNode(node2.column);
  }
  visitSelectAll(_) {
    this.append("*");
  }
  visitIdentifier(node2) {
    this.append(this.getLeftIdentifierWrapper());
    this.compileUnwrappedIdentifier(node2);
    this.append(this.getRightIdentifierWrapper());
  }
  compileUnwrappedIdentifier(node2) {
    if (!isString(node2.name)) {
      throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
    }
    this.append(this.sanitizeIdentifier(node2.name));
  }
  visitAnd(node2) {
    this.visitNode(node2.left);
    this.append(" and ");
    this.visitNode(node2.right);
  }
  visitOr(node2) {
    this.visitNode(node2.left);
    this.append(" or ");
    this.visitNode(node2.right);
  }
  visitValue(node2) {
    if (node2.immediate) {
      this.appendImmediateValue(node2.value);
    } else {
      this.appendValue(node2.value);
    }
  }
  visitValueList(node2) {
    this.append("(");
    this.compileList(node2.values);
    this.append(")");
  }
  visitTuple(node2) {
    this.append("(");
    this.compileList(node2.values);
    this.append(")");
  }
  visitPrimitiveValueList(node2) {
    this.append("(");
    const { values: values2 } = node2;
    for (let i = 0; i < values2.length; ++i) {
      this.appendValue(values2[i]);
      if (i !== values2.length - 1) {
        this.append(", ");
      }
    }
    this.append(")");
  }
  visitParens(node2) {
    this.append("(");
    this.visitNode(node2.node);
    this.append(")");
  }
  visitJoin(node2) {
    this.append(JOIN_TYPE_SQL[node2.joinType]);
    this.append(" ");
    this.visitNode(node2.table);
    if (node2.on) {
      this.append(" ");
      this.visitNode(node2.on);
    }
  }
  visitOn(node2) {
    this.append("on ");
    this.visitNode(node2.on);
  }
  visitRaw(node2) {
    const { sqlFragments, parameters: params } = node2;
    for (let i = 0; i < sqlFragments.length; ++i) {
      this.append(sqlFragments[i]);
      if (params.length > i) {
        this.visitNode(params[i]);
      }
    }
  }
  visitOperator(node2) {
    this.append(node2.operator);
  }
  visitTable(node2) {
    this.visitNode(node2.table);
  }
  visitSchemableIdentifier(node2) {
    if (node2.schema) {
      this.visitNode(node2.schema);
      this.append(".");
    }
    this.visitNode(node2.identifier);
  }
  visitCreateTable(node2) {
    this.append("create ");
    if (node2.frontModifiers && node2.frontModifiers.length > 0) {
      this.compileList(node2.frontModifiers, " ");
      this.append(" ");
    }
    if (node2.temporary) {
      this.append("temporary ");
    }
    this.append("table ");
    if (node2.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node2.table);
    if (node2.selectQuery) {
      this.append(" as ");
      this.visitNode(node2.selectQuery);
    } else {
      this.append(" (");
      this.compileList([...node2.columns, ...node2.constraints ?? []]);
      this.append(")");
      if (node2.onCommit) {
        this.append(" on commit ");
        this.append(node2.onCommit);
      }
      if (node2.endModifiers && node2.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node2.endModifiers, " ");
      }
    }
  }
  visitColumnDefinition(node2) {
    if (node2.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node2.column);
    this.append(" ");
    this.visitNode(node2.dataType);
    if (node2.unsigned) {
      this.append(" unsigned");
    }
    if (node2.frontModifiers && node2.frontModifiers.length > 0) {
      this.append(" ");
      this.compileList(node2.frontModifiers, " ");
    }
    if (node2.generated) {
      this.append(" ");
      this.visitNode(node2.generated);
    }
    if (node2.identity) {
      this.append(" identity");
    }
    if (node2.defaultTo) {
      this.append(" ");
      this.visitNode(node2.defaultTo);
    }
    if (node2.notNull) {
      this.append(" not null");
    }
    if (node2.unique) {
      this.append(" unique");
    }
    if (node2.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node2.primaryKey) {
      this.append(" primary key");
    }
    if (node2.autoIncrement) {
      this.append(" ");
      this.append(this.getAutoIncrement());
    }
    if (node2.references) {
      this.append(" ");
      this.visitNode(node2.references);
    }
    if (node2.check) {
      this.append(" ");
      this.visitNode(node2.check);
    }
    if (node2.endModifiers && node2.endModifiers.length > 0) {
      this.append(" ");
      this.compileList(node2.endModifiers, " ");
    }
  }
  getAutoIncrement() {
    return "auto_increment";
  }
  visitReferences(node2) {
    this.append("references ");
    this.visitNode(node2.table);
    this.append(" (");
    this.compileList(node2.columns);
    this.append(")");
    if (node2.onDelete) {
      this.append(" on delete ");
      this.append(node2.onDelete);
    }
    if (node2.onUpdate) {
      this.append(" on update ");
      this.append(node2.onUpdate);
    }
  }
  visitDropTable(node2) {
    this.append("drop table ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.table);
    if (node2.cascade) {
      this.append(" cascade");
    }
  }
  visitDataType(node2) {
    this.append(node2.dataType);
  }
  visitOrderBy(node2) {
    this.append("order by ");
    this.compileList(node2.items);
  }
  visitOrderByItem(node2) {
    this.visitNode(node2.orderBy);
    if (node2.collation) {
      this.append(" ");
      this.visitNode(node2.collation);
    }
    if (node2.direction) {
      this.append(" ");
      this.visitNode(node2.direction);
    }
    if (node2.nulls) {
      this.append(" nulls ");
      this.append(node2.nulls);
    }
  }
  visitGroupBy(node2) {
    this.append("group by ");
    this.compileList(node2.items);
  }
  visitGroupByItem(node2) {
    this.visitNode(node2.groupBy);
  }
  visitUpdateQuery(node2) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode) && !WhenNode.is(this.parentNode);
    if (this.parentNode === void 0 && node2.explain) {
      this.visitNode(node2.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node2.with) {
      this.visitNode(node2.with);
      this.append(" ");
    }
    this.append("update ");
    if (node2.top) {
      this.visitNode(node2.top);
      this.append(" ");
    }
    if (node2.table) {
      this.visitNode(node2.table);
      this.append(" ");
    }
    this.append("set ");
    if (node2.updates) {
      this.compileList(node2.updates);
    }
    if (node2.output) {
      this.append(" ");
      this.visitNode(node2.output);
    }
    if (node2.from) {
      this.append(" ");
      this.visitNode(node2.from);
    }
    if (node2.joins) {
      if (!node2.from) {
        throw new Error("Joins in an update query are only supported as a part of a PostgreSQL 'update set from join' query. If you want to create a MySQL 'update join set' query, see https://kysely.dev/docs/examples/update/my-sql-joins");
      }
      this.append(" ");
      this.compileList(node2.joins, " ");
    }
    if (node2.where) {
      this.append(" ");
      this.visitNode(node2.where);
    }
    if (node2.returning) {
      this.append(" ");
      this.visitNode(node2.returning);
    }
    if (node2.orderBy) {
      this.append(" ");
      this.visitNode(node2.orderBy);
    }
    if (node2.limit) {
      this.append(" ");
      this.visitNode(node2.limit);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node2.endModifiers?.length) {
      this.append(" ");
      this.compileList(node2.endModifiers, " ");
    }
  }
  visitColumnUpdate(node2) {
    this.visitNode(node2.column);
    this.append(" = ");
    this.visitNode(node2.value);
  }
  visitLimit(node2) {
    this.append("limit ");
    this.visitNode(node2.limit);
  }
  visitOffset(node2) {
    this.append("offset ");
    this.visitNode(node2.offset);
  }
  visitOnConflict(node2) {
    this.append("on conflict");
    if (node2.columns) {
      this.append(" (");
      this.compileList(node2.columns);
      this.append(")");
    } else if (node2.constraint) {
      this.append(" on constraint ");
      this.visitNode(node2.constraint);
    } else if (node2.indexExpression) {
      this.append(" (");
      this.visitNode(node2.indexExpression);
      this.append(")");
    }
    if (node2.indexWhere) {
      this.append(" ");
      this.visitNode(node2.indexWhere);
    }
    if (node2.doNothing === true) {
      this.append(" do nothing");
    } else if (node2.updates) {
      this.append(" do update set ");
      this.compileList(node2.updates);
      if (node2.updateWhere) {
        this.append(" ");
        this.visitNode(node2.updateWhere);
      }
    }
  }
  visitOnDuplicateKey(node2) {
    this.append("on duplicate key update ");
    this.compileList(node2.updates);
  }
  visitCreateIndex(node2) {
    this.append("create ");
    if (node2.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node2.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node2.name);
    if (node2.table) {
      this.append(" on ");
      this.visitNode(node2.table);
    }
    if (node2.using) {
      this.append(" using ");
      this.visitNode(node2.using);
    }
    if (node2.columns) {
      this.append(" (");
      this.compileList(node2.columns);
      this.append(")");
    }
    if (node2.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node2.where) {
      this.append(" ");
      this.visitNode(node2.where);
    }
  }
  visitDropIndex(node2) {
    this.append("drop index ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.name);
    if (node2.table) {
      this.append(" on ");
      this.visitNode(node2.table);
    }
    if (node2.cascade) {
      this.append(" cascade");
    }
  }
  visitCreateSchema(node2) {
    this.append("create schema ");
    if (node2.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node2.schema);
  }
  visitDropSchema(node2) {
    this.append("drop schema ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.schema);
    if (node2.cascade) {
      this.append(" cascade");
    }
  }
  visitPrimaryKeyConstraint(node2) {
    if (node2.name) {
      this.append("constraint ");
      this.visitNode(node2.name);
      this.append(" ");
    }
    this.append("primary key (");
    this.compileList(node2.columns);
    this.append(")");
    this.buildDeferrable(node2);
  }
  buildDeferrable(node2) {
    if (node2.deferrable !== void 0) {
      if (node2.deferrable) {
        this.append(" deferrable");
      } else {
        this.append(" not deferrable");
      }
    }
    if (node2.initiallyDeferred !== void 0) {
      if (node2.initiallyDeferred) {
        this.append(" initially deferred");
      } else {
        this.append(" initially immediate");
      }
    }
  }
  visitUniqueConstraint(node2) {
    if (node2.name) {
      this.append("constraint ");
      this.visitNode(node2.name);
      this.append(" ");
    }
    this.append("unique");
    if (node2.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    this.append(" (");
    this.compileList(node2.columns);
    this.append(")");
    this.buildDeferrable(node2);
  }
  visitCheckConstraint(node2) {
    if (node2.name) {
      this.append("constraint ");
      this.visitNode(node2.name);
      this.append(" ");
    }
    this.append("check (");
    this.visitNode(node2.expression);
    this.append(")");
  }
  visitForeignKeyConstraint(node2) {
    if (node2.name) {
      this.append("constraint ");
      this.visitNode(node2.name);
      this.append(" ");
    }
    this.append("foreign key (");
    this.compileList(node2.columns);
    this.append(") ");
    this.visitNode(node2.references);
    if (node2.onDelete) {
      this.append(" on delete ");
      this.append(node2.onDelete);
    }
    if (node2.onUpdate) {
      this.append(" on update ");
      this.append(node2.onUpdate);
    }
    this.buildDeferrable(node2);
  }
  visitList(node2) {
    this.compileList(node2.items);
  }
  visitWith(node2) {
    this.append("with ");
    if (node2.recursive) {
      this.append("recursive ");
    }
    this.compileList(node2.expressions);
  }
  visitCommonTableExpression(node2) {
    this.visitNode(node2.name);
    this.append(" as ");
    if (isBoolean(node2.materialized)) {
      if (!node2.materialized) {
        this.append("not ");
      }
      this.append("materialized ");
    }
    this.visitNode(node2.expression);
  }
  visitCommonTableExpressionName(node2) {
    this.visitNode(node2.table);
    if (node2.columns) {
      this.append("(");
      this.compileList(node2.columns);
      this.append(")");
    }
  }
  visitAlterTable(node2) {
    this.append("alter table ");
    this.visitNode(node2.table);
    this.append(" ");
    if (node2.renameTo) {
      this.append("rename to ");
      this.visitNode(node2.renameTo);
    }
    if (node2.setSchema) {
      this.append("set schema ");
      this.visitNode(node2.setSchema);
    }
    if (node2.addConstraint) {
      this.visitNode(node2.addConstraint);
    }
    if (node2.dropConstraint) {
      this.visitNode(node2.dropConstraint);
    }
    if (node2.renameConstraint) {
      this.visitNode(node2.renameConstraint);
    }
    if (node2.columnAlterations) {
      this.compileColumnAlterations(node2.columnAlterations);
    }
    if (node2.addIndex) {
      this.visitNode(node2.addIndex);
    }
    if (node2.dropIndex) {
      this.visitNode(node2.dropIndex);
    }
  }
  visitAddColumn(node2) {
    this.append("add column ");
    this.visitNode(node2.column);
  }
  visitRenameColumn(node2) {
    this.append("rename column ");
    this.visitNode(node2.column);
    this.append(" to ");
    this.visitNode(node2.renameTo);
  }
  visitDropColumn(node2) {
    this.append("drop column ");
    this.visitNode(node2.column);
  }
  visitAlterColumn(node2) {
    this.append("alter column ");
    this.visitNode(node2.column);
    this.append(" ");
    if (node2.dataType) {
      if (this.announcesNewColumnDataType()) {
        this.append("type ");
      }
      this.visitNode(node2.dataType);
      if (node2.dataTypeExpression) {
        this.append("using ");
        this.visitNode(node2.dataTypeExpression);
      }
    }
    if (node2.setDefault) {
      this.append("set default ");
      this.visitNode(node2.setDefault);
    }
    if (node2.dropDefault) {
      this.append("drop default");
    }
    if (node2.setNotNull) {
      this.append("set not null");
    }
    if (node2.dropNotNull) {
      this.append("drop not null");
    }
  }
  visitModifyColumn(node2) {
    this.append("modify column ");
    this.visitNode(node2.column);
  }
  visitAddConstraint(node2) {
    this.append("add ");
    this.visitNode(node2.constraint);
  }
  visitDropConstraint(node2) {
    this.append("drop constraint ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.constraintName);
    if (node2.modifier === "cascade") {
      this.append(" cascade");
    } else if (node2.modifier === "restrict") {
      this.append(" restrict");
    }
  }
  visitRenameConstraint(node2) {
    this.append("rename constraint ");
    this.visitNode(node2.oldName);
    this.append(" to ");
    this.visitNode(node2.newName);
  }
  visitSetOperation(node2) {
    this.append(node2.operator);
    this.append(" ");
    if (node2.all) {
      this.append("all ");
    }
    this.visitNode(node2.expression);
  }
  visitCreateView(node2) {
    this.append("create ");
    if (node2.orReplace) {
      this.append("or replace ");
    }
    if (node2.materialized) {
      this.append("materialized ");
    }
    if (node2.temporary) {
      this.append("temporary ");
    }
    this.append("view ");
    if (node2.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node2.name);
    this.append(" ");
    if (node2.columns) {
      this.append("(");
      this.compileList(node2.columns);
      this.append(") ");
    }
    if (node2.as) {
      this.append("as ");
      this.visitNode(node2.as);
    }
  }
  visitRefreshMaterializedView(node2) {
    this.append("refresh materialized view ");
    if (node2.concurrently) {
      this.append("concurrently ");
    }
    this.visitNode(node2.name);
    if (node2.withNoData) {
      this.append(" with no data");
    } else {
      this.append(" with data");
    }
  }
  visitDropView(node2) {
    this.append("drop ");
    if (node2.materialized) {
      this.append("materialized ");
    }
    this.append("view ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.name);
    if (node2.cascade) {
      this.append(" cascade");
    }
  }
  visitGenerated(node2) {
    this.append("generated ");
    if (node2.always) {
      this.append("always ");
    }
    if (node2.byDefault) {
      this.append("by default ");
    }
    this.append("as ");
    if (node2.identity) {
      this.append("identity");
    }
    if (node2.expression) {
      this.append("(");
      this.visitNode(node2.expression);
      this.append(")");
    }
    if (node2.stored) {
      this.append(" stored");
    }
  }
  visitDefaultValue(node2) {
    this.append("default ");
    this.visitNode(node2.defaultValue);
  }
  visitSelectModifier(node2) {
    if (node2.rawModifier) {
      this.visitNode(node2.rawModifier);
    } else {
      this.append(SELECT_MODIFIER_SQL[node2.modifier]);
    }
    if (node2.of) {
      this.append(" of ");
      this.compileList(node2.of, ", ");
    }
  }
  visitCreateType(node2) {
    this.append("create type ");
    this.visitNode(node2.name);
    if (node2.enum) {
      this.append(" as enum ");
      this.visitNode(node2.enum);
    }
  }
  visitDropType(node2) {
    this.append("drop type ");
    if (node2.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node2.name);
  }
  visitExplain(node2) {
    this.append("explain");
    if (node2.options || node2.format) {
      this.append(" ");
      this.append(this.getLeftExplainOptionsWrapper());
      if (node2.options) {
        this.visitNode(node2.options);
        if (node2.format) {
          this.append(this.getExplainOptionsDelimiter());
        }
      }
      if (node2.format) {
        this.append("format");
        this.append(this.getExplainOptionAssignment());
        this.append(node2.format);
      }
      this.append(this.getRightExplainOptionsWrapper());
    }
  }
  visitDefaultInsertValue(_) {
    this.append("default");
  }
  visitAggregateFunction(node2) {
    this.append(node2.func);
    this.append("(");
    if (node2.distinct) {
      this.append("distinct ");
    }
    this.compileList(node2.aggregated);
    if (node2.orderBy) {
      this.append(" ");
      this.visitNode(node2.orderBy);
    }
    this.append(")");
    if (node2.withinGroup) {
      this.append(" within group (");
      this.visitNode(node2.withinGroup);
      this.append(")");
    }
    if (node2.filter) {
      this.append(" filter(");
      this.visitNode(node2.filter);
      this.append(")");
    }
    if (node2.over) {
      this.append(" ");
      this.visitNode(node2.over);
    }
  }
  visitOver(node2) {
    this.append("over(");
    if (node2.partitionBy) {
      this.visitNode(node2.partitionBy);
      if (node2.orderBy) {
        this.append(" ");
      }
    }
    if (node2.orderBy) {
      this.visitNode(node2.orderBy);
    }
    this.append(")");
  }
  visitPartitionBy(node2) {
    this.append("partition by ");
    this.compileList(node2.items);
  }
  visitPartitionByItem(node2) {
    this.visitNode(node2.partitionBy);
  }
  visitBinaryOperation(node2) {
    this.visitNode(node2.leftOperand);
    this.append(" ");
    this.visitNode(node2.operator);
    this.append(" ");
    this.visitNode(node2.rightOperand);
  }
  visitUnaryOperation(node2) {
    this.visitNode(node2.operator);
    if (!this.isMinusOperator(node2.operator)) {
      this.append(" ");
    }
    this.visitNode(node2.operand);
  }
  isMinusOperator(node2) {
    return OperatorNode.is(node2) && node2.operator === "-";
  }
  visitUsing(node2) {
    this.append("using ");
    this.compileList(node2.tables);
  }
  visitFunction(node2) {
    this.append(node2.func);
    this.append("(");
    this.compileList(node2.arguments);
    this.append(")");
  }
  visitCase(node2) {
    this.append("case");
    if (node2.value) {
      this.append(" ");
      this.visitNode(node2.value);
    }
    if (node2.when) {
      this.append(" ");
      this.compileList(node2.when, " ");
    }
    if (node2.else) {
      this.append(" else ");
      this.visitNode(node2.else);
    }
    this.append(" end");
    if (node2.isStatement) {
      this.append(" case");
    }
  }
  visitWhen(node2) {
    this.append("when ");
    this.visitNode(node2.condition);
    if (node2.result) {
      this.append(" then ");
      this.visitNode(node2.result);
    }
  }
  visitJSONReference(node2) {
    this.visitNode(node2.reference);
    this.visitNode(node2.traversal);
  }
  visitJSONPath(node2) {
    if (node2.inOperator) {
      this.visitNode(node2.inOperator);
    }
    this.append("'$");
    for (const pathLeg of node2.pathLegs) {
      this.visitNode(pathLeg);
    }
    this.append("'");
  }
  visitJSONPathLeg(node2) {
    const isArrayLocation = node2.type === "ArrayLocation";
    this.append(isArrayLocation ? "[" : ".");
    this.append(String(node2.value));
    if (isArrayLocation) {
      this.append("]");
    }
  }
  visitJSONOperatorChain(node2) {
    for (let i = 0, len = node2.values.length; i < len; i++) {
      if (i === len - 1) {
        this.visitNode(node2.operator);
      } else {
        this.append("->");
      }
      this.visitNode(node2.values[i]);
    }
  }
  visitMergeQuery(node2) {
    if (node2.with) {
      this.visitNode(node2.with);
      this.append(" ");
    }
    this.append("merge ");
    if (node2.top) {
      this.visitNode(node2.top);
      this.append(" ");
    }
    this.append("into ");
    this.visitNode(node2.into);
    if (node2.using) {
      this.append(" ");
      this.visitNode(node2.using);
    }
    if (node2.whens) {
      this.append(" ");
      this.compileList(node2.whens, " ");
    }
    if (node2.returning) {
      this.append(" ");
      this.visitNode(node2.returning);
    }
    if (node2.output) {
      this.append(" ");
      this.visitNode(node2.output);
    }
    if (node2.endModifiers?.length) {
      this.append(" ");
      this.compileList(node2.endModifiers, " ");
    }
  }
  visitMatched(node2) {
    if (node2.not) {
      this.append("not ");
    }
    this.append("matched");
    if (node2.bySource) {
      this.append(" by source");
    }
  }
  visitAddIndex(node2) {
    this.append("add ");
    if (node2.unique) {
      this.append("unique ");
    }
    this.append("index ");
    this.visitNode(node2.name);
    if (node2.columns) {
      this.append(" (");
      this.compileList(node2.columns);
      this.append(")");
    }
    if (node2.using) {
      this.append(" using ");
      this.visitNode(node2.using);
    }
  }
  visitCast(node2) {
    this.append("cast(");
    this.visitNode(node2.expression);
    this.append(" as ");
    this.visitNode(node2.dataType);
    this.append(")");
  }
  visitFetch(node2) {
    this.append("fetch next ");
    this.visitNode(node2.rowCount);
    this.append(` rows ${node2.modifier}`);
  }
  visitOutput(node2) {
    this.append("output ");
    this.compileList(node2.selections);
  }
  visitTop(node2) {
    this.append(`top(${node2.expression})`);
    if (node2.modifiers) {
      this.append(` ${node2.modifiers}`);
    }
  }
  visitOrAction(node2) {
    this.append(node2.action);
  }
  visitCollate(node2) {
    this.append("collate ");
    this.visitNode(node2.collation);
  }
  append(str) {
    this.#sql += str;
  }
  appendValue(parameter) {
    this.addParameter(parameter);
    this.append(this.getCurrentParameterPlaceholder());
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getCurrentParameterPlaceholder() {
    return "$" + this.numParameters;
  }
  getLeftExplainOptionsWrapper() {
    return "(";
  }
  getExplainOptionAssignment() {
    return " ";
  }
  getExplainOptionsDelimiter() {
    return ", ";
  }
  getRightExplainOptionsWrapper() {
    return ")";
  }
  sanitizeIdentifier(identifier) {
    const leftWrap = this.getLeftIdentifierWrapper();
    const rightWrap = this.getRightIdentifierWrapper();
    let sanitized = "";
    for (const c of identifier) {
      sanitized += c;
      if (c === leftWrap) {
        sanitized += leftWrap;
      } else if (c === rightWrap) {
        sanitized += rightWrap;
      }
    }
    return sanitized;
  }
  sanitizeStringLiteral(value) {
    return value.replace(LIT_WRAP_REGEX, "''");
  }
  addParameter(parameter) {
    this.#parameters.push(parameter);
  }
  appendImmediateValue(value) {
    if (isString(value)) {
      this.appendStringLiteral(value);
    } else if (isNumber(value) || isBoolean(value) || isBigInt(value)) {
      this.append(value.toString());
    } else if (isNull(value)) {
      this.append("null");
    } else if (isDate(value)) {
      this.appendImmediateValue(value.toISOString());
    } else {
      throw new Error(`invalid immediate value ${value}`);
    }
  }
  appendStringLiteral(value) {
    this.append("'");
    this.append(this.sanitizeStringLiteral(value));
    this.append("'");
  }
  sortSelectModifiers(arr) {
    arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
    return freeze(arr);
  }
  compileColumnAlterations(columnAlterations) {
    this.compileList(columnAlterations);
  }
  /**
   * controls whether the dialect adds a "type" keyword before a column's new data
   * type in an ALTER TABLE statement.
   */
  announcesNewColumnDataType() {
    return true;
  }
}
const SELECT_MODIFIER_SQL = freeze({
  ForKeyShare: "for key share",
  ForNoKeyUpdate: "for no key update",
  ForUpdate: "for update",
  ForShare: "for share",
  NoWait: "nowait",
  SkipLocked: "skip locked",
  Distinct: "distinct"
});
const SELECT_MODIFIER_PRIORITY = freeze({
  ForKeyShare: 1,
  ForNoKeyUpdate: 1,
  ForUpdate: 1,
  ForShare: 1,
  NoWait: 2,
  SkipLocked: 2,
  Distinct: 0
});
const JOIN_TYPE_SQL = freeze({
  InnerJoin: "inner join",
  LeftJoin: "left join",
  RightJoin: "right join",
  FullJoin: "full join",
  CrossJoin: "cross join",
  LateralInnerJoin: "inner join lateral",
  LateralLeftJoin: "left join lateral",
  LateralCrossJoin: "cross join lateral",
  OuterApply: "outer apply",
  CrossApply: "cross apply",
  Using: "using"
});
const CompiledQuery = freeze({
  raw(sql2, parameters = []) {
    return freeze({
      sql: sql2,
      query: RawNode.createWithSql(sql2),
      parameters: freeze(parameters),
      queryId: createQueryId()
    });
  }
});
class DialectAdapterBase {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
}
function parseSavepointCommand(command, savepointName) {
  return RawNode.createWithChildren([
    RawNode.createWithSql(`${command} `),
    IdentifierNode.create(savepointName)
    // ensures savepointName gets sanitized
  ]);
}
class SqliteDriver {
  #config;
  #connectionMutex = new ConnectionMutex();
  #db;
  #connection;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  async init() {
    this.#db = isFunction(this.#config.database) ? await this.#config.database() : this.#config.database;
    this.#connection = new SqliteConnection(this.#db);
    if (this.#config.onCreateConnection) {
      await this.#config.onCreateConnection(this.#connection);
    }
  }
  async acquireConnection() {
    await this.#connectionMutex.lock();
    return this.#connection;
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection() {
    this.#connectionMutex.unlock();
  }
  async destroy() {
    this.#db?.close();
  }
}
class SqliteConnection {
  #db;
  constructor(db2) {
    this.#db = db2;
  }
  executeQuery(compiledQuery) {
    const { sql: sql2, parameters } = compiledQuery;
    const stmt = this.#db.prepare(sql2);
    if (stmt.reader) {
      return Promise.resolve({
        rows: stmt.all(parameters)
      });
    }
    const { changes, lastInsertRowid } = stmt.run(parameters);
    return Promise.resolve({
      numAffectedRows: changes !== void 0 && changes !== null ? BigInt(changes) : void 0,
      insertId: lastInsertRowid !== void 0 && lastInsertRowid !== null ? BigInt(lastInsertRowid) : void 0,
      rows: []
    });
  }
  async *streamQuery(compiledQuery, _chunkSize) {
    const { sql: sql2, parameters, query } = compiledQuery;
    const stmt = this.#db.prepare(sql2);
    if (SelectQueryNode.is(query)) {
      const iter = stmt.iterate(parameters);
      for (const row of iter) {
        yield {
          rows: [row]
        };
      }
    } else {
      throw new Error("Sqlite driver only supports streaming of select queries");
    }
  }
}
class ConnectionMutex {
  #promise;
  #resolve;
  async lock() {
    while (this.#promise) {
      await this.#promise;
    }
    this.#promise = new Promise((resolve2) => {
      this.#resolve = resolve2;
    });
  }
  unlock() {
    const resolve2 = this.#resolve;
    this.#promise = void 0;
    this.#resolve = void 0;
    resolve2?.();
  }
}
const ID_WRAP_REGEX = /"/g;
class SqliteQueryCompiler extends DefaultQueryCompiler {
  visitOrAction(node2) {
    this.append("or ");
    this.append(node2.action);
  }
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getAutoIncrement() {
    return "autoincrement";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX, '""');
  }
  visitDefaultInsertValue(_) {
    this.append("null");
  }
}
const DEFAULT_MIGRATION_TABLE = "kysely_migration";
const DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
freeze({ __noMigrations__: true });
class SqliteIntrospector {
  #db;
  constructor(db2) {
    this.#db = db2;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    return await this.#getTableMetadata(options);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #tablesQuery(qb, options) {
    let tablesQuery = qb.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
    if (!options.withInternalKyselyTables) {
      tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    return tablesQuery;
  }
  async #getTableMetadata(options) {
    const tablesResult = await this.#tablesQuery(this.#db, options).execute();
    const tableMetadata = await this.#db.with("table_list", (qb) => this.#tablesQuery(qb, options)).selectFrom([
      "table_list as tl",
      sql`pragma_table_info(tl.name)`.as("p")
    ]).select([
      "tl.name as table",
      "p.cid",
      "p.name",
      "p.type",
      "p.notnull",
      "p.dflt_value",
      "p.pk"
    ]).orderBy("tl.name").orderBy("p.cid").execute();
    const columnsByTable = {};
    for (const row of tableMetadata) {
      columnsByTable[row.table] ??= [];
      columnsByTable[row.table].push(row);
    }
    return tablesResult.map(({ name, sql: sql2, type: type2 }) => {
      let autoIncrementCol = sql2?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.trimStart()?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
      const columns = columnsByTable[name] ?? [];
      if (!autoIncrementCol) {
        const pkCols = columns.filter((r) => r.pk > 0);
        if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
          autoIncrementCol = pkCols[0].name;
        }
      }
      return {
        name,
        isView: type2 === "view",
        columns: columns.map((col) => ({
          name: col.name,
          dataType: col.type,
          isNullable: !col.notnull,
          isAutoIncrementing: col.name === autoIncrementCol,
          hasDefaultValue: col.dflt_value != null,
          comment: void 0
        }))
      };
    });
  }
}
class SqliteAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(_db, _opt) {
  }
  async releaseMigrationLock(_db, _opt) {
  }
}
class SqliteDialect {
  #config;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  createDriver() {
    return new SqliteDriver(this.#config);
  }
  createQueryCompiler() {
    return new SqliteQueryCompiler();
  }
  createAdapter() {
    return new SqliteAdapter();
  }
  createIntrospector(db2) {
    return new SqliteIntrospector(db2);
  }
}
const initDb = (dbPath) => {
  const db2 = new Database(dbPath);
  const tableExists = db2.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='drawings'").get();
  if (!tableExists) {
    console.log("Database not initialized. Running schema.sql...");
    try {
      const possiblePaths = [
        path.join(__dirname, "schema.sql"),
        path.join(__dirname, "../database/schema.sql"),
        path.join(process.cwd(), "src/main/database/schema.sql")
      ];
      let schemaPath = "";
      for (const p of possiblePaths) {
        if (fs.existsSync(p)) {
          schemaPath = p;
          break;
        }
      }
      if (schemaPath) {
        const sql2 = fs.readFileSync(schemaPath, "utf8");
        db2.exec(sql2);
        console.log(`Database schema initialized from ${schemaPath}`);
      } else {
        db2.exec(`
          CREATE TABLE IF NOT EXISTS drawings (
              id TEXT PRIMARY KEY,
              title TEXT NOT NULL,
              fileName TEXT NOT NULL,
              windowCount INTEGER DEFAULT 0,
              totalArea REAL DEFAULT 0,
              createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
          );
          CREATE TABLE IF NOT EXISTS windows (
              id TEXT PRIMARY KEY,
              drawingId TEXT,
              name TEXT NOT NULL,
              category TEXT NOT NULL,
              shapeType TEXT NOT NULL,
              width REAL NOT NULL,
              height REAL NOT NULL,
              area REAL NOT NULL,
              glassArea REAL DEFAULT 0,
              perimeter REAL NOT NULL,
              frameWeight REAL DEFAULT 0,
              points TEXT NOT NULL,
              createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (drawingId) REFERENCES drawings(id) ON DELETE CASCADE
          );
        `);
      }
    } catch (err2) {
      console.error("Failed to initialize database schema:", err2);
    }
  } else {
    console.log("Database already initialized. Skipping schema execution.");
  }
  return new Kysely({
    dialect: new SqliteDialect({
      database: db2
    })
  });
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    require$$0$9.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const native = { randomUUID: require$$0$9.randomUUID };
function _v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  return _v4(options);
}
const fastify = Fastify({
  logger: true
});
fastify.register(cors, { origin: "*" });
fastify.setValidatorCompiler(validatorCompiler);
fastify.setSerializerCompiler(serializerCompiler);
const db = initDb("./dxf-app.db");
const startServer = async (port = 3001) => {
  const api = fastify.withTypeProvider();
  api.get("/api/drawings", {
    schema: { response: { 200: DrawingResponseSchema } }
  }, async () => {
    const drawings = await db.selectFrom("drawings").selectAll().orderBy("createdAt desc").execute();
    return { success: true, data: drawings };
  });
  api.post("/api/drawings", {
    schema: {
      body: object({
        title: string(),
        fileName: string(),
        windows: array(WindowItemSchema.omit({ id: true, drawingId: true, createdAt: true }))
      }),
      response: { 201: DrawingResponseSchema }
    }
  }, async (request2, reply2) => {
    const { title: title2, fileName, windows } = request2.body;
    const drawingId = v4();
    const createdAt = (/* @__PURE__ */ new Date()).toISOString();
    const totalArea = windows.reduce((sum, w) => sum + w.area, 0);
    const drawing = {
      id: drawingId,
      title: title2,
      fileName,
      windowCount: windows.length,
      totalArea,
      createdAt
    };
    await db.insertInto("drawings").values(drawing).execute();
    if (windows.length > 0) {
      const windowEntries = windows.map((win) => ({
        ...win,
        id: v4(),
        drawingId,
        points: JSON.stringify(win.points),
        createdAt
      }));
      await db.insertInto("windows").values(windowEntries).execute();
    }
    reply2.status(201).send({ success: true, data: drawing });
  });
  api.get("/api/drawings/:id/windows", {
    schema: {
      params: object({ id: string().uuid() }),
      response: { 200: WindowResponseSchema }
    }
  }, async (request2) => {
    const { id: id2 } = request2.params;
    const windows = await db.selectFrom("windows").where("drawingId", "=", id2).selectAll().execute();
    return {
      success: true,
      data: windows.map((w) => ({ ...w, points: JSON.parse(w.points) }))
    };
  });
  api.delete("/api/drawings/:id", {
    schema: {
      params: object({ id: string().uuid() })
    }
  }, async (request2) => {
    const { id: id2 } = request2.params;
    await db.deleteFrom("drawings").where("id", "=", id2).execute();
    return { success: true };
  });
  api.get("/api/windows", async () => {
    const windows = await db.selectFrom("windows").selectAll().execute();
    return {
      success: true,
      data: windows.map((w) => ({ ...w, points: JSON.parse(w.points) }))
    };
  });
  api.delete("/api/windows/all", async () => {
    await db.deleteFrom("windows").execute();
    await db.deleteFrom("drawings").execute();
    return { success: true };
  });
  try {
    await fastify.listen({ port, host: "0.0.0.0" });
    console.log(`Fastify server listening on http://localhost:${port}`);
  } catch (err2) {
    fastify.log.error(err2);
    process.exit(1);
  }
};
class DxfArrayScanner {
  constructor(data) {
    this._pointer = 0;
    this._eof = false;
    this._data = data;
  }
  /**
   * Gets the next group (code, value) from the array. A group is two consecutive elements
   * in the array. The first is the code, the second is the value.
   * @returns {{code: Number}|*}
   */
  next() {
    if (!this.hasNext()) {
      if (!this._eof)
        throw new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
      else
        throw new Error("Cannot call 'next' after EOF group has been read");
    }
    const group = {
      code: parseInt(this._data[this._pointer])
    };
    this._pointer++;
    group.value = parseGroupValue(group.code, this._data[this._pointer].trim());
    this._pointer++;
    if (group.code === 0 && group.value === "EOF")
      this._eof = true;
    this.lastReadGroup = group;
    return group;
  }
  peek() {
    if (!this.hasNext()) {
      if (!this._eof)
        throw new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
      else
        throw new Error("Cannot call 'next' after EOF group has been read");
    }
    const group = {
      code: parseInt(this._data[this._pointer])
    };
    group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());
    return group;
  }
  rewind(numberOfGroups = 1) {
    this._pointer = this._pointer - numberOfGroups * 2;
  }
  /**
   * Returns true if there is another code/value pair (2 elements in the array).
   * @returns {boolean}
   */
  hasNext() {
    if (this._eof) {
      return false;
    }
    if (this._pointer > this._data.length - 2) {
      return false;
    }
    return true;
  }
  /**
   * Returns true if the scanner is at the end of the array
   * @returns {boolean}
   */
  isEOF() {
    return this._eof;
  }
}
function parseGroupValue(code2, value) {
  if (code2 <= 9)
    return value;
  if (code2 >= 10 && code2 <= 59)
    return parseFloat(value);
  if (code2 >= 60 && code2 <= 99)
    return parseInt(value);
  if (code2 >= 100 && code2 <= 109)
    return value;
  if (code2 >= 110 && code2 <= 149)
    return parseFloat(value);
  if (code2 >= 160 && code2 <= 179)
    return parseInt(value);
  if (code2 >= 210 && code2 <= 239)
    return parseFloat(value);
  if (code2 >= 270 && code2 <= 289)
    return parseInt(value);
  if (code2 >= 290 && code2 <= 299)
    return parseBoolean(value);
  if (code2 >= 300 && code2 <= 369)
    return value;
  if (code2 >= 370 && code2 <= 389)
    return parseInt(value);
  if (code2 >= 390 && code2 <= 399)
    return value;
  if (code2 >= 400 && code2 <= 409)
    return parseInt(value);
  if (code2 >= 410 && code2 <= 419)
    return value;
  if (code2 >= 420 && code2 <= 429)
    return parseInt(value);
  if (code2 >= 430 && code2 <= 439)
    return value;
  if (code2 >= 440 && code2 <= 459)
    return parseInt(value);
  if (code2 >= 460 && code2 <= 469)
    return parseFloat(value);
  if (code2 >= 470 && code2 <= 481)
    return value;
  if (code2 === 999)
    return value;
  if (code2 >= 1e3 && code2 <= 1009)
    return value;
  if (code2 >= 1010 && code2 <= 1059)
    return parseFloat(value);
  if (code2 >= 1060 && code2 <= 1071)
    return parseInt(value);
  console.log("WARNING: Group code does not have a defined type: %j", { code: code2, value });
  return value;
}
function parseBoolean(str) {
  if (str === "0")
    return false;
  if (str === "1")
    return true;
  throw TypeError("String '" + str + "' cannot be cast to Boolean type");
}
const AUTO_CAD_COLOR_INDEX = [
  0,
  16711680,
  16776960,
  65280,
  65535,
  255,
  16711935,
  16777215,
  8421504,
  12632256,
  16711680,
  16744319,
  13369344,
  13395558,
  10027008,
  10046540,
  8323072,
  8339263,
  4980736,
  4990502,
  16727808,
  16752511,
  13382400,
  13401958,
  10036736,
  10051404,
  8331008,
  8343359,
  4985600,
  4992806,
  16744192,
  16760703,
  13395456,
  13408614,
  10046464,
  10056268,
  8339200,
  8347455,
  4990464,
  4995366,
  16760576,
  16768895,
  13408512,
  13415014,
  10056192,
  10061132,
  8347392,
  8351551,
  4995328,
  4997670,
  16776960,
  16777087,
  13421568,
  13421670,
  10000384,
  10000460,
  8355584,
  8355647,
  5000192,
  5000230,
  12582656,
  14679935,
  10079232,
  11717734,
  7510016,
  8755276,
  6258432,
  7307071,
  3755008,
  4344870,
  8388352,
  12582783,
  6736896,
  10079334,
  5019648,
  7510092,
  4161280,
  6258495,
  2509824,
  3755046,
  4194048,
  10485631,
  3394560,
  8375398,
  2529280,
  6264908,
  2064128,
  5209919,
  1264640,
  3099686,
  65280,
  8388479,
  52224,
  6736998,
  38912,
  5019724,
  32512,
  4161343,
  19456,
  2509862,
  65343,
  8388511,
  52275,
  6737023,
  38950,
  5019743,
  32543,
  4161359,
  19475,
  2509871,
  65407,
  8388543,
  52326,
  6737049,
  38988,
  5019762,
  32575,
  4161375,
  19494,
  2509881,
  65471,
  8388575,
  52377,
  6737074,
  39026,
  5019781,
  32607,
  4161391,
  19513,
  2509890,
  65535,
  8388607,
  52428,
  6737100,
  39064,
  5019800,
  32639,
  4161407,
  19532,
  2509900,
  49151,
  8380415,
  39372,
  6730444,
  29336,
  5014936,
  24447,
  4157311,
  14668,
  2507340,
  32767,
  8372223,
  26316,
  6724044,
  19608,
  5010072,
  16255,
  4153215,
  9804,
  2505036,
  16383,
  8364031,
  13260,
  6717388,
  9880,
  5005208,
  8063,
  4149119,
  4940,
  2502476,
  255,
  8355839,
  204,
  6710988,
  152,
  5000344,
  127,
  4145023,
  76,
  2500172,
  4129023,
  10452991,
  3342540,
  8349388,
  2490520,
  6245528,
  2031743,
  5193599,
  1245260,
  3089996,
  8323327,
  12550143,
  6684876,
  10053324,
  4980888,
  7490712,
  4128895,
  6242175,
  2490444,
  3745356,
  12517631,
  14647295,
  10027212,
  11691724,
  7471256,
  8735896,
  6226047,
  7290751,
  3735628,
  4335180,
  16711935,
  16744447,
  13369548,
  13395660,
  9961624,
  9981080,
  8323199,
  8339327,
  4980812,
  4990540,
  16711871,
  16744415,
  13369497,
  13395634,
  9961586,
  9981061,
  8323167,
  8339311,
  4980793,
  4990530,
  16711807,
  16744383,
  13369446,
  13395609,
  9961548,
  9981042,
  8323135,
  8339295,
  4980774,
  4990521,
  16711743,
  16744351,
  13369395,
  13395583,
  9961510,
  9981023,
  8323103,
  8339279,
  4980755,
  4990511,
  3355443,
  5987163,
  8684676,
  11382189,
  14079702,
  16777215
];
function getAcadColor$1(index) {
  return AUTO_CAD_COLOR_INDEX[index];
}
function parsePoint(scanner) {
  const point = {};
  scanner.rewind();
  let curr = scanner.next();
  let code2 = curr.code;
  point.x = curr.value;
  code2 += 10;
  curr = scanner.next();
  if (curr.code != code2)
    throw new Error("Expected code for point value to be " + code2 + " but got " + curr.code + ".");
  point.y = curr.value;
  code2 += 10;
  curr = scanner.next();
  if (curr.code != code2) {
    scanner.rewind();
    return point;
  }
  point.z = curr.value;
  return point;
}
function checkCommonEntityProperties(entity, curr, scanner) {
  switch (curr.code) {
    case 0:
      entity.type = curr.value;
      break;
    case 5:
      entity.handle = curr.value;
      break;
    case 6:
      entity.lineType = curr.value;
      break;
    case 8:
      entity.layer = curr.value;
      break;
    case 48:
      entity.lineTypeScale = curr.value;
      break;
    case 60:
      entity.visible = curr.value === 0;
      break;
    case 62:
      entity.colorIndex = curr.value;
      entity.color = getAcadColor$1(Math.abs(curr.value));
      break;
    case 67:
      entity.inPaperSpace = curr.value !== 0;
      break;
    case 100:
      break;
    case 101:
      while (curr.code != 0) {
        curr = scanner.next();
      }
      scanner.rewind();
      break;
    case 330:
      entity.ownerHandle = curr.value;
      break;
    case 347:
      entity.materialObjectHandle = curr.value;
      break;
    case 370:
      entity.lineweight = curr.value;
      break;
    case 420:
      entity.color = curr.value;
      break;
    case 1e3:
      entity.extendedData = entity.extendedData || {};
      entity.extendedData.customStrings = entity.extendedData.customStrings || [];
      entity.extendedData.customStrings.push(curr.value);
      break;
    case 1001:
      entity.extendedData = entity.extendedData || {};
      entity.extendedData.applicationName = curr.value;
      break;
    default:
      return false;
  }
  return true;
}
class ThreeDface {
  constructor() {
    this.ForEntityName = "3DFACE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value, vertices: [] };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 70:
          entity.shape = (curr.value & 1) === 1;
          entity.hasContinuousLinetypePattern = (curr.value & 128) === 128;
          break;
        case 10:
          entity.vertices = parse3dFaceVertices(scanner, curr);
          curr = scanner.lastReadGroup;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
function parse3dFaceVertices(scanner, curr) {
  var vertices = [];
  var vertexIsStarted = false;
  var vertexIsFinished = false;
  var verticesPer3dFace = 4;
  for (let i = 0; i <= verticesPer3dFace; i++) {
    var vertex = {};
    while (!scanner.isEOF()) {
      if (curr.code === 0 || vertexIsFinished)
        break;
      switch (curr.code) {
        case 10:
        // X0
        case 11:
        // X1
        case 12:
        // X2
        case 13:
          if (vertexIsStarted) {
            vertexIsFinished = true;
            continue;
          }
          vertex.x = curr.value;
          vertexIsStarted = true;
          break;
        case 20:
        // Y
        case 21:
        case 22:
        case 23:
          vertex.y = curr.value;
          break;
        case 30:
        // Z
        case 31:
        case 32:
        case 33:
          vertex.z = curr.value;
          break;
        default:
          return vertices;
      }
      curr = scanner.next();
    }
    vertices.push(vertex);
    vertexIsStarted = false;
    vertexIsFinished = false;
  }
  scanner.rewind();
  return vertices;
}
class Arc {
  constructor() {
    this.ForEntityName = "ARC";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.center = parsePoint(scanner);
          break;
        case 40:
          entity.radius = curr.value;
          break;
        case 50:
          entity.startAngle = Math.PI / 180 * curr.value;
          break;
        case 51:
          entity.endAngle = Math.PI / 180 * curr.value;
          entity.angleLength = entity.endAngle - entity.startAngle;
          break;
        case 210:
          entity.extrusionDirectionX = curr.value;
          break;
        case 220:
          entity.extrusionDirectionY = curr.value;
          break;
        case 230:
          entity.extrusionDirectionZ = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Attdef {
  constructor() {
    this.ForEntityName = "ATTDEF";
  }
  parseEntity(scanner, curr) {
    var entity = {
      type: curr.value,
      scale: 1,
      textStyle: "STANDARD"
    };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0) {
        break;
      }
      switch (curr.code) {
        case 1:
          entity.text = curr.value;
          break;
        case 2:
          entity.tag = curr.value;
          break;
        case 3:
          entity.prompt = curr.value;
          break;
        case 7:
          entity.textStyle = curr.value;
          break;
        case 10:
          entity.startPoint = parsePoint(scanner);
          break;
        case 11:
          entity.endPoint = parsePoint(scanner);
          break;
        case 39:
          entity.thickness = curr.value;
          break;
        case 40:
          entity.textHeight = curr.value;
          break;
        case 41:
          entity.scale = curr.value;
          break;
        case 50:
          entity.rotation = curr.value;
          break;
        case 51:
          entity.obliqueAngle = curr.value;
          break;
        case 70:
          entity.invisible = !!(curr.value & 1);
          entity.constant = !!(curr.value & 2);
          entity.verificationRequired = !!(curr.value & 4);
          entity.preset = !!(curr.value & 8);
          break;
        case 71:
          entity.backwards = !!(curr.value & 2);
          entity.mirrored = !!(curr.value & 4);
          break;
        case 72:
          entity.horizontalJustification = curr.value;
          break;
        case 73:
          entity.fieldLength = curr.value;
          break;
        case 74:
          entity.verticalJustification = curr.value;
          break;
        case 100:
          break;
        case 210:
          entity.extrusionDirectionX = curr.value;
          break;
        case 220:
          entity.extrusionDirectionY = curr.value;
          break;
        case 230:
          entity.extrusionDirectionZ = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Circle {
  constructor() {
    this.ForEntityName = "CIRCLE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.center = parsePoint(scanner);
          break;
        case 40:
          entity.radius = curr.value;
          break;
        case 50:
          entity.startAngle = Math.PI / 180 * curr.value;
          break;
        case 51:
          const endAngle = Math.PI / 180 * curr.value;
          if (endAngle < entity.startAngle)
            entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;
          else
            entity.angleLength = endAngle - entity.startAngle;
          entity.endAngle = endAngle;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Dimension {
  constructor() {
    this.ForEntityName = "DIMENSION";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 2:
          entity.block = curr.value;
          break;
        case 10:
          entity.anchorPoint = parsePoint(scanner);
          break;
        case 11:
          entity.middleOfText = parsePoint(scanner);
          break;
        case 12:
          entity.insertionPoint = parsePoint(scanner);
          break;
        case 13:
          entity.linearOrAngularPoint1 = parsePoint(scanner);
          break;
        case 14:
          entity.linearOrAngularPoint2 = parsePoint(scanner);
          break;
        case 15:
          entity.diameterOrRadiusPoint = parsePoint(scanner);
          break;
        case 16:
          entity.arcPoint = parsePoint(scanner);
          break;
        case 70:
          entity.dimensionType = curr.value;
          break;
        case 71:
          entity.attachmentPoint = curr.value;
          break;
        case 42:
          entity.actualMeasurement = curr.value;
          break;
        case 1:
          entity.text = curr.value;
          break;
        case 50:
          entity.angle = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Ellipse {
  constructor() {
    this.ForEntityName = "ELLIPSE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.center = parsePoint(scanner);
          break;
        case 11:
          entity.majorAxisEndPoint = parsePoint(scanner);
          break;
        case 40:
          entity.axisRatio = curr.value;
          break;
        case 41:
          entity.startAngle = curr.value;
          break;
        case 42:
          entity.endAngle = curr.value;
          break;
        case 2:
          entity.name = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Insert {
  constructor() {
    this.ForEntityName = "INSERT";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 2:
          entity.name = curr.value;
          break;
        case 41:
          entity.xScale = curr.value;
          break;
        case 42:
          entity.yScale = curr.value;
          break;
        case 43:
          entity.zScale = curr.value;
          break;
        case 10:
          entity.position = parsePoint(scanner);
          break;
        case 50:
          entity.rotation = curr.value;
          break;
        case 70:
          entity.columnCount = curr.value;
          break;
        case 71:
          entity.rowCount = curr.value;
          break;
        case 44:
          entity.columnSpacing = curr.value;
          break;
        case 45:
          entity.rowSpacing = curr.value;
          break;
        case 210:
          entity.extrusionDirection = parsePoint(scanner);
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Line {
  constructor() {
    this.ForEntityName = "LINE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value, vertices: [] };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.vertices.unshift(parsePoint(scanner));
          break;
        case 11:
          entity.vertices.push(parsePoint(scanner));
          break;
        case 210:
          entity.extrusionDirection = parsePoint(scanner);
          break;
        case 100:
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Lwpolyline {
  constructor() {
    this.ForEntityName = "LWPOLYLINE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value, vertices: [] };
    let numberOfVertices = 0;
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 38:
          entity.elevation = curr.value;
          break;
        case 39:
          entity.depth = curr.value;
          break;
        case 70:
          entity.shape = (curr.value & 1) === 1;
          entity.hasContinuousLinetypePattern = (curr.value & 128) === 128;
          break;
        case 90:
          numberOfVertices = curr.value;
          break;
        case 10:
          entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);
          break;
        case 43:
          if (curr.value !== 0)
            entity.width = curr.value;
          break;
        case 210:
          entity.extrusionDirectionX = curr.value;
          break;
        case 220:
          entity.extrusionDirectionY = curr.value;
          break;
        case 230:
          entity.extrusionDirectionZ = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
function parseLWPolylineVertices(n, scanner) {
  if (!n || n <= 0)
    throw Error("n must be greater than 0 verticies");
  const vertices = [];
  let vertexIsStarted = false;
  let vertexIsFinished = false;
  let curr = scanner.lastReadGroup;
  for (let i = 0; i < n; i++) {
    const vertex = {};
    while (!scanner.isEOF()) {
      if (curr.code === 0 || vertexIsFinished)
        break;
      switch (curr.code) {
        case 10:
          if (vertexIsStarted) {
            vertexIsFinished = true;
            continue;
          }
          vertex.x = curr.value;
          vertexIsStarted = true;
          break;
        case 20:
          vertex.y = curr.value;
          break;
        case 30:
          vertex.z = curr.value;
          break;
        case 40:
          vertex.startWidth = curr.value;
          break;
        case 41:
          vertex.endWidth = curr.value;
          break;
        case 42:
          if (curr.value != 0)
            vertex.bulge = curr.value;
          break;
        default:
          scanner.rewind();
          if (vertexIsStarted) {
            vertices.push(vertex);
          }
          scanner.rewind();
          return vertices;
      }
      curr = scanner.next();
    }
    vertices.push(vertex);
    vertexIsStarted = false;
    vertexIsFinished = false;
  }
  scanner.rewind();
  return vertices;
}
class Mtext {
  constructor() {
    this.ForEntityName = "MTEXT";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 3:
          entity.text ? entity.text += curr.value : entity.text = curr.value;
          break;
        case 1:
          entity.text ? entity.text += curr.value : entity.text = curr.value;
          break;
        case 10:
          entity.position = parsePoint(scanner);
          break;
        case 11:
          entity.directionVector = parsePoint(scanner);
          break;
        case 40:
          entity.height = curr.value;
          break;
        case 41:
          entity.width = curr.value;
          break;
        case 50:
          entity.rotation = curr.value;
          break;
        case 71:
          entity.attachmentPoint = curr.value;
          break;
        case 72:
          entity.drawingDirection = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Point {
  constructor() {
    this.ForEntityName = "POINT";
  }
  parseEntity(scanner, curr) {
    const type2 = curr.value;
    const entity = { type: type2 };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.position = parsePoint(scanner);
          break;
        case 39:
          entity.thickness = curr.value;
          break;
        case 210:
          entity.extrusionDirection = parsePoint(scanner);
          break;
        case 100:
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Vertex {
  constructor() {
    this.ForEntityName = "VERTEX";
  }
  parseEntity(scanner, curr) {
    var entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.x = curr.value;
          break;
        case 20:
          entity.y = curr.value;
          break;
        case 30:
          entity.z = curr.value;
          break;
        case 40:
          break;
        case 41:
          break;
        case 42:
          if (curr.value != 0)
            entity.bulge = curr.value;
          break;
        case 70:
          entity.curveFittingVertex = (curr.value & 1) !== 0;
          entity.curveFitTangent = (curr.value & 2) !== 0;
          entity.splineVertex = (curr.value & 8) !== 0;
          entity.splineControlPoint = (curr.value & 16) !== 0;
          entity.threeDPolylineVertex = (curr.value & 32) !== 0;
          entity.threeDPolylineMesh = (curr.value & 64) !== 0;
          entity.polyfaceMeshVertex = (curr.value & 128) !== 0;
          break;
        case 50:
          break;
        case 71:
          entity.faceA = curr.value;
          break;
        case 72:
          entity.faceB = curr.value;
          break;
        case 73:
          entity.faceC = curr.value;
          break;
        case 74:
          entity.faceD = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Polyline {
  constructor() {
    this.ForEntityName = "POLYLINE";
  }
  parseEntity(scanner, curr) {
    var entity = { type: curr.value, vertices: [] };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          break;
        case 20:
          break;
        case 30:
          break;
        case 39:
          entity.thickness = curr.value;
          break;
        case 40:
          break;
        case 41:
          break;
        case 70:
          entity.shape = (curr.value & 1) !== 0;
          entity.includesCurveFitVertices = (curr.value & 2) !== 0;
          entity.includesSplineFitVertices = (curr.value & 4) !== 0;
          entity.is3dPolyline = (curr.value & 8) !== 0;
          entity.is3dPolygonMesh = (curr.value & 16) !== 0;
          entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0;
          entity.isPolyfaceMesh = (curr.value & 64) !== 0;
          entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;
          break;
        case 71:
          break;
        case 72:
          break;
        case 73:
          break;
        case 74:
          break;
        case 75:
          break;
        case 210:
          entity.extrusionDirection = parsePoint(scanner);
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    entity.vertices = parsePolylineVertices(scanner, curr);
    return entity;
  }
}
function parsePolylineVertices(scanner, curr) {
  const vertexParser = new Vertex();
  const vertices = [];
  while (!scanner.isEOF()) {
    if (curr.code === 0) {
      if (curr.value === "VERTEX") {
        vertices.push(vertexParser.parseEntity(scanner, curr));
        curr = scanner.lastReadGroup;
      } else if (curr.value === "SEQEND") {
        parseSeqEnd(scanner, curr);
        break;
      }
    }
  }
  return vertices;
}
function parseSeqEnd(scanner, curr) {
  const entity = { type: curr.value };
  curr = scanner.next();
  while (!scanner.isEOF()) {
    if (curr.code == 0)
      break;
    checkCommonEntityProperties(entity, curr, scanner);
    curr = scanner.next();
  }
  return entity;
}
class Solid {
  constructor() {
    this.ForEntityName = "SOLID";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value, points: [] };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.points[0] = parsePoint(scanner);
          break;
        case 11:
          entity.points[1] = parsePoint(scanner);
          break;
        case 12:
          entity.points[2] = parsePoint(scanner);
          break;
        case 13:
          entity.points[3] = parsePoint(scanner);
          break;
        case 210:
          entity.extrusionDirection = parsePoint(scanner);
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Spline {
  constructor() {
    this.ForEntityName = "SPLINE";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          if (!entity.controlPoints)
            entity.controlPoints = [];
          entity.controlPoints.push(parsePoint(scanner));
          break;
        case 11:
          if (!entity.fitPoints)
            entity.fitPoints = [];
          entity.fitPoints.push(parsePoint(scanner));
          break;
        case 12:
          entity.startTangent = parsePoint(scanner);
          break;
        case 13:
          entity.endTangent = parsePoint(scanner);
          break;
        case 40:
          if (!entity.knotValues)
            entity.knotValues = [];
          entity.knotValues.push(curr.value);
          break;
        case 70:
          if ((curr.value & 1) != 0)
            entity.closed = true;
          if ((curr.value & 2) != 0)
            entity.periodic = true;
          if ((curr.value & 4) != 0)
            entity.rational = true;
          if ((curr.value & 8) != 0)
            entity.planar = true;
          if ((curr.value & 16) != 0) {
            entity.planar = true;
            entity.linear = true;
          }
          break;
        case 71:
          entity.degreeOfSplineCurve = curr.value;
          break;
        case 72:
          entity.numberOfKnots = curr.value;
          break;
        case 73:
          entity.numberOfControlPoints = curr.value;
          break;
        case 74:
          entity.numberOfFitPoints = curr.value;
          break;
        case 210:
          entity.normalVector = parsePoint(scanner);
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
class Text {
  constructor() {
    this.ForEntityName = "TEXT";
  }
  parseEntity(scanner, curr) {
    const entity = { type: curr.value };
    curr = scanner.next();
    while (!scanner.isEOF()) {
      if (curr.code === 0)
        break;
      switch (curr.code) {
        case 10:
          entity.startPoint = parsePoint(scanner);
          break;
        case 11:
          entity.endPoint = parsePoint(scanner);
          break;
        case 40:
          entity.textHeight = curr.value;
          break;
        case 41:
          entity.xScale = curr.value;
          break;
        case 50:
          entity.rotation = curr.value;
          break;
        case 1:
          entity.text = curr.value;
          break;
        // NOTE: 72 and 73 are meaningless without 11 (second alignment point)
        case 72:
          entity.halign = curr.value;
          break;
        case 73:
          entity.valign = curr.value;
          break;
        default:
          checkCommonEntityProperties(entity, curr, scanner);
          break;
      }
      curr = scanner.next();
    }
    return entity;
  }
}
var loglevel$1 = { exports: {} };
var loglevel = loglevel$1.exports;
var hasRequiredLoglevel;
function requireLoglevel() {
  if (hasRequiredLoglevel) return loglevel$1.exports;
  hasRequiredLoglevel = 1;
  (function(module) {
    (function(root, definition) {
      if (module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(loglevel, function() {
      var noop2 = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger2 = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop2;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location2 = cookie.indexOf(cookieName + "=");
              if (location2 !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location2 + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger2 !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger2.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger2 === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger2 ? defaultLogger2.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger2 = new Logger();
      defaultLogger2.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger2.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger2.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger2) {
          window.log = _log;
        }
        return defaultLogger2;
      };
      defaultLogger2.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger2["default"] = defaultLogger2;
      return defaultLogger2;
    });
  })(loglevel$1);
  return loglevel$1.exports;
}
var loglevelExports = requireLoglevel();
const log = /* @__PURE__ */ getDefaultExportFromCjs(loglevelExports);
log.setLevel("error");
function registerDefaultEntityHandlers(dxfParser) {
  dxfParser.registerEntityHandler(ThreeDface);
  dxfParser.registerEntityHandler(Arc);
  dxfParser.registerEntityHandler(Attdef);
  dxfParser.registerEntityHandler(Circle);
  dxfParser.registerEntityHandler(Dimension);
  dxfParser.registerEntityHandler(Ellipse);
  dxfParser.registerEntityHandler(Insert);
  dxfParser.registerEntityHandler(Line);
  dxfParser.registerEntityHandler(Lwpolyline);
  dxfParser.registerEntityHandler(Mtext);
  dxfParser.registerEntityHandler(Point);
  dxfParser.registerEntityHandler(Polyline);
  dxfParser.registerEntityHandler(Solid);
  dxfParser.registerEntityHandler(Spline);
  dxfParser.registerEntityHandler(Text);
}
class DxfParser {
  constructor() {
    this._entityHandlers = {};
    registerDefaultEntityHandlers(this);
  }
  parse(source) {
    if (typeof source === "string") {
      return this._parse(source);
    } else {
      console.error("Cannot read dxf source of type `" + typeof source);
      return null;
    }
  }
  registerEntityHandler(handlerType) {
    const instance = new handlerType();
    this._entityHandlers[instance.ForEntityName] = instance;
  }
  parseSync(source) {
    return this.parse(source);
  }
  parseStream(stream) {
    let dxfString = "";
    const self2 = this;
    return new Promise((res2, rej) => {
      stream.on("data", (chunk) => {
        dxfString += chunk;
      });
      stream.on("end", () => {
        try {
          res2(self2._parse(dxfString));
        } catch (err2) {
          rej(err2);
        }
      });
      stream.on("error", (err2) => {
        rej(err2);
      });
    });
  }
  _parse(dxfString) {
    const dxf = {};
    let lastHandle = 0;
    const dxfLinesArray = dxfString.split(/\r\n|\r|\n/g);
    const scanner = new DxfArrayScanner(dxfLinesArray);
    if (!scanner.hasNext())
      throw Error("Empty file");
    const self2 = this;
    let curr;
    function parseAll() {
      curr = scanner.next();
      while (!scanner.isEOF()) {
        if (curr.code === 0 && curr.value === "SECTION") {
          curr = scanner.next();
          if (curr.code !== 2) {
            console.error("Unexpected code %s after 0:SECTION", debugCode(curr));
            curr = scanner.next();
            continue;
          }
          if (curr.value === "HEADER") {
            log.debug("> HEADER");
            dxf.header = parseHeader();
            log.debug("<");
          } else if (curr.value === "BLOCKS") {
            log.debug("> BLOCKS");
            dxf.blocks = parseBlocks();
            log.debug("<");
          } else if (curr.value === "ENTITIES") {
            log.debug("> ENTITIES");
            dxf.entities = parseEntities(false);
            log.debug("<");
          } else if (curr.value === "TABLES") {
            log.debug("> TABLES");
            dxf.tables = parseTables();
            log.debug("<");
          } else if (curr.value === "EOF") {
            log.debug("EOF");
          } else {
            log.warn("Skipping section '%s'", curr.value);
          }
        } else {
          curr = scanner.next();
        }
      }
    }
    function parseHeader() {
      let currVarName = null;
      let currVarValue = null;
      const header = {};
      curr = scanner.next();
      while (true) {
        if (groupIs(curr, 0, "ENDSEC")) {
          if (currVarName)
            header[currVarName] = currVarValue;
          break;
        } else if (curr.code === 9) {
          if (currVarName)
            header[currVarName] = currVarValue;
          currVarName = curr.value;
        } else {
          if (curr.code === 10) {
            currVarValue = { x: curr.value };
          } else if (curr.code === 20) {
            currVarValue.y = curr.value;
          } else if (curr.code === 30) {
            currVarValue.z = curr.value;
          } else {
            currVarValue = curr.value;
          }
        }
        curr = scanner.next();
      }
      curr = scanner.next();
      return header;
    }
    function parseBlocks() {
      const blocks = {};
      curr = scanner.next();
      while (curr.value !== "EOF") {
        if (groupIs(curr, 0, "ENDSEC")) {
          break;
        }
        if (groupIs(curr, 0, "BLOCK")) {
          log.debug("block {");
          const block = parseBlock();
          log.debug("}");
          ensureHandle(block);
          if (!block.name)
            log.error('block with handle "' + block.handle + '" is missing a name.');
          else
            blocks[block.name] = block;
        } else {
          logUnhandledGroup(curr);
          curr = scanner.next();
        }
      }
      return blocks;
    }
    function parseBlock() {
      const block = {};
      curr = scanner.next();
      while (curr.value !== "EOF") {
        switch (curr.code) {
          case 1:
            block.xrefPath = curr.value;
            curr = scanner.next();
            break;
          case 2:
            block.name = curr.value;
            curr = scanner.next();
            break;
          case 3:
            block.name2 = curr.value;
            curr = scanner.next();
            break;
          case 5:
            block.handle = curr.value;
            curr = scanner.next();
            break;
          case 8:
            block.layer = curr.value;
            curr = scanner.next();
            break;
          case 10:
            block.position = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 67:
            block.paperSpace = curr.value && curr.value == 1 ? true : false;
            curr = scanner.next();
            break;
          case 70:
            if (curr.value != 0) {
              block.type = curr.value;
            }
            curr = scanner.next();
            break;
          case 100:
            curr = scanner.next();
            break;
          case 330:
            block.ownerHandle = curr.value;
            curr = scanner.next();
            break;
          case 0:
            if (curr.value == "ENDBLK")
              break;
            block.entities = parseEntities(true);
            break;
          default:
            logUnhandledGroup(curr);
            curr = scanner.next();
        }
        if (groupIs(curr, 0, "ENDBLK")) {
          curr = scanner.next();
          break;
        }
      }
      return block;
    }
    function parseTables() {
      const tables = {};
      curr = scanner.next();
      while (curr.value !== "EOF") {
        if (groupIs(curr, 0, "ENDSEC"))
          break;
        if (groupIs(curr, 0, "TABLE")) {
          curr = scanner.next();
          const tableDefinition = tableDefinitions[curr.value];
          if (tableDefinition) {
            log.debug(curr.value + " Table {");
            tables[tableDefinitions[curr.value].tableName] = parseTable2(curr);
            log.debug("}");
          } else {
            log.debug("Unhandled Table " + curr.value);
          }
        } else {
          curr = scanner.next();
        }
      }
      curr = scanner.next();
      return tables;
    }
    const END_OF_TABLE_VALUE = "ENDTAB";
    function parseTable2(group) {
      const tableDefinition = tableDefinitions[group.value];
      const table = {};
      let expectedCount = 0;
      curr = scanner.next();
      while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {
        switch (curr.code) {
          case 5:
            table.handle = curr.value;
            curr = scanner.next();
            break;
          case 330:
            table.ownerHandle = curr.value;
            curr = scanner.next();
            break;
          case 100:
            if (curr.value === "AcDbSymbolTable") {
              curr = scanner.next();
            } else {
              logUnhandledGroup(curr);
              curr = scanner.next();
            }
            break;
          case 70:
            expectedCount = curr.value;
            curr = scanner.next();
            break;
          case 0:
            if (curr.value === tableDefinition.dxfSymbolName) {
              table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();
            } else {
              logUnhandledGroup(curr);
              curr = scanner.next();
            }
            break;
          default:
            logUnhandledGroup(curr);
            curr = scanner.next();
        }
      }
      const tableRecords = table[tableDefinition.tableRecordsProperty];
      if (tableRecords) {
        let actualCount = (() => {
          if (tableRecords.constructor === Array) {
            return tableRecords.length;
          } else if (typeof tableRecords === "object") {
            return Object.keys(tableRecords).length;
          }
          return void 0;
        })();
        if (expectedCount !== actualCount)
          log.warn("Parsed " + actualCount + " " + tableDefinition.dxfSymbolName + "'s but expected " + expectedCount);
      }
      curr = scanner.next();
      return table;
    }
    function parseViewPortRecords() {
      const viewPorts = [];
      let viewPort = {};
      log.debug("ViewPort {");
      curr = scanner.next();
      while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {
        switch (curr.code) {
          case 2:
            viewPort.name = curr.value;
            curr = scanner.next();
            break;
          case 10:
            viewPort.lowerLeftCorner = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 11:
            viewPort.upperRightCorner = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 12:
            viewPort.center = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 13:
            viewPort.snapBasePoint = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 14:
            viewPort.snapSpacing = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 15:
            viewPort.gridSpacing = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 16:
            viewPort.viewDirectionFromTarget = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 17:
            viewPort.viewTarget = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 42:
            viewPort.lensLength = curr.value;
            curr = scanner.next();
            break;
          case 43:
            viewPort.frontClippingPlane = curr.value;
            curr = scanner.next();
            break;
          case 44:
            viewPort.backClippingPlane = curr.value;
            curr = scanner.next();
            break;
          case 45:
            viewPort.viewHeight = curr.value;
            curr = scanner.next();
            break;
          case 50:
            viewPort.snapRotationAngle = curr.value;
            curr = scanner.next();
            break;
          case 51:
            viewPort.viewTwistAngle = curr.value;
            curr = scanner.next();
            break;
          case 79:
            viewPort.orthographicType = curr.value;
            curr = scanner.next();
            break;
          case 110:
            viewPort.ucsOrigin = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 111:
            viewPort.ucsXAxis = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 112:
            viewPort.ucsYAxis = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 110:
            viewPort.ucsOrigin = parsePoint2(curr);
            curr = scanner.next();
            break;
          case 281:
            viewPort.renderMode = curr.value;
            curr = scanner.next();
            break;
          case 281:
            viewPort.defaultLightingType = curr.value;
            curr = scanner.next();
            break;
          case 292:
            viewPort.defaultLightingOn = curr.value;
            curr = scanner.next();
            break;
          case 330:
            viewPort.ownerHandle = curr.value;
            curr = scanner.next();
            break;
          case 63:
          // These are all ambient color. Perhaps should be a gradient when multiple are set.
          case 421:
          case 431:
            viewPort.ambientColor = curr.value;
            curr = scanner.next();
            break;
          case 0:
            if (curr.value === "VPORT") {
              log.debug("}");
              viewPorts.push(viewPort);
              log.debug("ViewPort {");
              viewPort = {};
              curr = scanner.next();
            }
            break;
          default:
            logUnhandledGroup(curr);
            curr = scanner.next();
            break;
        }
      }
      log.debug("}");
      viewPorts.push(viewPort);
      return viewPorts;
    }
    function parseLineTypes() {
      const ltypes = {};
      let ltype = {};
      let length = 0;
      let ltypeName;
      log.debug("LType {");
      curr = scanner.next();
      while (!groupIs(curr, 0, "ENDTAB")) {
        switch (curr.code) {
          case 2:
            ltype.name = curr.value;
            ltypeName = curr.value;
            curr = scanner.next();
            break;
          case 3:
            ltype.description = curr.value;
            curr = scanner.next();
            break;
          case 73:
            length = curr.value;
            if (length > 0)
              ltype.pattern = [];
            curr = scanner.next();
            break;
          case 40:
            ltype.patternLength = curr.value;
            curr = scanner.next();
            break;
          case 49:
            ltype.pattern.push(curr.value);
            curr = scanner.next();
            break;
          case 0:
            log.debug("}");
            if (length > 0 && length !== ltype.pattern.length)
              log.warn("lengths do not match on LTYPE pattern");
            ltypes[ltypeName] = ltype;
            ltype = {};
            log.debug("LType {");
            curr = scanner.next();
            break;
          default:
            curr = scanner.next();
        }
      }
      log.debug("}");
      ltypes[ltypeName] = ltype;
      return ltypes;
    }
    function parseLayers() {
      const layers = {};
      let layer = {};
      let layerName;
      log.debug("Layer {");
      curr = scanner.next();
      while (!groupIs(curr, 0, "ENDTAB")) {
        switch (curr.code) {
          case 2:
            layer.name = curr.value;
            layerName = curr.value;
            curr = scanner.next();
            break;
          case 62:
            layer.visible = curr.value >= 0;
            layer.colorIndex = Math.abs(curr.value);
            layer.color = getAcadColor(layer.colorIndex);
            curr = scanner.next();
            break;
          case 70:
            layer.frozen = (curr.value & 1) != 0 || (curr.value & 2) != 0;
            curr = scanner.next();
            break;
          case 0:
            if (curr.value === "LAYER") {
              log.debug("}");
              layers[layerName] = layer;
              log.debug("Layer {");
              layer = {};
              layerName = void 0;
              curr = scanner.next();
            }
            break;
          default:
            logUnhandledGroup(curr);
            curr = scanner.next();
            break;
        }
      }
      log.debug("}");
      layers[layerName] = layer;
      return layers;
    }
    const tableDefinitions = {
      VPORT: {
        tableRecordsProperty: "viewPorts",
        tableName: "viewPort",
        dxfSymbolName: "VPORT",
        parseTableRecords: parseViewPortRecords
      },
      LTYPE: {
        tableRecordsProperty: "lineTypes",
        tableName: "lineType",
        dxfSymbolName: "LTYPE",
        parseTableRecords: parseLineTypes
      },
      LAYER: {
        tableRecordsProperty: "layers",
        tableName: "layer",
        dxfSymbolName: "LAYER",
        parseTableRecords: parseLayers
      }
    };
    function parseEntities(forBlock) {
      const entities = [];
      const endingOnValue = forBlock ? "ENDBLK" : "ENDSEC";
      if (!forBlock) {
        curr = scanner.next();
      }
      while (true) {
        if (curr.code === 0) {
          if (curr.value === endingOnValue) {
            break;
          }
          const handler = self2._entityHandlers[curr.value];
          if (handler != null) {
            log.debug(curr.value + " {");
            const entity = handler.parseEntity(scanner, curr);
            curr = scanner.lastReadGroup;
            log.debug("}");
            ensureHandle(entity);
            entities.push(entity);
          } else {
            log.warn("Unhandled entity " + curr.value);
            curr = scanner.next();
            continue;
          }
        } else {
          curr = scanner.next();
        }
      }
      if (endingOnValue == "ENDSEC")
        curr = scanner.next();
      return entities;
    }
    function parsePoint2(curr2) {
      const point = {};
      let code2 = curr2.code;
      point.x = curr2.value;
      code2 += 10;
      curr2 = scanner.next();
      if (curr2.code != code2)
        throw new Error("Expected code for point value to be " + code2 + " but got " + curr2.code + ".");
      point.y = curr2.value;
      code2 += 10;
      curr2 = scanner.next();
      if (curr2.code != code2) {
        scanner.rewind();
        return point;
      }
      point.z = curr2.value;
      return point;
    }
    function ensureHandle(entity) {
      if (!entity)
        throw new TypeError("entity cannot be undefined or null");
      if (!entity.handle)
        entity.handle = lastHandle++;
    }
    parseAll();
    return dxf;
  }
}
function groupIs(group, code2, value) {
  return group.code === code2 && group.value === value;
}
function logUnhandledGroup(curr) {
  log.debug("unhandled group " + debugCode(curr));
}
function debugCode(curr) {
  return curr.code + ":" + curr.value;
}
function getAcadColor(index) {
  return AUTO_CAD_COLOR_INDEX[index];
}
const PORT = 6002;
function createWindow() {
  const win = new electron.BrowserWindow({
    width: 1400,
    height: 900,
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      nodeIntegration: false,
      contextIsolation: true
    },
    titleBarStyle: "hidden",
    trafficLightPosition: { x: 10, y: 10 }
  });
  win.webContents.openDevTools();
  win.webContents.on("did-finish-load", () => {
    win.webContents.send("api-port", PORT);
    console.log(`Sent API port ${PORT} to renderer`);
  });
  if (process.env.VITE_DEV_SERVER_URL) {
    win.loadURL(process.env.VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path.join(__dirname, "../renderer/index.html"));
  }
}
electron.ipcMain.handle("parse-dxf", async (_event, content) => {
  const parser = new DxfParser();
  try {
    return parser.parseSync(content);
  } catch (err2) {
    console.error("DXF Parse Error:", err2);
    throw err2;
  }
});
electron.app.whenReady().then(async () => {
  try {
    await startServer(PORT);
    createWindow();
  } catch (err2) {
    console.error("Failed to start server:", err2);
  }
  electron.app.on("activate", () => {
    if (electron.BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") electron.app.quit();
});
